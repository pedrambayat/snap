<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 79b7cf00-d0eb-459f-b39b-4d401b2ae276 (2026-02-04 03:00Z) -->

# 2025-02-03 plans document goals (2026-02-04 03:00Z)

_**User**_

based on @notes/2025-02-03 plans.pd  and your understanding of the codebase, come  up with a detailed plan for how to achieve the goals stated in the plans document and provide them to me.

---

_**Agent (model default, mode Agent)**_





---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/notes/2025-02-03 plans.pd</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/README.md</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "/home/ec2-user/snap"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "/home/ec2-user/snap",
    "childrenDirs": [
      {
        "absPath": "/home/ec2-user/snap/.specstory",
        "childrenFiles": [
          {
            "name": ".project.json"
          },
          {
            "name": ".what-is-this.md"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/home/ec2-user/snap/cd19-mber",
        "childrenDirs": [
          {
            "absPath": "/home/ec2-user/snap/cd19-mber/config_data",
            "childrenFiles": [
              {
                "name": "config_data.json"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "/home/ec2-user/snap/cd19-mber/evaluation_data",
            "childrenDirs": [
              {
                "absPath": "/home/ec2-user/snap/cd19-mber/evaluation_data/binders",
                "childrenFiles": [
                  {
                    "name": "CD19_5896319_binder-0_iptm-0.1442_complex.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-0_iptm-0.1442_monomer.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-0_iptm-0.1442_relaxed.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-1_iptm-0.1779_complex.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-1_iptm-0.1779_monomer.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-1_iptm-0.1779_relaxed.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-2_iptm-0.1752_complex.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-2_iptm-0.1752_monomer.pdb"
                  },
                  {
                    "name": "CD19_5896319_binder-2_iptm-0.1752_relaxed.pdb"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenFiles": [
              {
                "name": "evaluation_data.json"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "/home/ec2-user/snap/cd19-mber/protocol_info",
            "childrenFiles": [
              {
                "name": "protocol_info.json"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "/home/ec2-user/snap/cd19-mber/template_data",
            "childrenFiles": [
              {
                "name": "full_target_pdb.pdb"
              },
              {
                "name": "template_data.json"
              },
              {
                "name": "template_pdb.pdb"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "/home/ec2-user/snap/cd19-mber/trajectory_data",
            "childrenFiles": [
              {
                "name": "best_pdb.pdb"
              },
              {
                "name": "trajectory_data.json"
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": "cd19-pipeline-linear.py"
          },
          {
            "name": "design_state.pickle"
          },
          {
            "name": "design_summary.yaml"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/home/ec2-user/snap/CHL1",
        "childrenDirs": [
          {
            "absPath": "/home/ec2-user/snap/CHL1/fasta",
            "childrenFiles": [
              {
                "name": "variant_a.fasta"
              },
              {
                "name": "variant_b.fasta"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "/home/ec2-user/snap/CHL1/snap",
            "childrenDirs": [
              {
                "absPath": "/home/ec2-user/snap/CHL1/snap/CHL1",
                "childrenDirs": [
                  {
                    "absPath": "/home/ec2-user/snap/CHL1/snap/CHL1/colabfold_results",
                    "childrenFiles": [
                      {
                        "name": "log.txt"
                      }
                    ],
                    "childrenWereProcessed": true
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": "run_colabfold_chl1.sh"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/home/ec2-user/snap/mber-open",
        "childrenDirs": [
          {
            "absPath": "/home/ec2-user/snap/mber-open/assets",
            "childrenFiles": [
              {
                "name": "mBER_graphical_abstract.png"
              }
            ],
            "childrenWereProcessed": true
          },
          {
            "absPath": "/home/ec2-user/snap/mber-open/notebooks",
            "fullSubtreeExtensionCounts": {
              ".ipynb": 1,
              "": 2
            },
            "numFiles": 3
          },
          {
            "absPath": "/home/ec2-user/snap/mber-open/protocols",
            "childrenDirs": [
              {
                "absPath": "/home/ec2-user/snap/mber-open/protocols/src",
                "childrenDirs": [
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols",
                    "childrenDirs": [
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design",
                            "childrenDirs": [
                              {
                                "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design/examples",
                                "childrenFiles": [
                                  {
                                    "name": "PDL1.pdb"
                                  },
                                  {
                                    "name": "vhh_settings_example.yml"
                                  }
                                ],
                                "childrenWereProcessed": true
                              }
                            ],
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "cli.py"
                              },
                              {
                                "name": "config.py"
                              },
                              {
                                "name": "evaluation.py"
                              },
                              {
                                "name": "pipeline.py"
                              },
                              {
                                "name": "state.py"
                              },
                              {
                                "name": "template.py"
                              },
                              {
                                "name": "trajectory.py"
                              },
                              {
                                "name": "VHH_CLI.md"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenWereProcessed": true
                      }
                    ],
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "version.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenFiles": [
              {
                "name": "setup.py"
              }
            ],
            "fullSubtreeExtensionCounts": {
              ".md": 1
            },
            "numFiles": 1
          },
          {
            "absPath": "/home/ec2-user/snap/mber-open/src",
            "childrenDirs": [
              {
                "absPath": "/home/ec2-user/snap/mber-open/src/mber",
                "childrenDirs": [
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/core",
                    "childrenDirs": [
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/core/data",
                        "fullSubtreeExtensionCounts": {
                          ".py": 3
                        },
                        "numFiles": 3
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/core/modules",
                        "fullSubtreeExtensionCounts": {
                          ".py": 6
                        },
                        "numFiles": 6
                      }
                    ],
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "README.md"
                      },
                      {
                        "name": "sasa.py"
                      },
                      {
                        "name": "truncation.py"
                      }
                    ],
                    "childrenWereProcessed": true,
                    "fullSubtreeExtensionCounts": {
                      ".py": 10
                    },
                    "numFiles": 10
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/models",
                    "childrenDirs": [
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/common",
                            "childrenDirs": [
                              {
                                "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/common/testdata",
                                "fullSubtreeExtensionCounts": {
                                  ".pdb": 3
                                },
                                "numFiles": 3
                              }
                            ],
                            "fullSubtreeExtensionCounts": {
                              ".py": 8,
                              ".txt": 1,
                              ".pdb": 3
                            },
                            "numFiles": 12
                          },
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/data",
                            "childrenDirs": [
                              {
                                "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/data/tools",
                                "childrenFiles": [
                                  {
                                    "name": "__init__.py"
                                  },
                                  {
                                    "name": "hhblits.py"
                                  },
                                  {
                                    "name": "hhsearch.py"
                                  },
                                  {
                                    "name": "hmmbuild.py"
                                  },
                                  {
                                    "name": "hmmsearch.py"
                                  },
                                  {
                                    "name": "jackhmmer.py"
                                  },
                                  {
                                    "name": "kalign.py"
                                  },
                                  {
                                    "name": "utils.py"
                                  }
                                ],
                                "childrenWereProcessed": true
                              }
                            ],
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "feature_processing.py"
                              },
                              {
                                "name": "mmcif_parsing.py"
                              },
                              {
                                "name": "msa_identifiers.py"
                              },
                              {
                                "name": "msa_pairing.py"
                              },
                              {
                                "name": "parsers.py"
                              },
                              {
                                "name": "pipeline_multimer.py"
                              },
                              {
                                "name": "pipeline.py"
                              },
                              {
                                "name": "templates.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          },
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/model",
                            "childrenDirs": [
                              {
                                "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/model/geometry",
                                "childrenFiles": [
                                  {
                                    "name": "__init__.py"
                                  },
                                  {
                                    "name": "rigid_matrix_vector.py"
                                  },
                                  {
                                    "name": "rotation_matrix.py"
                                  },
                                  {
                                    "name": "struct_of_array.py"
                                  },
                                  {
                                    "name": "test_utils.py"
                                  },
                                  {
                                    "name": "utils.py"
                                  },
                                  {
                                    "name": "vector.py"
                                  }
                                ],
                                "childrenWereProcessed": true
                              },
                              {
                                "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/model/tf",
                                "childrenFiles": [
                                  {
                                    "name": "__init__.py"
                                  },
                                  {
                                    "name": "data_transforms.py"
                                  },
                                  {
                                    "name": "input_pipeline.py"
                                  },
                                  {
                                    "name": "protein_features_test.py"
                                  },
                                  {
                                    "name": "protein_features.py"
                                  },
                                  {
                                    "name": "proteins_dataset.py"
                                  },
                                  {
                                    "name": "shape_helpers_test.py"
                                  },
                                  {
                                    "name": "shape_helpers.py"
                                  },
                                  {
                                    "name": "shape_placeholders.py"
                                  },
                                  {
                                    "name": "utils.py"
                                  }
                                ],
                                "childrenWereProcessed": true
                              }
                            ],
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "all_atom_multimer.py"
                              },
                              {
                                "name": "all_atom_test.py"
                              },
                              {
                                "name": "all_atom.py"
                              },
                              {
                                "name": "common_modules.py"
                              },
                              {
                                "name": "config.py"
                              },
                              {
                                "name": "data.py"
                              },
                              {
                                "name": "features.py"
                              },
                              {
                                "name": "folding_multimer.py"
                              },
                              {
                                "name": "folding.py"
                              },
                              {
                                "name": "layer_stack_test.py"
                              },
                              {
                                "name": "layer_stack.py"
                              },
                              {
                                "name": "lddt_test.py"
                              },
                              {
                                "name": "lddt.py"
                              },
                              {
                                "name": "mapping.py"
                              },
                              {
                                "name": "model.py"
                              },
                              {
                                "name": "modules_multimer.py"
                              },
                              {
                                "name": "modules.py"
                              },
                              {
                                "name": "prng_test.py"
                              },
                              {
                                "name": "prng.py"
                              },
                              {
                                "name": "quat_affine_test.py"
                              },
                              {
                                "name": "quat_affine.py"
                              },
                              {
                                "name": "r3.py"
                              },
                              {
                                "name": "utils.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          },
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/notebooks",
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "notebook_utils_test.py"
                              },
                              {
                                "name": "notebook_utils.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          },
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/relax",
                            "childrenDirs": [
                              {
                                "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/relax/testdata",
                                "childrenFiles": [
                                  {
                                    "name": "model_output.pdb"
                                  },
                                  {
                                    "name": "multiple_disulfides_target.pdb"
                                  },
                                  {
                                    "name": "with_violations_casp14.pdb"
                                  },
                                  {
                                    "name": "with_violations.pdb"
                                  }
                                ],
                                "childrenWereProcessed": true
                              }
                            ],
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "amber_minimize_test.py"
                              },
                              {
                                "name": "amber_minimize.py"
                              },
                              {
                                "name": "cleanup_test.py"
                              },
                              {
                                "name": "cleanup.py"
                              },
                              {
                                "name": "relax_test.py"
                              },
                              {
                                "name": "relax.py"
                              },
                              {
                                "name": "utils_test.py"
                              },
                              {
                                "name": "utils.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenFiles": [
                          {
                            "name": "LICENSE"
                          },
                          {
                            "name": "version.py"
                          }
                        ],
                        "childrenWereProcessed": true,
                        "fullSubtreeExtensionCounts": {
                          ".py": 9,
                          ".txt": 1,
                          ".pdb": 3
                        },
                        "numFiles": 13
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/colabdesign",
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "design.py"
                          },
                          {
                            "name": "inputs.py"
                          },
                          {
                            "name": "loss.py"
                          },
                          {
                            "name": "model.py"
                          },
                          {
                            "name": "optimizer.py"
                          },
                          {
                            "name": "prep.py"
                          },
                          {
                            "name": "README.md"
                          },
                          {
                            "name": "utils.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/colabfold",
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "relax.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/folding",
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "abb2_model.py"
                          },
                          {
                            "name": "af2_model.py"
                          },
                          {
                            "name": "esmfold_model.py"
                          },
                          {
                            "name": "folding_model_bases.py"
                          },
                          {
                            "name": "nbb2_model.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/plm",
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "ablang2_model.py"
                          },
                          {
                            "name": "esm2_model.py"
                          },
                          {
                            "name": "plm_model_bases.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      }
                    ],
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      }
                    ],
                    "childrenWereProcessed": true,
                    "fullSubtreeExtensionCounts": {
                      ".py": 9,
                      ".txt": 1,
                      ".pdb": 3
                    },
                    "numFiles": 13
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/utils",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "pdb_utils.py"
                      },
                      {
                        "name": "plm_utils.py"
                      },
                      {
                        "name": "plotting.py"
                      },
                      {
                        "name": "regions.py"
                      },
                      {
                        "name": "timing_summary.py"
                      },
                      {
                        "name": "timing_utils.py"
                      },
                      {
                        "name": "yaml_summary_utils.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  }
                ],
                "childrenWereProcessed": true,
                "fullSubtreeExtensionCounts": {
                  ".py": 19,
                  ".txt": 1,
                  ".pdb": 3
                },
                "numFiles": 23
              }
            ],
            "childrenWereProcessed": true,
            "fullSubtreeExtensionCounts": {
              ".py": 19,
              ".txt": 1,
              ".pdb": 3
            },
            "numFiles": 23
          }
        ],
        "childrenFiles": [
          {
            "name": ".git"
          },
          {
            "name": ".gitignore"
          },
          {
            "name": "CONTRIBUTING.md"
          },
          {
            "name": "download_af_weights.sh"
          },
          {
            "name": "environment.yml"
          },
          {
            "name": "LICENSE"
          },
          {
            "name": "README.md"
          },
          {
            "name": "requirements.txt"
          },
          {
            "name": "setup.py"
          }
        ],
        "fullSubtreeExtensionCounts": {
          ".md": 1,
          ".py": 19,
          ".txt": 1,
          ".ipynb": 1,
          "": 2,
          ".pdb": 3
        },
        "numFiles": 27
      }
    ],
    "childrenFiles": [
      {
        "name": ".DS_Store"
      },
      {
        "name": ".gitignore"
      },
      {
        "name": ".gitmodules"
      },
      {
        "name": "README.md"
      }
    ],
    "fullSubtreeExtensionCounts": {
      ".md": 1,
      ".py": 19,
      ".txt": 1,
      ".ipynb": 1,
      "": 2,
      ".pdb": 3
    },
    "numFiles": 27
  }
}
```
Status: **completed**


</details>
</tool-use>

---


Exploring the codebase to see how mBER works, how the CD19 pipeline runs, and how CHL1 variants are set up.


---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "/home/ec2-user/snap/mber-open"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "/home/ec2-user/snap/mber-open",
    "childrenDirs": [
      {
        "absPath": "/home/ec2-user/snap/mber-open/assets",
        "childrenFiles": [
          {
            "name": "mBER_graphical_abstract.png"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/home/ec2-user/snap/mber-open/notebooks",
        "childrenFiles": [
          {
            "name": ".gitattributes"
          },
          {
            "name": ".gitignore"
          },
          {
            "name": "template_trajectory_evaluation_example_PDL1.ipynb"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/home/ec2-user/snap/mber-open/protocols",
        "childrenDirs": [
          {
            "absPath": "/home/ec2-user/snap/mber-open/protocols/src",
            "childrenDirs": [
              {
                "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols",
                "childrenDirs": [
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable",
                    "childrenDirs": [
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design/examples",
                            "childrenFiles": [
                              {
                                "name": "PDL1.pdb"
                              },
                              {
                                "name": "vhh_settings_example.yml"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "cli.py"
                          },
                          {
                            "name": "config.py"
                          },
                          {
                            "name": "evaluation.py"
                          },
                          {
                            "name": "pipeline.py"
                          },
                          {
                            "name": "state.py"
                          },
                          {
                            "name": "template.py"
                          },
                          {
                            "name": "trajectory.py"
                          },
                          {
                            "name": "VHH_CLI.md"
                          }
                        ],
                        "childrenWereProcessed": true
                      }
                    ],
                    "childrenWereProcessed": true
                  }
                ],
                "childrenFiles": [
                  {
                    "name": "__init__.py"
                  },
                  {
                    "name": "version.py"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenFiles": [
          {
            "name": "README.md"
          },
          {
            "name": "setup.py"
          }
        ],
        "childrenWereProcessed": true
      },
      {
        "absPath": "/home/ec2-user/snap/mber-open/src",
        "childrenDirs": [
          {
            "absPath": "/home/ec2-user/snap/mber-open/src/mber",
            "childrenDirs": [
              {
                "absPath": "/home/ec2-user/snap/mber-open/src/mber/core",
                "childrenDirs": [
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/core/data",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "serializable.py"
                      },
                      {
                        "name": "state.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/core/modules",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "base.py"
                      },
                      {
                        "name": "config.py"
                      },
                      {
                        "name": "evaluation.py"
                      },
                      {
                        "name": "template.py"
                      },
                      {
                        "name": "trajectory.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  }
                ],
                "childrenFiles": [
                  {
                    "name": "__init__.py"
                  },
                  {
                    "name": "logging.py"
                  },
                  {
                    "name": "README.md"
                  },
                  {
                    "name": "sasa.py"
                  },
                  {
                    "name": "truncation.py"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "/home/ec2-user/snap/mber-open/src/mber/models",
                "childrenDirs": [
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold",
                    "childrenDirs": [
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/common",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/common/testdata",
                            "childrenFiles": [
                              {
                                "name": "2rbg.pdb"
                              },
                              {
                                "name": "5nmu.pdb"
                              },
                              {
                                "name": "glucagon.pdb"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "confidence_test.py"
                          },
                          {
                            "name": "confidence.py"
                          },
                          {
                            "name": "mmcif_metadata.py"
                          },
                          {
                            "name": "protein_test.py"
                          },
                          {
                            "name": "protein.py"
                          },
                          {
                            "name": "residue_constants_test.py"
                          },
                          {
                            "name": "residue_constants.py"
                          },
                          {
                            "name": "stereo_chemical_props.txt"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/data",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/data/tools",
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "hhblits.py"
                              },
                              {
                                "name": "hhsearch.py"
                              },
                              {
                                "name": "hmmbuild.py"
                              },
                              {
                                "name": "hmmsearch.py"
                              },
                              {
                                "name": "jackhmmer.py"
                              },
                              {
                                "name": "kalign.py"
                              },
                              {
                                "name": "utils.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "feature_processing.py"
                          },
                          {
                            "name": "mmcif_parsing.py"
                          },
                          {
                            "name": "msa_identifiers.py"
                          },
                          {
                            "name": "msa_pairing.py"
                          },
                          {
                            "name": "parsers.py"
                          },
                          {
                            "name": "pipeline_multimer.py"
                          },
                          {
                            "name": "pipeline.py"
                          },
                          {
                            "name": "templates.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/model",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/model/geometry",
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "rigid_matrix_vector.py"
                              },
                              {
                                "name": "rotation_matrix.py"
                              },
                              {
                                "name": "struct_of_array.py"
                              },
                              {
                                "name": "test_utils.py"
                              },
                              {
                                "name": "utils.py"
                              },
                              {
                                "name": "vector.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          },
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/model/tf",
                            "childrenFiles": [
                              {
                                "name": "__init__.py"
                              },
                              {
                                "name": "data_transforms.py"
                              },
                              {
                                "name": "input_pipeline.py"
                              },
                              {
                                "name": "protein_features_test.py"
                              },
                              {
                                "name": "protein_features.py"
                              },
                              {
                                "name": "proteins_dataset.py"
                              },
                              {
                                "name": "shape_helpers_test.py"
                              },
                              {
                                "name": "shape_helpers.py"
                              },
                              {
                                "name": "shape_placeholders.py"
                              },
                              {
                                "name": "utils.py"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "all_atom_multimer.py"
                          },
                          {
                            "name": "all_atom_test.py"
                          },
                          {
                            "name": "all_atom.py"
                          },
                          {
                            "name": "common_modules.py"
                          },
                          {
                            "name": "config.py"
                          },
                          {
                            "name": "data.py"
                          },
                          {
                            "name": "features.py"
                          },
                          {
                            "name": "folding_multimer.py"
                          },
                          {
                            "name": "folding.py"
                          },
                          {
                            "name": "layer_stack_test.py"
                          },
                          {
                            "name": "layer_stack.py"
                          },
                          {
                            "name": "lddt_test.py"
                          },
                          {
                            "name": "lddt.py"
                          },
                          {
                            "name": "mapping.py"
                          },
                          {
                            "name": "model.py"
                          },
                          {
                            "name": "modules_multimer.py"
                          },
                          {
                            "name": "modules.py"
                          },
                          {
                            "name": "prng_test.py"
                          },
                          {
                            "name": "prng.py"
                          },
                          {
                            "name": "quat_affine_test.py"
                          },
                          {
                            "name": "quat_affine.py"
                          },
                          {
                            "name": "r3.py"
                          },
                          {
                            "name": "utils.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/notebooks",
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "notebook_utils_test.py"
                          },
                          {
                            "name": "notebook_utils.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      },
                      {
                        "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/relax",
                        "childrenDirs": [
                          {
                            "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/alphafold/relax/testdata",
                            "childrenFiles": [
                              {
                                "name": "model_output.pdb"
                              },
                              {
                                "name": "multiple_disulfides_target.pdb"
                              },
                              {
                                "name": "with_violations_casp14.pdb"
                              },
                              {
                                "name": "with_violations.pdb"
                              }
                            ],
                            "childrenWereProcessed": true
                          }
                        ],
                        "childrenFiles": [
                          {
                            "name": "__init__.py"
                          },
                          {
                            "name": "amber_minimize_test.py"
                          },
                          {
                            "name": "amber_minimize.py"
                          },
                          {
                            "name": "cleanup_test.py"
                          },
                          {
                            "name": "cleanup.py"
                          },
                          {
                            "name": "relax_test.py"
                          },
                          {
                            "name": "relax.py"
                          },
                          {
                            "name": "utils_test.py"
                          },
                          {
                            "name": "utils.py"
                          }
                        ],
                        "childrenWereProcessed": true
                      }
                    ],
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "LICENSE"
                      },
                      {
                        "name": "version.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/colabdesign",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "design.py"
                      },
                      {
                        "name": "inputs.py"
                      },
                      {
                        "name": "loss.py"
                      },
                      {
                        "name": "model.py"
                      },
                      {
                        "name": "optimizer.py"
                      },
                      {
                        "name": "prep.py"
                      },
                      {
                        "name": "README.md"
                      },
                      {
                        "name": "utils.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/colabfold",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "relax.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/folding",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "abb2_model.py"
                      },
                      {
                        "name": "af2_model.py"
                      },
                      {
                        "name": "esmfold_model.py"
                      },
                      {
                        "name": "folding_model_bases.py"
                      },
                      {
                        "name": "nbb2_model.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  },
                  {
                    "absPath": "/home/ec2-user/snap/mber-open/src/mber/models/plm",
                    "childrenFiles": [
                      {
                        "name": "__init__.py"
                      },
                      {
                        "name": "ablang2_model.py"
                      },
                      {
                        "name": "esm2_model.py"
                      },
                      {
                        "name": "plm_model_bases.py"
                      }
                    ],
                    "childrenWereProcessed": true
                  }
                ],
                "childrenFiles": [
                  {
                    "name": "__init__.py"
                  }
                ],
                "childrenWereProcessed": true
              },
              {
                "absPath": "/home/ec2-user/snap/mber-open/src/mber/utils",
                "childrenFiles": [
                  {
                    "name": "__init__.py"
                  },
                  {
                    "name": "pdb_utils.py"
                  },
                  {
                    "name": "plm_utils.py"
                  },
                  {
                    "name": "plotting.py"
                  },
                  {
                    "name": "regions.py"
                  },
                  {
                    "name": "timing_summary.py"
                  },
                  {
                    "name": "timing_utils.py"
                  },
                  {
                    "name": "yaml_summary_utils.py"
                  }
                ],
                "childrenWereProcessed": true
              }
            ],
            "childrenWereProcessed": true
          }
        ],
        "childrenWereProcessed": true
      }
    ],
    "childrenFiles": [
      {
        "name": ".git"
      },
      {
        "name": ".gitignore"
      },
      {
        "name": "CONTRIBUTING.md"
      },
      {
        "name": "download_af_weights.sh"
      },
      {
        "name": "environment.yml"
      },
      {
        "name": "LICENSE"
      },
      {
        "name": "README.md"
      },
      {
        "name": "requirements.txt"
      },
      {
        "name": "setup.py"
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/cd19-mber/cd19-pipeline-linear.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/CHL1/fasta/variant_a.fasta</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/CHL1/fasta/variant_b.fasta</summary>

</details>
</tool-use>

---


Inspecting how mBER resolves the template from a UniProt ID, how loss is computed, and the template/design-state interfaces:


---

<tool-use data-tool-type="unknown" data-tool-name="semantic_search_full">
<details>
<summary>Tool use: **semantic_search_full**</summary>


Parameters:

```json
{
  "query": "Where does mBER resolve UniProt ID to target sequence or structure?",
  "includePattern": "/home/ec2-user/snap/mber-open",
  "topK": 10,
  "explanation": ""
}
```
Result:

```json
{
  "codeResults": [
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/utils/pdb_utils.py",
        "range": {
          "startPosition": {
            "line": 18
          },
          "endPosition": {
            "line": 110
          }
        },
        "contents": "def process_target(target_id: str) -&gt; tuple:\n\n            return f.read(), pae_matrix\n\n    # Check if it's a 4-letter PDB code\n    if len(target_id) == 4 and target_id.isalnum():\n        pdb_url = f\"https://files.rcsb.org/download/{target_id}.pdb\"\n        response = requests.get(pdb_url)\n        if response.status_code == 200:\n            return response.text, None  # PDB files don't have PAE data\n        else:\n            raise ValueError(f\"Failed to download PDB: {target_id}\")\n\n    # Check if it's a UniProt ID\n    if len(target_id) &gt;= 6 and target_id.isalnum():\n        # Download AlphaFold structure\n        af_url = f\"https://alphafold.ebi.ac.uk/files/AF-{target_id}-F1-model_v6.pdb\"\n        response = requests.get(af_url)\n        if response.status_code == 200:\n            pdb_content = response.text\n\n            # Also download the PAE file\n            pae_url = f\"https://alphafold.ebi.ac.uk/files/AF-{target_id}-F1-predicted_aligned_error_v6.json\"\n            pae_response = requests.get(pae_url)\n\n            if pae_response.status_code == 200:\n                pae_matrix = parse_pae_matrix(pae_response.text)\n                return pdb_content, pae_matrix\n            else:\n                return pdb_content, None  # PAE file not available\n        else:\n            raise ValueError(f\"Failed to download AlphaFold structure: {target_id}\")\n\n    raise ValueError(f\"Invalid target ID format: {target_id}\")\n\n\ndef parse_pae_matrix(pae_text: str):\n    \"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 19,
                "column": 1
              },
              "endPosition": {
                "line": 20,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "def process_target(target_id: str) -&gt; tuple:",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "lineNumber": 56
          },
          {
            "text": "            return f.read(), pae_matrix",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "    # Check if it's a 4-letter PDB code",
            "lineNumber": 59
          },
          {
            "text": "    if len(target_id) == 4 and target_id.isalnum():",
            "lineNumber": 60
          },
          {
            "text": "        pdb_url = f\"https://files.rcsb.org/download/{target_id}.pdb\"",
            "lineNumber": 61
          },
          {
            "text": "        response = requests.get(pdb_url)",
            "lineNumber": 62
          },
          {
            "text": "        if response.status_code == 200:",
            "lineNumber": 63
          },
          {
            "text": "            return response.text, None  # PDB files don't have PAE data",
            "lineNumber": 64
          },
          {
            "text": "        else:",
            "lineNumber": 65
          },
          {
            "text": "            raise ValueError(f\"Failed to download PDB: {target_id}\")",
            "lineNumber": 66
          },
          {
            "lineNumber": 67
          },
          {
            "text": "    # Check if it's a UniProt ID",
            "lineNumber": 68
          },
          {
            "text": "    if len(target_id) &gt;= 6 and target_id.isalnum():",
            "lineNumber": 69
          },
          {
            "text": "        # Download AlphaFold structure",
            "lineNumber": 70
          },
          {
            "text": "        af_url = f\"https://alphafold.ebi.ac.uk/files/AF-{target_id}-F1-model_v6.pdb\"",
            "lineNumber": 71
          },
          {
            "text": "        response = requests.get(af_url)",
            "lineNumber": 72
          },
          {
            "text": "        if response.status_code == 200:",
            "lineNumber": 73
          },
          {
            "text": "            pdb_content = response.text",
            "lineNumber": 74
          },
          {
            "lineNumber": 75
          },
          {
            "text": "            # Also download the PAE file",
            "lineNumber": 76
          },
          {
            "text": "            pae_url = f\"https://alphafold.ebi.ac.uk/files/AF-{target_id}-F1-predicted_aligned_error_v6.json\"",
            "lineNumber": 77
          },
          {
            "text": "            pae_response = requests.get(pae_url)",
            "lineNumber": 78
          },
          {
            "lineNumber": 79
          },
          {
            "text": "            if pae_response.status_code == 200:",
            "lineNumber": 80
          },
          {
            "text": "                pae_matrix = parse_pae_matrix(pae_response.text)",
            "lineNumber": 81
          },
          {
            "text": "                return pdb_content, pae_matrix",
            "lineNumber": 82
          },
          {
            "text": "            else:",
            "lineNumber": 83
          },
          {
            "text": "                return pdb_content, None  # PAE file not available",
            "lineNumber": 84
          },
          {
            "text": "        else:",
            "lineNumber": 85
          },
          {
            "text": "            raise ValueError(f\"Failed to download AlphaFold structure: {target_id}\")",
            "lineNumber": 86
          },
          {
            "lineNumber": 87
          },
          {
            "text": "    raise ValueError(f\"Invalid target ID format: {target_id}\")",
            "lineNumber": 88,
            "isSignature": true
          },
          {
            "lineNumber": 89
          },
          {
            "lineNumber": 90
          },
          {
            "text": "def parse_pae_matrix(pae_text: str):",
            "lineNumber": 91,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 92
          }
        ]
      },
      "score": 0.3970992863178253
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/utils/pdb_utils.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 87
          }
        },
        "contents": "from typing import Optional, List, Tuple, Dict, Union\nfrom pathlib import Path\nimport os\nimport re\nimport requests\nimport json\nimport numpy as np\nimport boto3\n\nfrom Bio import PDB\nfrom Bio.PDB.Structure import Structure\nfrom Bio.PDB.Model import Model\nfrom Bio.PDB.Chain import Chain\nfrom Bio.PDB.Residue import Residue\n\nfrom mber.models.folding import ProteinFoldingModel\n\n\ndef process_target(target_id: str) -&gt; tuple:\n    \"\"\"Process target protein from ID or file, returning PDB content and PAE matrix if available.\"\"\"\n    # Check if it's a file path and look for accompanying s3 file\n    if os.path.exists(target_id):\n        base_path = os.path.splitext(target_id)[0]\n        pae_path = f\"{base_path}_pae.json\"\n        if os.path.exists(pae_path):\n            with open(pae_path, \"r\") as f:\n                pae_matrix = parse_pae_matrix(f.read())\n            with open(target_id, \"r\") as f:\n                return f.read(), pae_matrix\n        else:\n            with open(target_id, \"r\") as f:\n                return f.read(), None\n\n    # check if its an s3 file and look for accompanying pae file on s3\n    if target_id.startswith(\"s3://\"):\n        s3_client = boto3.client(\"s3\")\n        bucket_name = target_id.split(\"/\")[2]\n        file_key = \"/\".join(target_id.split(\"/\")[3:])\n        local_file_path = os.path.join(\"/tmp\", os.path.basename(file_key))\n\n        # Download the PDB file from S3\n        s3_client.download_file(bucket_name, file_key, local_file_path)\n\n        # Check for accompanying PAE file\n        pae_key = file_key.replace(\".pdb\", \"_pae.json\")\n        pae_local_path = os.path.join(\"/tmp\", os.path.basename(pae_key))\n\n        try:\n            s3_client.download_file(bucket_name, pae_key, pae_local_path)\n            with open(pae_local_path, \"r\") as f:\n                pae_matrix = parse_pae_matrix(f.read())\n        except Exception as e:\n            print(f\"PAE file not found: {e}\")\n            pae_matrix = None\n\n        with open(local_file_path, \"r\") as f:\n            return f.read(), pae_matrix\n\n    # Check if it's a 4-letter PDB code\n    if",
        "signatures": {},
        "detailedLines": [
          {
            "text": "from typing import Optional, List, Tuple, Dict, Union",
            "lineNumber": 1
          },
          {
            "text": "from pathlib import Path",
            "lineNumber": 2
          },
          {
            "text": "import os",
            "lineNumber": 3
          },
          {
            "text": "import re",
            "lineNumber": 4
          },
          {
            "text": "import requests",
            "lineNumber": 5
          },
          {
            "text": "import json",
            "lineNumber": 6
          },
          {
            "text": "import numpy as np",
            "lineNumber": 7
          },
          {
            "text": "import boto3",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "from Bio import PDB",
            "lineNumber": 10
          },
          {
            "text": "from Bio.PDB.Structure import Structure",
            "lineNumber": 11
          },
          {
            "text": "from Bio.PDB.Model import Model",
            "lineNumber": 12
          },
          {
            "text": "from Bio.PDB.Chain import Chain",
            "lineNumber": 13
          },
          {
            "text": "from Bio.PDB.Residue import Residue",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "from mber.models.folding import ProteinFoldingModel",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "lineNumber": 18
          },
          {
            "text": "def process_target(target_id: str) -&gt; tuple:",
            "lineNumber": 19,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Process target protein from ID or file, returning PDB content and PAE matrix if available.\"\"\"",
            "lineNumber": 20
          },
          {
            "text": "    # Check if it's a file path and look for accompanying s3 file",
            "lineNumber": 21
          },
          {
            "text": "    if os.path.exists(target_id):",
            "lineNumber": 22
          },
          {
            "text": "        base_path = os.path.splitext(target_id)[0]",
            "lineNumber": 23
          },
          {
            "text": "        pae_path = f\"{base_path}_pae.json\"",
            "lineNumber": 24
          },
          {
            "text": "        if os.path.exists(pae_path):",
            "lineNumber": 25
          },
          {
            "text": "            with open(pae_path, \"r\") as f:",
            "lineNumber": 26
          },
          {
            "text": "                pae_matrix = parse_pae_matrix(f.read())",
            "lineNumber": 27
          },
          {
            "text": "            with open(target_id, \"r\") as f:",
            "lineNumber": 28
          },
          {
            "text": "                return f.read(), pae_matrix",
            "lineNumber": 29
          },
          {
            "text": "        else:",
            "lineNumber": 30
          },
          {
            "text": "            with open(target_id, \"r\") as f:",
            "lineNumber": 31
          },
          {
            "text": "                return f.read(), None",
            "lineNumber": 32
          },
          {
            "lineNumber": 33
          },
          {
            "text": "    # check if its an s3 file and look for accompanying pae file on s3",
            "lineNumber": 34
          },
          {
            "text": "    if target_id.startswith(\"s3://\"):",
            "lineNumber": 35
          },
          {
            "text": "        s3_client = boto3.client(\"s3\")",
            "lineNumber": 36
          },
          {
            "text": "        bucket_name = target_id.split(\"/\")[2]",
            "lineNumber": 37
          },
          {
            "text": "        file_key = \"/\".join(target_id.split(\"/\")[3:])",
            "lineNumber": 38
          },
          {
            "text": "        local_file_path = os.path.join(\"/tmp\", os.path.basename(file_key))",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "        # Download the PDB file from S3",
            "lineNumber": 41
          },
          {
            "text": "        s3_client.download_file(bucket_name, file_key, local_file_path)",
            "lineNumber": 42
          },
          {
            "lineNumber": 43
          },
          {
            "text": "        # Check for accompanying PAE file",
            "lineNumber": 44
          },
          {
            "text": "        pae_key = file_key.replace(\".pdb\", \"_pae.json\")",
            "lineNumber": 45
          },
          {
            "text": "        pae_local_path = os.path.join(\"/tmp\", os.path.basename(pae_key))",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "text": "        try:",
            "lineNumber": 48
          },
          {
            "text": "            s3_client.download_file(bucket_name, pae_key, pae_local_path)",
            "lineNumber": 49
          },
          {
            "text": "            with open(pae_local_path, \"r\") as f:",
            "lineNumber": 50
          },
          {
            "text": "                pae_matrix = parse_pae_matrix(f.read())",
            "lineNumber": 51
          },
          {
            "text": "        except Exception as e:",
            "lineNumber": 52
          },
          {
            "text": "            print(f\"PAE file not found: {e}\")",
            "lineNumber": 53
          },
          {
            "text": "            pae_matrix = None",
            "lineNumber": 54
          },
          {
            "lineNumber": 55
          },
          {
            "text": "        with open(local_file_path, \"r\") as f:",
            "lineNumber": 56
          },
          {
            "text": "            return f.read(), pae_matrix",
            "lineNumber": 57
          },
          {
            "lineNumber": 58
          },
          {
            "text": "    # Check if it's a 4-letter PDB code",
            "lineNumber": 59
          },
          {
            "text": "    if",
            "lineNumber": 60
          }
        ]
      },
      "score": 0.37847626209259033
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/truncation.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 663
          }
        },
        "contents": "import json\nimport os\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple, Union\nfrom itertools import groupby\nimport tempfile\nimport re\n\nimport numpy as np\nimport biotite.structure as struc\nimport biotite.structure.io.pdb as pdb\n# can drop fastpdb in like this, but need to add Rust package manager and Rust to environment.\n# import fastpdb as pdb\n\nfrom mber.utils.regions import RegionSpec, HotspotSpec, parse_region\n\nclass ProteinTruncator:\n    \"\"\"\n    A class for creating protein truncations based on multiple hotspots, distances, and PAE values.\n    Using Biotite for structure handling for improved performance.\n    \"\"\"\n    \n    # Cache for structure loading\n    _structure_cache = {}\n    \n    @classmethod\n    def get_structure(cls, pdb_file: str) -&gt; Tuple[struc.AtomArray, Dict[str, np.ndarray]]:\n        \"\"\"\n        Get structure from cache or load it if not present.\n        Optimized to avoid redundant computations.\n        \"\"\"\n        if pdb_file not in cls._structure_cache:\n            # Load PDB file using Biotite\n            pdb_file_obj = pdb.PDBFile.read(pdb_file)\n            atom_array = pdb.get_structure(pdb_file_obj, model=1)\n            \n            # Create a mapping of chain IDs to residue indices more efficiently\n            chains = {}\n            unique_chains = np.unique(atom_array.chain_id)\n            \n            for chain_id in unique_chains:\n                # Create mask for this chain\n                chain_mask = atom_array.chain_id == chain_id\n                \n                # Get unique residues more efficiently\n                # Using numpy's unique function with return_index to preserve order\n                _, res_indices = np.unique(atom_array.res_id[chain_mask], return_index=True)\n                chain_indices = np.where(chain_mask)[0]\n                chain_residues = atom_array.res_id[chain_indices[res_indices]]\n                \n                chains[chain_id] = chain_residues\n            \n            cls._structure_cache[pdb_file] = (atom_array, chains)\n        \n        return cls._structure_cache[pdb_file]\n\n    def __init__(self, \n                 pdb_file: Optional[str] = None, \n                 pdb_content: Optional[str] = None,\n                 region_str: Optional[str] = None,\n                 regions: Optional[List[RegionSpec]] = None,\n                 pae_file: Optional[str] = None,\n                 pae_matrix: Optional[str] = None,\n                 include_surrounding_context: Optional[bool] = False):\n        ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import json",
            "lineNumber": 1
          },
          {
            "text": "import os",
            "lineNumber": 2
          },
          {
            "text": "from pathlib import Path",
            "lineNumber": 3
          },
          {
            "text": "from typing import Dict, List, Optional, Tuple, Union",
            "lineNumber": 4
          },
          {
            "text": "from itertools import groupby",
            "lineNumber": 5
          },
          {
            "text": "import tempfile",
            "lineNumber": 6
          },
          {
            "text": "import re",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "import numpy as np",
            "lineNumber": 9
          },
          {
            "text": "import biotite.structure as struc",
            "lineNumber": 10
          },
          {
            "text": "import biotite.structure.io.pdb as pdb",
            "lineNumber": 11
          },
          {
            "text": "# can drop fastpdb in like this, but need to add Rust package manager and Rust to environment.",
            "lineNumber": 12
          },
          {
            "text": "# import fastpdb as pdb",
            "lineNumber": 13
          },
          {
            "lineNumber": 14
          },
          {
            "text": "from mber.utils.regions import RegionSpec, HotspotSpec, parse_region",
            "lineNumber": 15
          },
          {
            "lineNumber": 16
          },
          {
            "text": "class ProteinTruncator:",
            "lineNumber": 17,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 18
          },
          {
            "text": "    A class for creating protein truncations based on multiple hotspots, distances, and PAE values.",
            "lineNumber": 19
          },
          {
            "text": "    Using Biotite for structure handling for improved performance.",
            "lineNumber": 20
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 21
          },
          {
            "text": "    ",
            "lineNumber": 22
          },
          {
            "text": "    # Cache for structure loading",
            "lineNumber": 23
          },
          {
            "text": "    _structure_cache = {}",
            "lineNumber": 24
          },
          {
            "text": "    ",
            "lineNumber": 25
          },
          {
            "text": "    @classmethod",
            "lineNumber": 26
          },
          {
            "text": "    def get_structure(cls, pdb_file: str) -&gt; Tuple[struc.AtomArray, Dict[str, np.ndarray]]:",
            "lineNumber": 27
          },
          {
            "text": "        \"\"\"",
            "lineNumber": 28
          },
          {
            "text": "        Get structure from cache or load it if not present.",
            "lineNumber": 29
          },
          {
            "text": "        Optimized to avoid redundant computations.",
            "lineNumber": 30
          },
          {
            "text": "        \"\"\"",
            "lineNumber": 31
          },
          {
            "text": "        if pdb_file not in cls._structure_cache:",
            "lineNumber": 32
          },
          {
            "text": "            # Load PDB file using Biotite",
            "lineNumber": 33
          },
          {
            "text": "            pdb_file_obj = pdb.PDBFile.read(pdb_file)",
            "lineNumber": 34
          },
          {
            "text": "            atom_array = pdb.get_structure(pdb_file_obj, model=1)",
            "lineNumber": 35
          },
          {
            "text": "            ",
            "lineNumber": 36
          },
          {
            "text": "            # Create a mapping of chain IDs to residue indices more efficiently",
            "lineNumber": 37
          },
          {
            "text": "            chains = {}",
            "lineNumber": 38
          },
          {
            "text": "            unique_chains = np.unique(atom_array.chain_id)",
            "lineNumber": 39
          },
          {
            "text": "            ",
            "lineNumber": 40
          },
          {
            "text": "            for chain_id in unique_chains:",
            "lineNumber": 41
          },
          {
            "text": "                # Create mask for this chain",
            "lineNumber": 42
          },
          {
            "text": "                chain_mask = atom_array.chain_id == chain_id",
            "lineNumber": 43
          },
          {
            "text": "                ",
            "lineNumber": 44
          },
          {
            "text": "                # Get unique residues more efficiently",
            "lineNumber": 45
          },
          {
            "text": "                # Using numpy's unique function with return_index to preserve order",
            "lineNumber": 46
          },
          {
            "text": "                _, res_indices = np.unique(atom_array.res_id[chain_mask], return_index=True)",
            "lineNumber": 47
          },
          {
            "text": "                chain_indices = np.where(chain_mask)[0]",
            "lineNumber": 48
          },
          {
            "text": "                chain_residues = atom_array.res_id[chain_indices[res_indices]]",
            "lineNumber": 49
          },
          {
            "text": "                ",
            "lineNumber": 50
          },
          {
            "text": "                chains[chain_id] = chain_residues",
            "lineNumber": 51
          },
          {
            "text": "            ",
            "lineNumber": 52
          },
          {
            "text": "            cls._structure_cache[pdb_file] = (atom_array, chains)",
            "lineNumber": 53
          },
          {
            "text": "        ",
            "lineNumber": 54
          },
          {
            "text": "        return cls._structure_cache[pdb_file]",
            "lineNumber": 55
          },
          {
            "lineNumber": 56
          },
          {
            "text": "    def __init__(self, ",
            "lineNumber": 57
          },
          {
            "text": "                 pdb_file: Optional[str] = None, ",
            "lineNumber": 58
          },
          {
            "text": "                 pdb_content: Optional[str] = None,",
            "lineNumber": 59
          },
          {
            "text": "                 region_str: Optional[str] = None,",
            "lineNumber": 60
          },
          {
            "text": "                 regions: Optional[List[RegionSpec]] = None,",
            "lineNumber": 61
          },
          {
            "text": "                 pae_file: Optional[str] = None,",
            "lineNumber": 62
          },
          {
            "text": "                 pae_matrix: Optional[str] = None,",
            "lineNumber": 63
          },
          {
            "text": "                 include_surrounding_context: Optional[bool] = False):",
            "lineNumber": 64
          },
          {
            "text": "        ",
            "lineNumber": 65
          }
        ]
      },
      "score": 0.3324032127857208
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/data/state.py",
        "range": {
          "startPosition": {
            "line": 30,
            "column": 45
          },
          "endPosition": {
            "line": 140
          }
        },
        "contents": "@dataclass(repr=False)\nclass TemplateData(SerializableDataclass):\n    \"\"\"Data class for template information.\"\"\"\n    # Required inputs\n    target_id: str  # UniProt, PDB, input pdb filename, or other unique ID for target protein\n    target_name: str  # Colloquial name for target protein\n\n    # Optional inputs\n    region: Optional[str] = None  # Region of interest (e.g. \"A:101-200\")\n    target_hotspot_residues: Optional[str] = None  # Hotspot residues (e.g. \"A10,A25\")\n    masked_binder_seq: Optional[str] = None  # Sequence with '*' marking positions to fill\n    include_surrounding_context: Optional[bool]= False\n    \n    # Outputs filled by TemplateModule\n    target_source: Optional[str] = None  # Source of target (e.g. \"uniprot\", \"pdb\", \"input\")\n    template_pdb: Optional[str] = None  # Combined PDB file content as string\n    full_target_pdb: Optional[str] = None  # PDB with both truncated (chain A) and untruncated (chain Z) residues\n    target_chain: Optional[str] = None  # Chain ID for target protein\n    binder_chain: Optional[str] = None  # Chain ID for binder protein\n    binder_len: Optional[int] = None  # Length of binder sequence\n    binder_seq: Optional[str] = None  # Full binder sequence\n    binder_bias: Optional[np.ndarray] = None  # Bias matrix for design\n    template_preparation_complete: bool = False  # Flag to indicate preparation is complete\n    logs: List[Dict] = field(default_factory=list)  # Module logs\n    timings: Dict[str, float] = field(default_factory=dict)  # Timing information\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Custom representation for template data.\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "@dataclass(repr=False)",
            "lineNumber": 34
          },
          {
            "text": "class TemplateData(SerializableDataclass):",
            "lineNumber": 35,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Data class for template information.\"\"\"",
            "lineNumber": 36
          },
          {
            "text": "    # Required inputs",
            "lineNumber": 37
          },
          {
            "text": "    target_id: str  # UniProt, PDB, input pdb filename, or other unique ID for target protein",
            "lineNumber": 38
          },
          {
            "text": "    target_name: str  # Colloquial name for target protein",
            "lineNumber": 39
          },
          {
            "lineNumber": 40
          },
          {
            "text": "    # Optional inputs",
            "lineNumber": 41
          },
          {
            "text": "    region: Optional[str] = None  # Region of interest (e.g. \"A:101-200\")",
            "lineNumber": 42
          },
          {
            "text": "    target_hotspot_residues: Optional[str] = None  # Hotspot residues (e.g. \"A10,A25\")",
            "lineNumber": 43
          },
          {
            "text": "    masked_binder_seq: Optional[str] = None  # Sequence with '*' marking positions to fill",
            "lineNumber": 44
          },
          {
            "text": "    include_surrounding_context: Optional[bool]= False",
            "lineNumber": 45
          },
          {
            "text": "    ",
            "lineNumber": 46
          },
          {
            "text": "    # Outputs filled by TemplateModule",
            "lineNumber": 47
          },
          {
            "text": "    target_source: Optional[str] = None  # Source of target (e.g. \"uniprot\", \"pdb\", \"input\")",
            "lineNumber": 48
          },
          {
            "text": "    template_pdb: Optional[str] = None  # Combined PDB file content as string",
            "lineNumber": 49
          },
          {
            "text": "    full_target_pdb: Optional[str] = None  # PDB with both truncated (chain A) and untruncated (chain Z) residues",
            "lineNumber": 50
          },
          {
            "text": "    target_chain: Optional[str] = None  # Chain ID for target protein",
            "lineNumber": 51
          },
          {
            "text": "    binder_chain: Optional[str] = None  # Chain ID for binder protein",
            "lineNumber": 52
          },
          {
            "text": "    binder_len: Optional[int] = None  # Length of binder sequence",
            "lineNumber": 53
          },
          {
            "text": "    binder_seq: Optional[str] = None  # Full binder sequence",
            "lineNumber": 54
          },
          {
            "text": "    binder_bias: Optional[np.ndarray] = None  # Bias matrix for design",
            "lineNumber": 55
          },
          {
            "text": "    template_preparation_complete: bool = False  # Flag to indicate preparation is complete",
            "lineNumber": 56
          },
          {
            "text": "    logs: List[Dict] = field(default_factory=list)  # Module logs",
            "lineNumber": 57
          },
          {
            "text": "    timings: Dict[str, float] = field(default_factory=dict)  # Timing information",
            "lineNumber": 58
          },
          {
            "lineNumber": 59
          },
          {
            "text": "    def __repr__(self) -&gt; str:",
            "lineNumber": 60
          },
          {
            "text": "        \"\"\"Custom representation for template data.\"\"\"",
            "lineNumber": 61
          }
        ]
      },
      "score": 0.3135373592376709
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/msa_identifiers.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 71
          }
        },
        "contents": "# Copyright 2021 DeepMind Technologies Limited\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilities for extracting identifiers from MSA sequence descriptions.\"\"\"\n\nimport dataclasses\nimport re\nfrom typing import Optional\n\n\n# Sequences coming from UniProtKB database come in the\n# &#96;db|UniqueIdentifier|EntryName&#96; format, e.g. &#96;tr|A0A146SKV9|A0A146SKV9_FUNHE&#96;\n# or &#96;sp|P0C2L1|A3X1_LOXLA&#96; (for TREMBL/Swiss-Prot respectively).\n_UNIPROT_PATTERN = re.compile(\n    r\"\"\"\n    ^\n    # UniProtKB/TrEMBL or UniProtKB/Swiss-Prot\n    (?:tr|sp)\n    \\|\n    # A primary accession number of the UniProtKB entry.\n    (?P&lt;AccessionIdentifier&gt;[A-Za-z0-9]{6,10})\n    # Occasionally there is a _0 or _1 isoform suffix, which we ignore.\n    (?:_\\d)?\n    \\|\n    # TREMBL repeats the accession ID here. Swiss-Prot has a mnemonic\n    # protein ID code.\n    (?:[A-Za-z0-9]+)\n    _\n    # A mnemonic species identification code.\n    (?P&lt;SpeciesIdentifier&gt;([A-Za-z0-9]){1,5})\n    # Small BFD uses a final value after an underscore, which we ignore.\n    (?:_\\d+)?\n    $\n    \"\"\",\n    re.VERBOSE)\n\n\n@dataclasses.dataclass(frozen=True)\nclass Identifiers:\n  species_id: str = ''\n\n\ndef _parse_sequence_identifier(msa_sequence_identifier: str) -&gt; Identifiers:\n  \"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# Copyright 2021 DeepMind Technologies Limited",
            "lineNumber": 1
          },
          {
            "text": "#",
            "lineNumber": 2
          },
          {
            "text": "# Licensed under the Apache License, Version 2.0 (the \"License\");",
            "lineNumber": 3
          },
          {
            "text": "# you may not use this file except in compliance with the License.",
            "lineNumber": 4
          },
          {
            "text": "# You may obtain a copy of the License at",
            "lineNumber": 5
          },
          {
            "text": "#",
            "lineNumber": 6
          },
          {
            "text": "#      http://www.apache.org/licenses/LICENSE-2.0",
            "lineNumber": 7
          },
          {
            "text": "#",
            "lineNumber": 8
          },
          {
            "text": "# Unless required by applicable law or agreed to in writing, software",
            "lineNumber": 9
          },
          {
            "text": "# distributed under the License is distributed on an \"AS IS\" BASIS,",
            "lineNumber": 10
          },
          {
            "text": "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.",
            "lineNumber": 11
          },
          {
            "text": "# See the License for the specific language governing permissions and",
            "lineNumber": 12
          },
          {
            "text": "# limitations under the License.",
            "lineNumber": 13
          },
          {
            "lineNumber": 14
          },
          {
            "text": "\"\"\"Utilities for extracting identifiers from MSA sequence descriptions.\"\"\"",
            "lineNumber": 15
          },
          {
            "lineNumber": 16
          },
          {
            "text": "import dataclasses",
            "lineNumber": 17
          },
          {
            "text": "import re",
            "lineNumber": 18
          },
          {
            "text": "from typing import Optional",
            "lineNumber": 19
          },
          {
            "lineNumber": 20
          },
          {
            "lineNumber": 21
          },
          {
            "text": "# Sequences coming from UniProtKB database come in the",
            "lineNumber": 22
          },
          {
            "text": "# &#96;db|UniqueIdentifier|EntryName&#96; format, e.g. &#96;tr|A0A146SKV9|A0A146SKV9_FUNHE&#96;",
            "lineNumber": 23
          },
          {
            "text": "# or &#96;sp|P0C2L1|A3X1_LOXLA&#96; (for TREMBL/Swiss-Prot respectively).",
            "lineNumber": 24
          },
          {
            "text": "_UNIPROT_PATTERN = re.compile(",
            "lineNumber": 25
          },
          {
            "text": "    r\"\"\"",
            "lineNumber": 26
          },
          {
            "text": "    ^",
            "lineNumber": 27
          },
          {
            "text": "    # UniProtKB/TrEMBL or UniProtKB/Swiss-Prot",
            "lineNumber": 28
          },
          {
            "text": "    (?:tr|sp)",
            "lineNumber": 29
          },
          {
            "text": "    \\|",
            "lineNumber": 30
          },
          {
            "text": "    # A primary accession number of the UniProtKB entry.",
            "lineNumber": 31
          },
          {
            "text": "    (?P&lt;AccessionIdentifier&gt;[A-Za-z0-9]{6,10})",
            "lineNumber": 32
          },
          {
            "text": "    # Occasionally there is a _0 or _1 isoform suffix, which we ignore.",
            "lineNumber": 33
          },
          {
            "text": "    (?:_\\d)?",
            "lineNumber": 34
          },
          {
            "text": "    \\|",
            "lineNumber": 35
          },
          {
            "text": "    # TREMBL repeats the accession ID here. Swiss-Prot has a mnemonic",
            "lineNumber": 36
          },
          {
            "text": "    # protein ID code.",
            "lineNumber": 37
          },
          {
            "text": "    (?:[A-Za-z0-9]+)",
            "lineNumber": 38
          },
          {
            "text": "    _",
            "lineNumber": 39
          },
          {
            "text": "    # A mnemonic species identification code.",
            "lineNumber": 40
          },
          {
            "text": "    (?P&lt;SpeciesIdentifier&gt;([A-Za-z0-9]){1,5})",
            "lineNumber": 41
          },
          {
            "text": "    # Small BFD uses a final value after an underscore, which we ignore.",
            "lineNumber": 42
          },
          {
            "text": "    (?:_\\d+)?",
            "lineNumber": 43
          },
          {
            "text": "    $",
            "lineNumber": 44
          },
          {
            "text": "    \"\"\",",
            "lineNumber": 45
          },
          {
            "text": "    re.VERBOSE)",
            "lineNumber": 46
          },
          {
            "lineNumber": 47
          },
          {
            "lineNumber": 48
          },
          {
            "text": "@dataclasses.dataclass(frozen=True)",
            "lineNumber": 49
          },
          {
            "text": "class Identifiers:",
            "lineNumber": 50,
            "isSignature": true
          },
          {
            "text": "  species_id: str = ''",
            "lineNumber": 51,
            "isSignature": true
          },
          {
            "lineNumber": 52
          },
          {
            "lineNumber": 53
          },
          {
            "text": "def _parse_sequence_identifier(msa_sequence_identifier: str) -&gt; Identifiers:",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "  \"\"\"",
            "lineNumber": 55
          }
        ]
      },
      "score": 0.3128117322921753
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/sasa.py",
        "range": {
          "startPosition": {
            "line": 335,
            "column": 67
          },
          "endPosition": {
            "line": 417
          }
        },
        "contents": "def _last_resort_fallback(pdb_path: str) -&gt; str:\n    \"\"\"Absolute last resort fallback to find any residue.\"\"\"\n    pdb_file_obj = pdb.PDBFile.read(pdb_path)\n    atom_array = pdb.get_structure(pdb_file_obj)\n    \n    # Get a list of all chain_id, res_id combinations\n    chains = np.unique(atom_array.chain_id)\n    \n    if len(chains) == 0:\n        raise ValueError(\"No chains found in PDB file\")\n    \n    # Pick the first chain\n    chain_id = chains[0]\n    chain_mask = (atom_array.chain_id == chain_id)\n    chain_atoms = atom_array[chain_mask]\n    \n    # Get residue IDs\n    res_ids = np.unique(chain_atoms.res_id)\n    \n    if len(res_ids) == 0:\n        raise ValueError(\"No residues found in chain\")\n    \n    # Pick the middle residue\n    middle_idx = len(res_ids) // 2\n    res_id = res_ids[middle_idx]\n    \n    return f\"{chain_id}{res_id}\"\n\n\ndef find_hotspots(pdb_content: str, region_str: Optional[str] = None, \n                sasa_threshold: float = 50.0, hotspot_strategy: Callable = None) -&gt; str:\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _last_resort_fallback(pdb_path: str) -&gt; str:",
            "lineNumber": 339,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Absolute last resort fallback to find any residue.\"\"\"",
            "lineNumber": 340
          },
          {
            "text": "    pdb_file_obj = pdb.PDBFile.read(pdb_path)",
            "lineNumber": 341
          },
          {
            "text": "    atom_array = pdb.get_structure(pdb_file_obj)",
            "lineNumber": 342
          },
          {
            "text": "    ",
            "lineNumber": 343
          },
          {
            "text": "    # Get a list of all chain_id, res_id combinations",
            "lineNumber": 344
          },
          {
            "text": "    chains = np.unique(atom_array.chain_id)",
            "lineNumber": 345
          },
          {
            "text": "    ",
            "lineNumber": 346
          },
          {
            "text": "    if len(chains) == 0:",
            "lineNumber": 347
          },
          {
            "text": "        raise ValueError(\"No chains found in PDB file\")",
            "lineNumber": 348
          },
          {
            "text": "    ",
            "lineNumber": 349
          },
          {
            "text": "    # Pick the first chain",
            "lineNumber": 350
          },
          {
            "text": "    chain_id = chains[0]",
            "lineNumber": 351
          },
          {
            "text": "    chain_mask = (atom_array.chain_id == chain_id)",
            "lineNumber": 352
          },
          {
            "text": "    chain_atoms = atom_array[chain_mask]",
            "lineNumber": 353
          },
          {
            "text": "    ",
            "lineNumber": 354
          },
          {
            "text": "    # Get residue IDs",
            "lineNumber": 355
          },
          {
            "text": "    res_ids = np.unique(chain_atoms.res_id)",
            "lineNumber": 356
          },
          {
            "text": "    ",
            "lineNumber": 357
          },
          {
            "text": "    if len(res_ids) == 0:",
            "lineNumber": 358
          },
          {
            "text": "        raise ValueError(\"No residues found in chain\")",
            "lineNumber": 359
          },
          {
            "text": "    ",
            "lineNumber": 360
          },
          {
            "text": "    # Pick the middle residue",
            "lineNumber": 361
          },
          {
            "text": "    middle_idx = len(res_ids) // 2",
            "lineNumber": 362
          },
          {
            "text": "    res_id = res_ids[middle_idx]",
            "lineNumber": 363
          },
          {
            "text": "    ",
            "lineNumber": 364
          },
          {
            "text": "    return f\"{chain_id}{res_id}\"",
            "lineNumber": 365,
            "isSignature": true
          },
          {
            "lineNumber": 366
          },
          {
            "lineNumber": 367
          },
          {
            "text": "def find_hotspots(pdb_content: str, region_str: Optional[str] = None, ",
            "lineNumber": 368,
            "isSignature": true
          },
          {
            "text": "                sasa_threshold: float = 50.0, hotspot_strategy: Callable = None) -&gt; str:",
            "lineNumber": 369,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 370
          }
        ]
      },
      "score": 0.30399489402770996
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/modules/template.py",
        "range": {
          "startPosition": {
            "line": 22
          },
          "endPosition": {
            "line": 230
          }
        },
        "contents": "class BaseTemplateModule(BaseModule):\n@time_method()\ndef _create_truncation(self, design_state: DesignState) -&gt; DesignState:\n\n        \n        return design_state\n    \n    @time_method()\n    def _process_masked_sequence(self, design_state: DesignState) -&gt; DesignState:\n        \"\"\"Process masked sequence to generate binder sequence and structure.\"\"\"\n        self._log(\"Processing masked binder sequence\")\n        \n        # Get path to temporary directory\n        temp_dir_path = Path(self.temp_dir.name)\n        \n        # Generate complete sequence from masked sequence\n        binder_seq = generate_sequence_from_mask(\n            self.esm_model,\n            design_state.template_data.masked_binder_seq,\n            temperature=self.template_config.sampling_temperature,\n            num_samples=1\n        )\n        design_state.template_data.binder_seq = binder_seq\n        design_state.template_data.binder_len = len(binder_seq)\n        \n        # Generate bias from masked sequence\n        self._log(\"Generating position-specific bias\")\n        binder_bias = generate_bias_from_mask(\n            self.esm_model,\n            design_state.template_data,\n            self.template_config.omit_amino_acids,\n            temperature=self.template_config.bias_temperature\n        )\n        design_state.template_data.binder_bias = binder_bias\n        \n        # Fold binder structure\n        self._log(\"Folding binder structure\")\n        binder_pdb = fold_binder(\n            self.folding_model,\n            binder_seq, \n            output_dir=temp_dir_path\n        )\n        \n        # Combine structures\n        self._log(\"Combining target and binder structures\")\n        combined_pdb = combine_structures(\n            design_state.template_data.full_target_pdb, \n            binder_pdb, \n            design_state.template_data.target_chain,\n            output_dir=temp_dir_path\n        )\n        \n        # Update template PDB with combined structure\n        design_state.template_data.template_pdb = combined_pdb\n        design_state.template_data.binder_chain = self.template_config.binder_chain\n        \n        return design_state\n    \n    def _cleanup_temp_directory(self) -&gt; None:\n        \"\"\"Clean up temporary directory.\"\"\"",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 23,
                "column": 1
              },
              "endPosition": {
                "line": 24,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class BaseTemplateModule(BaseModule):",
            "lineNumber": 23,
            "isSignature": true
          },
          {
            "text": "@time_method()",
            "lineNumber": 135
          },
          {
            "text": "def _create_truncation(self, design_state: DesignState) -&gt; DesignState:",
            "lineNumber": 136
          },
          {
            "lineNumber": 162
          },
          {
            "text": "        ",
            "lineNumber": 163
          },
          {
            "text": "        return design_state",
            "lineNumber": 164
          },
          {
            "text": "    ",
            "lineNumber": 165
          },
          {
            "text": "    @time_method()",
            "lineNumber": 166
          },
          {
            "text": "    def _process_masked_sequence(self, design_state: DesignState) -&gt; DesignState:",
            "lineNumber": 167
          },
          {
            "text": "        \"\"\"Process masked sequence to generate binder sequence and structure.\"\"\"",
            "lineNumber": 168
          },
          {
            "text": "        self._log(\"Processing masked binder sequence\")",
            "lineNumber": 169
          },
          {
            "text": "        ",
            "lineNumber": 170
          },
          {
            "text": "        # Get path to temporary directory",
            "lineNumber": 171
          },
          {
            "text": "        temp_dir_path = Path(self.temp_dir.name)",
            "lineNumber": 172
          },
          {
            "text": "        ",
            "lineNumber": 173
          },
          {
            "text": "        # Generate complete sequence from masked sequence",
            "lineNumber": 174
          },
          {
            "text": "        binder_seq = generate_sequence_from_mask(",
            "lineNumber": 175
          },
          {
            "text": "            self.esm_model,",
            "lineNumber": 176
          },
          {
            "text": "            design_state.template_data.masked_binder_seq,",
            "lineNumber": 177
          },
          {
            "text": "            temperature=self.template_config.sampling_temperature,",
            "lineNumber": 178
          },
          {
            "text": "            num_samples=1",
            "lineNumber": 179
          },
          {
            "text": "        )",
            "lineNumber": 180
          },
          {
            "text": "        design_state.template_data.binder_seq = binder_seq",
            "lineNumber": 181
          },
          {
            "text": "        design_state.template_data.binder_len = len(binder_seq)",
            "lineNumber": 182
          },
          {
            "text": "        ",
            "lineNumber": 183
          },
          {
            "text": "        # Generate bias from masked sequence",
            "lineNumber": 184
          },
          {
            "text": "        self._log(\"Generating position-specific bias\")",
            "lineNumber": 185
          },
          {
            "text": "        binder_bias = generate_bias_from_mask(",
            "lineNumber": 186
          },
          {
            "text": "            self.esm_model,",
            "lineNumber": 187
          },
          {
            "text": "            design_state.template_data,",
            "lineNumber": 188
          },
          {
            "text": "            self.template_config.omit_amino_acids,",
            "lineNumber": 189
          },
          {
            "text": "            temperature=self.template_config.bias_temperature",
            "lineNumber": 190
          },
          {
            "text": "        )",
            "lineNumber": 191
          },
          {
            "text": "        design_state.template_data.binder_bias = binder_bias",
            "lineNumber": 192
          },
          {
            "text": "        ",
            "lineNumber": 193
          },
          {
            "text": "        # Fold binder structure",
            "lineNumber": 194
          },
          {
            "text": "        self._log(\"Folding binder structure\")",
            "lineNumber": 195
          },
          {
            "text": "        binder_pdb = fold_binder(",
            "lineNumber": 196
          },
          {
            "text": "            self.folding_model,",
            "lineNumber": 197
          },
          {
            "text": "            binder_seq, ",
            "lineNumber": 198
          },
          {
            "text": "            output_dir=temp_dir_path",
            "lineNumber": 199
          },
          {
            "text": "        )",
            "lineNumber": 200
          },
          {
            "text": "        ",
            "lineNumber": 201
          },
          {
            "text": "        # Combine structures",
            "lineNumber": 202
          },
          {
            "text": "        self._log(\"Combining target and binder structures\")",
            "lineNumber": 203
          },
          {
            "text": "        combined_pdb = combine_structures(",
            "lineNumber": 204
          },
          {
            "text": "            design_state.template_data.full_target_pdb, ",
            "lineNumber": 205
          },
          {
            "text": "            binder_pdb, ",
            "lineNumber": 206
          },
          {
            "text": "            design_state.template_data.target_chain,",
            "lineNumber": 207
          },
          {
            "text": "            output_dir=temp_dir_path",
            "lineNumber": 208
          },
          {
            "text": "        )",
            "lineNumber": 209
          },
          {
            "text": "        ",
            "lineNumber": 210
          },
          {
            "text": "        # Update template PDB with combined structure",
            "lineNumber": 211
          },
          {
            "text": "        design_state.template_data.template_pdb = combined_pdb",
            "lineNumber": 212
          },
          {
            "text": "        design_state.template_data.binder_chain = self.template_config.binder_chain",
            "lineNumber": 213
          },
          {
            "text": "        ",
            "lineNumber": 214
          },
          {
            "text": "        return design_state",
            "lineNumber": 215
          },
          {
            "text": "    ",
            "lineNumber": 216
          },
          {
            "text": "    def _cleanup_temp_directory(self) -&gt; None:",
            "lineNumber": 217
          },
          {
            "text": "        \"\"\"Clean up temporary directory.\"\"\"",
            "lineNumber": 218
          }
        ]
      },
      "score": 0.30047106742858887
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/msa_identifiers.py",
        "range": {
          "startPosition": {
            "line": 50,
            "column": 22
          },
          "endPosition": {
            "line": 80
          }
        },
        "contents": "def _parse_sequence_identifier(msa_sequence_identifier: str) -&gt; Identifiers:\n  \"\"\"Gets species from an msa sequence identifier.\n\n  The sequence identifier has the format specified by\n  _UNIPROT_TREMBL_ENTRY_NAME_PATTERN or _UNIPROT_SWISSPROT_ENTRY_NAME_PATTERN.\n  An example of a sequence identifier: &#96;tr|A0A146SKV9|A0A146SKV9_FUNHE&#96;\n\n  Args:\n    msa_sequence_identifier: a sequence identifier.\n\n  Returns:\n    An &#96;Identifiers&#96; instance with species_id. These\n    can be empty in the case where no identifier was found.\n  \"\"\"\n  matches = re.search(_UNIPROT_PATTERN, msa_sequence_identifier.strip())\n  if matches:\n    return Identifiers(\n        species_id=matches.group('SpeciesIdentifier'))\n  return Identifiers()\n\n\ndef _extract_sequence_identifier(description: str) -&gt; Optional[str]:\n  \"\"\"Extracts sequence identifier from description. Returns None if no match.\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _parse_sequence_identifier(msa_sequence_identifier: str) -&gt; Identifiers:",
            "lineNumber": 54,
            "isSignature": true
          },
          {
            "text": "  \"\"\"Gets species from an msa sequence identifier.",
            "lineNumber": 55
          },
          {
            "lineNumber": 56
          },
          {
            "text": "  The sequence identifier has the format specified by",
            "lineNumber": 57
          },
          {
            "text": "  _UNIPROT_TREMBL_ENTRY_NAME_PATTERN or _UNIPROT_SWISSPROT_ENTRY_NAME_PATTERN.",
            "lineNumber": 58
          },
          {
            "text": "  An example of a sequence identifier: &#96;tr|A0A146SKV9|A0A146SKV9_FUNHE&#96;",
            "lineNumber": 59
          },
          {
            "lineNumber": 60
          },
          {
            "text": "  Args:",
            "lineNumber": 61
          },
          {
            "text": "    msa_sequence_identifier: a sequence identifier.",
            "lineNumber": 62
          },
          {
            "lineNumber": 63
          },
          {
            "text": "  Returns:",
            "lineNumber": 64
          },
          {
            "text": "    An &#96;Identifiers&#96; instance with species_id. These",
            "lineNumber": 65
          },
          {
            "text": "    can be empty in the case where no identifier was found.",
            "lineNumber": 66
          },
          {
            "text": "  \"\"\"",
            "lineNumber": 67
          },
          {
            "text": "  matches = re.search(_UNIPROT_PATTERN, msa_sequence_identifier.strip())",
            "lineNumber": 68
          },
          {
            "text": "  if matches:",
            "lineNumber": 69
          },
          {
            "text": "    return Identifiers(",
            "lineNumber": 70
          },
          {
            "text": "        species_id=matches.group('SpeciesIdentifier'))",
            "lineNumber": 71
          },
          {
            "text": "  return Identifiers()",
            "lineNumber": 72,
            "isSignature": true
          },
          {
            "lineNumber": 73
          },
          {
            "lineNumber": 74
          },
          {
            "text": "def _extract_sequence_identifier(description: str) -&gt; Optional[str]:",
            "lineNumber": 75,
            "isSignature": true
          },
          {
            "text": "  \"\"\"Extracts sequence identifier from description. Returns None if no match.\"\"\"",
            "lineNumber": 76
          }
        ]
      },
      "score": 0.2889293432235718
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/sasa.py",
        "range": {
          "startPosition": {
            "line": 279,
            "column": 18
          },
          "endPosition": {
            "line": 364
          }
        },
        "contents": "def _fallback_hotspot(pdb_path: str, regions: List[RegionSpec]) -&gt; str:\n    \"\"\"\n    Find a fallback hotspot when SASA analysis finds none.\n    Vectorized implementation for better performance.\n    \"\"\"\n    # Load structure using Biotite\n    pdb_file_obj = pdb.PDBFile.read(pdb_path)\n    atom_array = pdb.get_structure(pdb_file_obj)\n    \n    # Get unique chain IDs\n    unique_chains = np.unique(atom_array.chain_id)\n    \n    # Create a set of chain IDs from regions for faster lookups\n    region_chains = set()\n    if regions:\n        region_chains = {r.chain for r in regions}\n    \n    valid_residues = []\n    \n    # Process each chain\n    for chain_id in unique_chains:\n        # Skip chains not in regions if regions are specified\n        if regions and chain_id not in region_chains:\n            continue\n            \n        # Get atoms in this chain\n        chain_mask = (atom_array.chain_id == chain_id)\n        chain_atoms = atom_array[chain_mask]\n        \n        # Get unique residue IDs\n        res_ids = np.unique(chain_atoms.res_id)\n        \n        # If no regions specified, add all residues\n        if not regions:\n            for res_id in res_ids:\n                valid_residues.append((chain_id, res_id))\n            continue\n        \n        # Filter residues based on region ranges\n        for res_id in res_ids:\n            for region in [r for r in regions if r.chain == chain_id]:\n                start = region.start if region.start is not None else -np.inf\n                end = region.end if region.end is not None else np.inf\n                \n                if start &lt;= res_id &lt;= end:\n                    valid_residues.append((chain_id, res_id))\n                    break  # No need to check other regions\n    \n    if valid_residues:\n        # Randomly select one residue\n        chain_id, res_id = random.choice(valid_residues)\n        return f\"{chain_id}{res_id}\"\n                        \n    raise ValueError(\"Could not find any suitable hotspot residue\")\n\n\ndef _last_resort_fallback(pdb_path: str) -&gt; str:\n    \"\"\"Absolute last resort fallback to find any residue.\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _fallback_hotspot(pdb_path: str, regions: List[RegionSpec]) -&gt; str:",
            "lineNumber": 283,
            "isSignature": true
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 284
          },
          {
            "text": "    Find a fallback hotspot when SASA analysis finds none.",
            "lineNumber": 285
          },
          {
            "text": "    Vectorized implementation for better performance.",
            "lineNumber": 286
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 287
          },
          {
            "text": "    # Load structure using Biotite",
            "lineNumber": 288
          },
          {
            "text": "    pdb_file_obj = pdb.PDBFile.read(pdb_path)",
            "lineNumber": 289
          },
          {
            "text": "    atom_array = pdb.get_structure(pdb_file_obj)",
            "lineNumber": 290
          },
          {
            "text": "    ",
            "lineNumber": 291
          },
          {
            "text": "    # Get unique chain IDs",
            "lineNumber": 292
          },
          {
            "text": "    unique_chains = np.unique(atom_array.chain_id)",
            "lineNumber": 293
          },
          {
            "text": "    ",
            "lineNumber": 294
          },
          {
            "text": "    # Create a set of chain IDs from regions for faster lookups",
            "lineNumber": 295
          },
          {
            "text": "    region_chains = set()",
            "lineNumber": 296
          },
          {
            "text": "    if regions:",
            "lineNumber": 297
          },
          {
            "text": "        region_chains = {r.chain for r in regions}",
            "lineNumber": 298
          },
          {
            "text": "    ",
            "lineNumber": 299
          },
          {
            "text": "    valid_residues = []",
            "lineNumber": 300
          },
          {
            "text": "    ",
            "lineNumber": 301
          },
          {
            "text": "    # Process each chain",
            "lineNumber": 302
          },
          {
            "text": "    for chain_id in unique_chains:",
            "lineNumber": 303
          },
          {
            "text": "        # Skip chains not in regions if regions are specified",
            "lineNumber": 304
          },
          {
            "text": "        if regions and chain_id not in region_chains:",
            "lineNumber": 305
          },
          {
            "text": "            continue",
            "lineNumber": 306
          },
          {
            "text": "            ",
            "lineNumber": 307
          },
          {
            "text": "        # Get atoms in this chain",
            "lineNumber": 308
          },
          {
            "text": "        chain_mask = (atom_array.chain_id == chain_id)",
            "lineNumber": 309
          },
          {
            "text": "        chain_atoms = atom_array[chain_mask]",
            "lineNumber": 310
          },
          {
            "text": "        ",
            "lineNumber": 311
          },
          {
            "text": "        # Get unique residue IDs",
            "lineNumber": 312
          },
          {
            "text": "        res_ids = np.unique(chain_atoms.res_id)",
            "lineNumber": 313
          },
          {
            "text": "        ",
            "lineNumber": 314
          },
          {
            "text": "        # If no regions specified, add all residues",
            "lineNumber": 315
          },
          {
            "text": "        if not regions:",
            "lineNumber": 316
          },
          {
            "text": "            for res_id in res_ids:",
            "lineNumber": 317
          },
          {
            "text": "                valid_residues.append((chain_id, res_id))",
            "lineNumber": 318
          },
          {
            "text": "            continue",
            "lineNumber": 319
          },
          {
            "text": "        ",
            "lineNumber": 320
          },
          {
            "text": "        # Filter residues based on region ranges",
            "lineNumber": 321
          },
          {
            "text": "        for res_id in res_ids:",
            "lineNumber": 322
          },
          {
            "text": "            for region in [r for r in regions if r.chain == chain_id]:",
            "lineNumber": 323
          },
          {
            "text": "                start = region.start if region.start is not None else -np.inf",
            "lineNumber": 324
          },
          {
            "text": "                end = region.end if region.end is not None else np.inf",
            "lineNumber": 325
          },
          {
            "text": "                ",
            "lineNumber": 326
          },
          {
            "text": "                if start &lt;= res_id &lt;= end:",
            "lineNumber": 327
          },
          {
            "text": "                    valid_residues.append((chain_id, res_id))",
            "lineNumber": 328
          },
          {
            "text": "                    break  # No need to check other regions",
            "lineNumber": 329
          },
          {
            "text": "    ",
            "lineNumber": 330
          },
          {
            "text": "    if valid_residues:",
            "lineNumber": 331
          },
          {
            "text": "        # Randomly select one residue",
            "lineNumber": 332
          },
          {
            "text": "        chain_id, res_id = random.choice(valid_residues)",
            "lineNumber": 333
          },
          {
            "text": "        return f\"{chain_id}{res_id}\"",
            "lineNumber": 334
          },
          {
            "text": "                        ",
            "lineNumber": 335
          },
          {
            "text": "    raise ValueError(\"Could not find any suitable hotspot residue\")",
            "lineNumber": 336,
            "isSignature": true
          },
          {
            "lineNumber": 337
          },
          {
            "lineNumber": 338
          },
          {
            "text": "def _last_resort_fallback(pdb_path: str) -&gt; str:",
            "lineNumber": 339,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Absolute last resort fallback to find any residue.\"\"\"",
            "lineNumber": 340
          }
        ]
      },
      "score": 0.283688485622406
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/mmcif_parsing.py",
        "range": {
          "startPosition": {
            "line": 165,
            "column": 53
          },
          "endPosition": {
            "line": 289
          }
        },
        "contents": "@functools.lru_cache(16, typed=False)\ndef parse(\n    *, file_id: str, mmcif_string: str, catch_all_errors: bool = True\n) -&gt; ParsingResult:\n    \"\"\"Entry point, parses an mmcif_string.\n\n    Args:\n      file_id: A string identifier for this file. Should be unique within the\n        collection of files being processed.\n      mmcif_string: Contents of an mmCIF file.\n      catch_all_errors: If True, all exceptions are caught and error messages are\n        returned as part of the ParsingResult. If False exceptions will be allowed\n        to propagate.\n\n    Returns:\n      A ParsingResult.\n    \"\"\"\n    errors = {}\n    try:\n        parser = PDB.MMCIFParser(QUIET=True)\n        handle = io.StringIO(mmcif_string)\n        full_structure = parser.get_structure(\"\", handle)\n        first_model_structure = _get_first_model(full_structure)\n        # Extract the _mmcif_dict from the parser, which contains useful fields not\n        # reflected in the Biopython structure.\n        parsed_info = parser._mmcif_dict  # pylint:disable=protected-access\n\n        # Ensure all values are lists, even if singletons.\n        for key, value in parsed_info.items():\n            if not isinstance(value, list):\n                parsed_info[key] = [value]\n\n        header = _get_header(parsed_info)\n\n        # Determine the protein chains, and their start numbers according to the\n        # internal mmCIF numbering scheme (likely but not guaranteed to be 1).\n        valid_chains = _get_protein_chains(parsed_info=parsed_info)\n        if not valid_chains:\n            return ParsingResult(\n                None, {(file_id, \"\"): \"No protein chains found in this file.\"}\n            )\n        seq_start_num = {\n            chain_id: min([monomer.num for monomer in seq])\n            for chain_id, seq in valid_chains.items()\n        }\n\n        # Loop over the atoms for which we have coordinates. Populate two mappings:\n        # -mmcif_to_author_chain_id (maps internal mmCIF chain ids to chain ids used\n        # the authors / Biopython).\n        # -seq_to_structure_mappings (maps idx into sequence to ResidueAtPosition).\n        mmcif_to_author_chain_id = {}\n        seq_to_structure_mappings = {}\n        for atom in _get_atom_site_list(parsed_info):",
        "signatures": {},
        "detailedLines": [
          {
            "text": "@functools.lru_cache(16, typed=False)",
            "lineNumber": 169
          },
          {
            "text": "def parse(",
            "lineNumber": 170,
            "isSignature": true
          },
          {
            "text": "    *, file_id: str, mmcif_string: str, catch_all_errors: bool = True",
            "lineNumber": 171,
            "isSignature": true
          },
          {
            "text": ") -&gt; ParsingResult:",
            "lineNumber": 172,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Entry point, parses an mmcif_string.",
            "lineNumber": 173
          },
          {
            "lineNumber": 174
          },
          {
            "text": "    Args:",
            "lineNumber": 175
          },
          {
            "text": "      file_id: A string identifier for this file. Should be unique within the",
            "lineNumber": 176
          },
          {
            "text": "        collection of files being processed.",
            "lineNumber": 177
          },
          {
            "text": "      mmcif_string: Contents of an mmCIF file.",
            "lineNumber": 178
          },
          {
            "text": "      catch_all_errors: If True, all exceptions are caught and error messages are",
            "lineNumber": 179
          },
          {
            "text": "        returned as part of the ParsingResult. If False exceptions will be allowed",
            "lineNumber": 180
          },
          {
            "text": "        to propagate.",
            "lineNumber": 181
          },
          {
            "lineNumber": 182
          },
          {
            "text": "    Returns:",
            "lineNumber": 183
          },
          {
            "text": "      A ParsingResult.",
            "lineNumber": 184
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 185
          },
          {
            "text": "    errors = {}",
            "lineNumber": 186
          },
          {
            "text": "    try:",
            "lineNumber": 187
          },
          {
            "text": "        parser = PDB.MMCIFParser(QUIET=True)",
            "lineNumber": 188
          },
          {
            "text": "        handle = io.StringIO(mmcif_string)",
            "lineNumber": 189
          },
          {
            "text": "        full_structure = parser.get_structure(\"\", handle)",
            "lineNumber": 190
          },
          {
            "text": "        first_model_structure = _get_first_model(full_structure)",
            "lineNumber": 191
          },
          {
            "text": "        # Extract the _mmcif_dict from the parser, which contains useful fields not",
            "lineNumber": 192
          },
          {
            "text": "        # reflected in the Biopython structure.",
            "lineNumber": 193
          },
          {
            "text": "        parsed_info = parser._mmcif_dict  # pylint:disable=protected-access",
            "lineNumber": 194
          },
          {
            "lineNumber": 195
          },
          {
            "text": "        # Ensure all values are lists, even if singletons.",
            "lineNumber": 196
          },
          {
            "text": "        for key, value in parsed_info.items():",
            "lineNumber": 197
          },
          {
            "text": "            if not isinstance(value, list):",
            "lineNumber": 198
          },
          {
            "text": "                parsed_info[key] = [value]",
            "lineNumber": 199
          },
          {
            "lineNumber": 200
          },
          {
            "text": "        header = _get_header(parsed_info)",
            "lineNumber": 201
          },
          {
            "lineNumber": 202
          },
          {
            "text": "        # Determine the protein chains, and their start numbers according to the",
            "lineNumber": 203
          },
          {
            "text": "        # internal mmCIF numbering scheme (likely but not guaranteed to be 1).",
            "lineNumber": 204
          },
          {
            "text": "        valid_chains = _get_protein_chains(parsed_info=parsed_info)",
            "lineNumber": 205
          },
          {
            "text": "        if not valid_chains:",
            "lineNumber": 206
          },
          {
            "text": "            return ParsingResult(",
            "lineNumber": 207
          },
          {
            "text": "                None, {(file_id, \"\"): \"No protein chains found in this file.\"}",
            "lineNumber": 208
          },
          {
            "text": "            )",
            "lineNumber": 209
          },
          {
            "text": "        seq_start_num = {",
            "lineNumber": 210
          },
          {
            "text": "            chain_id: min([monomer.num for monomer in seq])",
            "lineNumber": 211
          },
          {
            "text": "            for chain_id, seq in valid_chains.items()",
            "lineNumber": 212
          },
          {
            "text": "        }",
            "lineNumber": 213
          },
          {
            "lineNumber": 214
          },
          {
            "text": "        # Loop over the atoms for which we have coordinates. Populate two mappings:",
            "lineNumber": 215
          },
          {
            "text": "        # -mmcif_to_author_chain_id (maps internal mmCIF chain ids to chain ids used",
            "lineNumber": 216
          },
          {
            "text": "        # the authors / Biopython).",
            "lineNumber": 217
          },
          {
            "text": "        # -seq_to_structure_mappings (maps idx into sequence to ResidueAtPosition).",
            "lineNumber": 218
          },
          {
            "text": "        mmcif_to_author_chain_id = {}",
            "lineNumber": 219
          },
          {
            "text": "        seq_to_structure_mappings = {}",
            "lineNumber": 220
          },
          {
            "text": "        for atom in _get_atom_site_list(parsed_info):",
            "lineNumber": 221
          }
        ]
      },
      "score": 0.2830826938152313
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/README.md",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 31
          }
        },
        "contents": "# mber - Manifold Binder Engineering and Refinement\n\nAn open-source protein design framework for antibody binder design. mBER enables format specific binder design by leveraging structure templates and sequence conditioning in backprop design through AlphaFold-Multimer.\n\nPreprint with experimental validation: [https://www.biorxiv.org/content/10.1101/2025.09.26.678877v1](https://www.biorxiv.org/content/10.1101/2025.09.26.678877v1)\n## Graphical Abstract\n\n![Graphical Abstract](./assets/mBER_graphical_abstract.png)\n\n## Design Philosophy\n\nWe aim to create a flexible, modular, and efficient pipeline for the design of protein binders. Due to the variety of protein design problems, the parameters of these pipelines can be highly varied. To account for this, we aim to create a system that can be easily configured to suit the needs of the user. This is achieved via a series of core modules that can be easily swapped in and out, and a configuration system that allows for easy parameter tuning. These core modules include template preparation, trajectory optimization, and evaluation. These modules are defined in the &#96;src/mber/core/modules&#96; directory.\n\nTo avoid the common problem of ballooning config files, we have opted to create a set of protocols which extend the core modules to handle specific design problems. These protocols are stored in the &#96;protocols&#96; directory.\n\n## Architecture\n\nThe mber pipeline is built around three key modules:\n\n1. **Template** - Prepares target structures, identifies hotspots, and creates initial templates\n2. **Trajectory** - Designs binder sequences using protein folding models and optimization\n3. **Evaluation** - Evaluates designed binders using various metrics\n\nEach module is designed to be modular and configurable, with sensible defaults that can be overridden as needed.\n\n## Documentation\n\n- [Protocols Guide](./protocols/README.md) - How to create and use protocols\n- [Core Components](./src/mber/core/README.md) - Documentation of core functionality\n- [Example Notebooks](./notebooks) - Jupyter notebooks demonstrating usage",
        "signatures": {},
        "detailedLines": [
          {
            "text": "# mber - Manifold Binder Engineering and Refinement",
            "lineNumber": 1
          },
          {
            "lineNumber": 2
          },
          {
            "text": "An open-source protein design framework for antibody binder design. mBER enables format specific binder design by leveraging structure templates and sequence conditioning in backprop design through AlphaFold-Multimer.",
            "lineNumber": 3
          },
          {
            "lineNumber": 4
          },
          {
            "text": "Preprint with experimental validation: [https://www.biorxiv.org/content/10.1101/2025.09.26.678877v1](https://www.biorxiv.org/content/10.1101/2025.09.26.678877v1)",
            "lineNumber": 5
          },
          {
            "text": "## Graphical Abstract",
            "lineNumber": 6
          },
          {
            "lineNumber": 7
          },
          {
            "text": "![Graphical Abstract](./assets/mBER_graphical_abstract.png)",
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "## Design Philosophy",
            "lineNumber": 10
          },
          {
            "lineNumber": 11
          },
          {
            "text": "We aim to create a flexible, modular, and efficient pipeline for the design of protein binders. Due to the variety of protein design problems, the parameters of these pipelines can be highly varied. To account for this, we aim to create a system that can be easily configured to suit the needs of the user. This is achieved via a series of core modules that can be easily swapped in and out, and a configuration system that allows for easy parameter tuning. These core modules include template preparation, trajectory optimization, and evaluation. These modules are defined in the &#96;src/mber/core/modules&#96; directory.",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "To avoid the common problem of ballooning config files, we have opted to create a set of protocols which extend the core modules to handle specific design problems. These protocols are stored in the &#96;protocols&#96; directory.",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "## Architecture",
            "lineNumber": 16
          },
          {
            "lineNumber": 17
          },
          {
            "text": "The mber pipeline is built around three key modules:",
            "lineNumber": 18
          },
          {
            "lineNumber": 19
          },
          {
            "text": "1. **Template** - Prepares target structures, identifies hotspots, and creates initial templates",
            "lineNumber": 20
          },
          {
            "text": "2. **Trajectory** - Designs binder sequences using protein folding models and optimization",
            "lineNumber": 21
          },
          {
            "text": "3. **Evaluation** - Evaluates designed binders using various metrics",
            "lineNumber": 22
          },
          {
            "lineNumber": 23
          },
          {
            "text": "Each module is designed to be modular and configurable, with sensible defaults that can be overridden as needed.",
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "## Documentation",
            "lineNumber": 26
          },
          {
            "lineNumber": 27
          },
          {
            "text": "- [Protocols Guide](./protocols/README.md) - How to create and use protocols",
            "lineNumber": 28
          },
          {
            "text": "- [Core Components](./src/mber/core/README.md) - Documentation of core functionality",
            "lineNumber": 29
          },
          {
            "text": "- [Example Notebooks](./notebooks) - Jupyter notebooks demonstrating usage",
            "lineNumber": 30
          }
        ]
      },
      "score": 0.26963263750076294
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/modules/trajectory.py",
        "range": {
          "startPosition": {
            "line": 32
          },
          "endPosition": {
            "line": 481
          }
        },
        "contents": "class BaseTrajectoryModule(BaseModule):\n@time_method()\ndef _setup_trajectory(self, design_state: DesignState) -&gt; None:\n\n\n        with tempfile.NamedTemporaryFile(suffix=\".pdb\") as template_pdb:\n            # Write template_pdb to tmpfile as raw text\n            template_pdb.write(design_state.template_data.template_pdb.encode())\n            template_pdb.flush()\n            pdb_filename = template_pdb.name\n\n            # Configure masking options based on trajectory config\n            rm_binder_template = (\n                design_state.template_data.get_flex_pos(as_array=False)\n                if self.trajectory_config.mask_binder_variable_template\n                else False\n            )\n\n            rm_binder_seq = (\n                True\n                if self.trajectory_config.mask_binder_seq\n                else design_state.template_data.get_flex_pos(as_array=False)\n            )\n\n            rm_binder_sc = (\n                True\n                if self.trajectory_config.mask_binder_sidechains\n                else design_state.template_data.get_flex_pos(as_array=False)\n            )\n\n            if self.trajectory_config.mask_binder:\n                rm_binder_template = True\n                rm_binder_seq = True\n                rm_binder_sc = True\n\n            # Initialize AF model with the template\n            \n            # Now that we've renamed all chains in the PDB files to H, we use the proper chain IDs\n            self.af_model._prep_binder(\n                pdb_filename=pdb_filename,\n                chain=design_state.template_data.target_chain, \n                binder_chain=design_state.template_data.binder_chain,\n                binder_len=design_state.template_data.binder_len,\n                hotspot=design_state.template_data.target_hotspot_residues,\n                seed=design_state.trajectory_data.seed,\n                rm_aa=self.trajectory_config.rm_aa,\n                rm_target=self.trajectory_config.mask_target,\n                rm_target_seq=self.trajectory_config.mask_target_seq,\n                rm_target_sc=self.trajectory_config.mask_target_sidechains,\n                rm_template_ic=True,\n                rm_binder=rm_binder_template,\n                rm_binder_seq=rm_binder_seq,\n                rm_binder_sc=rm_binder_sc,\n            )\n\n        # Fix unmasked residues for pssm step\n        self.af_model.opt[\"fix_binder_pos\"]",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 33,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 230,
                "column": 5
              },
              "endPosition": {
                "line": 231,
                "column": 5
              }
            },
            {
              "startPosition": {
                "line": 231,
                "column": 5
              },
              "endPosition": {
                "line": 232,
                "column": 9
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class BaseTrajectoryModule(BaseModule):",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "text": "@time_method()",
            "lineNumber": 230
          },
          {
            "text": "def _setup_trajectory(self, design_state: DesignState) -&gt; None:",
            "lineNumber": 231
          },
          {
            "lineNumber": 245
          },
          {
            "lineNumber": 246
          },
          {
            "text": "        with tempfile.NamedTemporaryFile(suffix=\".pdb\") as template_pdb:",
            "lineNumber": 247
          },
          {
            "text": "            # Write template_pdb to tmpfile as raw text",
            "lineNumber": 248
          },
          {
            "text": "            template_pdb.write(design_state.template_data.template_pdb.encode())",
            "lineNumber": 249
          },
          {
            "text": "            template_pdb.flush()",
            "lineNumber": 250
          },
          {
            "text": "            pdb_filename = template_pdb.name",
            "lineNumber": 251
          },
          {
            "lineNumber": 252
          },
          {
            "text": "            # Configure masking options based on trajectory config",
            "lineNumber": 253
          },
          {
            "text": "            rm_binder_template = (",
            "lineNumber": 254
          },
          {
            "text": "                design_state.template_data.get_flex_pos(as_array=False)",
            "lineNumber": 255
          },
          {
            "text": "                if self.trajectory_config.mask_binder_variable_template",
            "lineNumber": 256
          },
          {
            "text": "                else False",
            "lineNumber": 257
          },
          {
            "text": "            )",
            "lineNumber": 258
          },
          {
            "lineNumber": 259
          },
          {
            "text": "            rm_binder_seq = (",
            "lineNumber": 260
          },
          {
            "text": "                True",
            "lineNumber": 261
          },
          {
            "text": "                if self.trajectory_config.mask_binder_seq",
            "lineNumber": 262
          },
          {
            "text": "                else design_state.template_data.get_flex_pos(as_array=False)",
            "lineNumber": 263
          },
          {
            "text": "            )",
            "lineNumber": 264
          },
          {
            "lineNumber": 265
          },
          {
            "text": "            rm_binder_sc = (",
            "lineNumber": 266
          },
          {
            "text": "                True",
            "lineNumber": 267
          },
          {
            "text": "                if self.trajectory_config.mask_binder_sidechains",
            "lineNumber": 268
          },
          {
            "text": "                else design_state.template_data.get_flex_pos(as_array=False)",
            "lineNumber": 269
          },
          {
            "text": "            )",
            "lineNumber": 270
          },
          {
            "lineNumber": 271
          },
          {
            "text": "            if self.trajectory_config.mask_binder:",
            "lineNumber": 272
          },
          {
            "text": "                rm_binder_template = True",
            "lineNumber": 273
          },
          {
            "text": "                rm_binder_seq = True",
            "lineNumber": 274
          },
          {
            "text": "                rm_binder_sc = True",
            "lineNumber": 275
          },
          {
            "lineNumber": 276
          },
          {
            "text": "            # Initialize AF model with the template",
            "lineNumber": 277
          },
          {
            "text": "            ",
            "lineNumber": 278
          },
          {
            "text": "            # Now that we've renamed all chains in the PDB files to H, we use the proper chain IDs",
            "lineNumber": 279
          },
          {
            "text": "            self.af_model._prep_binder(",
            "lineNumber": 280
          },
          {
            "text": "                pdb_filename=pdb_filename,",
            "lineNumber": 281
          },
          {
            "text": "                chain=design_state.template_data.target_chain, ",
            "lineNumber": 282
          },
          {
            "text": "                binder_chain=design_state.template_data.binder_chain,",
            "lineNumber": 283
          },
          {
            "text": "                binder_len=design_state.template_data.binder_len,",
            "lineNumber": 284
          },
          {
            "text": "                hotspot=design_state.template_data.target_hotspot_residues,",
            "lineNumber": 285
          },
          {
            "text": "                seed=design_state.trajectory_data.seed,",
            "lineNumber": 286
          },
          {
            "text": "                rm_aa=self.trajectory_config.rm_aa,",
            "lineNumber": 287
          },
          {
            "text": "                rm_target=self.trajectory_config.mask_target,",
            "lineNumber": 288
          },
          {
            "text": "                rm_target_seq=self.trajectory_config.mask_target_seq,",
            "lineNumber": 289
          },
          {
            "text": "                rm_target_sc=self.trajectory_config.mask_target_sidechains,",
            "lineNumber": 290
          },
          {
            "text": "                rm_template_ic=True,",
            "lineNumber": 291
          },
          {
            "text": "                rm_binder=rm_binder_template,",
            "lineNumber": 292
          },
          {
            "text": "                rm_binder_seq=rm_binder_seq,",
            "lineNumber": 293
          },
          {
            "text": "                rm_binder_sc=rm_binder_sc,",
            "lineNumber": 294
          },
          {
            "text": "            )",
            "lineNumber": 295
          },
          {
            "lineNumber": 296
          },
          {
            "text": "        # Fix unmasked residues for pssm step",
            "lineNumber": 297
          },
          {
            "text": "        self.af_model.opt[\"fix_binder_pos\"]",
            "lineNumber": 298
          }
        ]
      },
      "score": 0.2631736993789673
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/common/protein.py",
        "range": {
          "startPosition": {
            "line": 99
          },
          "endPosition": {
            "line": 178
          }
        },
        "contents": "def _from_bio_structure(\n    structure: Structure, chain_id: Optional[str] = None\n) -&gt; Protein:\n\n    chain_ids = []\n    b_factors = []\n\n    for chain in model:\n        if chain_id is not None and chain.id != chain_id:\n            continue\n        for res in chain:\n            if res.id[2] != \" \":\n                raise ValueError(\n                    f\"PDB/mmCIF contains an insertion code at chain {chain.id} and\"\n                    f\" residue index {res.id[1]}. These are not supported.\"\n                )\n            res_shortname = residue_constants.restype_3to1.get(res.resname, \"X\")\n            restype_idx = residue_constants.restype_order.get(\n                res_shortname, residue_constants.restype_num\n            )\n            pos = np.zeros((residue_constants.atom_type_num, 3))\n            mask = np.zeros((residue_constants.atom_type_num,))\n            res_b_factors = np.zeros((residue_constants.atom_type_num,))\n            for atom in res:\n                if atom.name not in residue_constants.atom_types:\n                    continue\n                pos[residue_constants.atom_order[atom.name]] = atom.coord\n                mask[residue_constants.atom_order[atom.name]] = 1.0\n                res_b_factors[residue_constants.atom_order[atom.name]] = atom.bfactor\n            if np.sum(mask) &lt; 0.5:\n                # If no known atom positions are reported for the residue then skip it.\n                continue\n            aatype.append(restype_idx)\n            atom_positions.append(pos)\n            atom_mask.append(mask)\n            residue_index.append(res.id[1])\n            chain_ids.append(chain.id)\n            b_factors.append(res_b_factors)\n\n    # Chain IDs are usually characters so map these to ints.\n    unique_chain_ids = np.unique(chain_ids)\n    chain_id_mapping = {cid: n for n, cid in enumerate(unique_chain_ids)}\n    chain_index = np.array([chain_id_mapping[cid] for cid in chain_ids])\n\n    return Protein(\n        atom_positions=np.array(atom_positions),",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 100,
                "column": 1
              },
              "endPosition": {
                "line": 103,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "def _from_bio_structure(",
            "lineNumber": 100,
            "isSignature": true
          },
          {
            "text": "    structure: Structure, chain_id: Optional[str] = None",
            "lineNumber": 101,
            "isSignature": true
          },
          {
            "text": ") -&gt; Protein:",
            "lineNumber": 102,
            "isSignature": true
          },
          {
            "lineNumber": 131
          },
          {
            "text": "    chain_ids = []",
            "lineNumber": 132
          },
          {
            "text": "    b_factors = []",
            "lineNumber": 133
          },
          {
            "lineNumber": 134
          },
          {
            "text": "    for chain in model:",
            "lineNumber": 135
          },
          {
            "text": "        if chain_id is not None and chain.id != chain_id:",
            "lineNumber": 136
          },
          {
            "text": "            continue",
            "lineNumber": 137
          },
          {
            "text": "        for res in chain:",
            "lineNumber": 138
          },
          {
            "text": "            if res.id[2] != \" \":",
            "lineNumber": 139
          },
          {
            "text": "                raise ValueError(",
            "lineNumber": 140
          },
          {
            "text": "                    f\"PDB/mmCIF contains an insertion code at chain {chain.id} and\"",
            "lineNumber": 141
          },
          {
            "text": "                    f\" residue index {res.id[1]}. These are not supported.\"",
            "lineNumber": 142
          },
          {
            "text": "                )",
            "lineNumber": 143
          },
          {
            "text": "            res_shortname = residue_constants.restype_3to1.get(res.resname, \"X\")",
            "lineNumber": 144
          },
          {
            "text": "            restype_idx = residue_constants.restype_order.get(",
            "lineNumber": 145
          },
          {
            "text": "                res_shortname, residue_constants.restype_num",
            "lineNumber": 146
          },
          {
            "text": "            )",
            "lineNumber": 147
          },
          {
            "text": "            pos = np.zeros((residue_constants.atom_type_num, 3))",
            "lineNumber": 148
          },
          {
            "text": "            mask = np.zeros((residue_constants.atom_type_num,))",
            "lineNumber": 149
          },
          {
            "text": "            res_b_factors = np.zeros((residue_constants.atom_type_num,))",
            "lineNumber": 150
          },
          {
            "text": "            for atom in res:",
            "lineNumber": 151
          },
          {
            "text": "                if atom.name not in residue_constants.atom_types:",
            "lineNumber": 152
          },
          {
            "text": "                    continue",
            "lineNumber": 153
          },
          {
            "text": "                pos[residue_constants.atom_order[atom.name]] = atom.coord",
            "lineNumber": 154
          },
          {
            "text": "                mask[residue_constants.atom_order[atom.name]] = 1.0",
            "lineNumber": 155
          },
          {
            "text": "                res_b_factors[residue_constants.atom_order[atom.name]] = atom.bfactor",
            "lineNumber": 156
          },
          {
            "text": "            if np.sum(mask) &lt; 0.5:",
            "lineNumber": 157
          },
          {
            "text": "                # If no known atom positions are reported for the residue then skip it.",
            "lineNumber": 158
          },
          {
            "text": "                continue",
            "lineNumber": 159
          },
          {
            "text": "            aatype.append(restype_idx)",
            "lineNumber": 160
          },
          {
            "text": "            atom_positions.append(pos)",
            "lineNumber": 161
          },
          {
            "text": "            atom_mask.append(mask)",
            "lineNumber": 162
          },
          {
            "text": "            residue_index.append(res.id[1])",
            "lineNumber": 163
          },
          {
            "text": "            chain_ids.append(chain.id)",
            "lineNumber": 164
          },
          {
            "text": "            b_factors.append(res_b_factors)",
            "lineNumber": 165
          },
          {
            "lineNumber": 166
          },
          {
            "text": "    # Chain IDs are usually characters so map these to ints.",
            "lineNumber": 167
          },
          {
            "text": "    unique_chain_ids = np.unique(chain_ids)",
            "lineNumber": 168
          },
          {
            "text": "    chain_id_mapping = {cid: n for n, cid in enumerate(unique_chain_ids)}",
            "lineNumber": 169
          },
          {
            "text": "    chain_index = np.array([chain_id_mapping[cid] for cid in chain_ids])",
            "lineNumber": 170
          },
          {
            "lineNumber": 171
          },
          {
            "text": "    return Protein(",
            "lineNumber": 172
          },
          {
            "text": "        atom_positions=np.array(atom_positions),",
            "lineNumber": 173
          }
        ]
      },
      "score": 0.26293134689331055
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/templates.py",
        "range": {
          "startPosition": {
            "line": 239,
            "column": 15
          },
          "endPosition": {
            "line": 304
          }
        },
        "contents": "def _find_template_in_pdb(\n    template_chain_id: str,\n    template_sequence: str,\n    mmcif_object: mmcif_parsing.MmcifObject,\n) -&gt; Tuple[str, str, int]:\n    \"\"\"Tries to find the template chain in the given pdb file.\n\n    This method tries the three following things in order:\n      1. Tries if there is an exact match in both the chain ID and the sequence.\n         If yes, the chain sequence is returned. Otherwise:\n      2. Tries if there is an exact match only in the sequence.\n         If yes, the chain sequence is returned. Otherwise:\n      3. Tries if there is a fuzzy match (X = wildcard) in the sequence.\n         If yes, the chain sequence is returned.\n    If none of these succeed, a SequenceNotInTemplateError is thrown.\n\n    Args:\n      template_chain_id: The template chain ID.\n      template_sequence: The template chain sequence.\n      mmcif_object: The PDB object to search for the template in.\n\n    Returns:\n      A tuple with:\n      * The chain sequence that was found to match the template in the PDB object.\n      * The ID of the chain that is being returned.\n      * The offset where the template sequence starts in the chain sequence.\n\n    Raises:\n      SequenceNotInTemplateError: If no match is found after the steps described\n        above.\n    \"\"\"\n    # Try if there is an exact match in both the chain ID and the (sub)sequence.\n    pdb_id = mmcif_object.file_id\n    chain_sequence = mmcif_object.chain_to_seqres.get(template_chain_id)\n    if chain_sequence and (template_sequence in chain_sequence):\n        logging.info(\"Found an exact template match %s_%s.\", pdb_id, template_chain_id)\n        mapping_offset = chain_sequence.find(template_sequence)\n        return chain_sequence, template_chain_id, mapping_offset\n\n    # Try if there is an exact match in the (sub)sequence only.",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _find_template_in_pdb(",
            "lineNumber": 243,
            "isSignature": true
          },
          {
            "text": "    template_chain_id: str,",
            "lineNumber": 244,
            "isSignature": true
          },
          {
            "text": "    template_sequence: str,",
            "lineNumber": 245,
            "isSignature": true
          },
          {
            "text": "    mmcif_object: mmcif_parsing.MmcifObject,",
            "lineNumber": 246,
            "isSignature": true
          },
          {
            "text": ") -&gt; Tuple[str, str, int]:",
            "lineNumber": 247,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Tries to find the template chain in the given pdb file.",
            "lineNumber": 248
          },
          {
            "lineNumber": 249
          },
          {
            "text": "    This method tries the three following things in order:",
            "lineNumber": 250
          },
          {
            "text": "      1. Tries if there is an exact match in both the chain ID and the sequence.",
            "lineNumber": 251
          },
          {
            "text": "         If yes, the chain sequence is returned. Otherwise:",
            "lineNumber": 252
          },
          {
            "text": "      2. Tries if there is an exact match only in the sequence.",
            "lineNumber": 253
          },
          {
            "text": "         If yes, the chain sequence is returned. Otherwise:",
            "lineNumber": 254
          },
          {
            "text": "      3. Tries if there is a fuzzy match (X = wildcard) in the sequence.",
            "lineNumber": 255
          },
          {
            "text": "         If yes, the chain sequence is returned.",
            "lineNumber": 256
          },
          {
            "text": "    If none of these succeed, a SequenceNotInTemplateError is thrown.",
            "lineNumber": 257
          },
          {
            "lineNumber": 258
          },
          {
            "text": "    Args:",
            "lineNumber": 259
          },
          {
            "text": "      template_chain_id: The template chain ID.",
            "lineNumber": 260
          },
          {
            "text": "      template_sequence: The template chain sequence.",
            "lineNumber": 261
          },
          {
            "text": "      mmcif_object: The PDB object to search for the template in.",
            "lineNumber": 262
          },
          {
            "lineNumber": 263
          },
          {
            "text": "    Returns:",
            "lineNumber": 264
          },
          {
            "text": "      A tuple with:",
            "lineNumber": 265
          },
          {
            "text": "      * The chain sequence that was found to match the template in the PDB object.",
            "lineNumber": 266
          },
          {
            "text": "      * The ID of the chain that is being returned.",
            "lineNumber": 267
          },
          {
            "text": "      * The offset where the template sequence starts in the chain sequence.",
            "lineNumber": 268
          },
          {
            "lineNumber": 269
          },
          {
            "text": "    Raises:",
            "lineNumber": 270
          },
          {
            "text": "      SequenceNotInTemplateError: If no match is found after the steps described",
            "lineNumber": 271
          },
          {
            "text": "        above.",
            "lineNumber": 272
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 273
          },
          {
            "text": "    # Try if there is an exact match in both the chain ID and the (sub)sequence.",
            "lineNumber": 274
          },
          {
            "text": "    pdb_id = mmcif_object.file_id",
            "lineNumber": 275
          },
          {
            "text": "    chain_sequence = mmcif_object.chain_to_seqres.get(template_chain_id)",
            "lineNumber": 276
          },
          {
            "text": "    if chain_sequence and (template_sequence in chain_sequence):",
            "lineNumber": 277
          },
          {
            "text": "        logging.info(\"Found an exact template match %s_%s.\", pdb_id, template_chain_id)",
            "lineNumber": 278
          },
          {
            "text": "        mapping_offset = chain_sequence.find(template_sequence)",
            "lineNumber": 279
          },
          {
            "text": "        return chain_sequence, template_chain_id, mapping_offset",
            "lineNumber": 280
          },
          {
            "lineNumber": 281
          },
          {
            "text": "    # Try if there is an exact match in the (sub)sequence only.",
            "lineNumber": 282
          }
        ]
      },
      "score": 0.25974419713020325
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/mmcif_parsing.py",
        "range": {
          "startPosition": {
            "line": 168
          },
          "endPosition": {
            "line": 289
          }
        },
        "contents": "@functools.lru_cache(16, typed=False)\ndef parse(\n    *, file_id: str, mmcif_string: str, catch_all_errors: bool = True\n) -&gt; ParsingResult:\n\n        mmcif_to_author_chain_id = {}\n        seq_to_structure_mappings = {}\n        for atom in _get_atom_site_list(parsed_info):\n            if atom.model_num != \"1\":\n                # We only process the first model at the moment.\n                continue\n\n            mmcif_to_author_chain_id[atom.mmcif_chain_id] = atom.author_chain_id\n\n            if atom.mmcif_chain_id in valid_chains:\n                hetflag = \" \"\n                if atom.hetatm_atom == \"HETATM\":\n                    # Water atoms are assigned a special hetflag of W in Biopython. We\n                    # need to do the same, so that this hetflag can be used to fetch\n                    # a residue from the Biopython structure by id.\n                    if atom.residue_name in (\"HOH\", \"WAT\"):\n                        hetflag = \"W\"\n                    else:\n                        hetflag = \"H_\" + atom.residue_name\n                insertion_code = atom.insertion_code\n                if not _is_set(atom.insertion_code):\n                    insertion_code = \" \"\n                position = ResiduePosition(\n                    chain_id=atom.author_chain_id,\n                    residue_number=int(atom.author_seq_num),\n                    insertion_code=insertion_code,\n                )\n                seq_idx = int(atom.mmcif_seq_num) - seq_start_num[atom.mmcif_chain_id]\n                current = seq_to_structure_mappings.get(atom.author_chain_id, {})\n                current[seq_idx] = ResidueAtPosition(\n                    position=position,\n                    name=atom.residue_name,\n                    is_missing=False,\n                    hetflag=hetflag,\n                )\n                seq_to_structure_mappings[atom.author_chain_id] = current\n\n        # Add missing residue information to seq_to_structure_mappings.\n        for",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 169,
                "column": 1
              },
              "endPosition": {
                "line": 170,
                "column": 1
              }
            },
            {
              "startPosition": {
                "line": 170,
                "column": 1
              },
              "endPosition": {
                "line": 173,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "@functools.lru_cache(16, typed=False)",
            "lineNumber": 169
          },
          {
            "text": "def parse(",
            "lineNumber": 170,
            "isSignature": true
          },
          {
            "text": "    *, file_id: str, mmcif_string: str, catch_all_errors: bool = True",
            "lineNumber": 171,
            "isSignature": true
          },
          {
            "text": ") -&gt; ParsingResult:",
            "lineNumber": 172,
            "isSignature": true
          },
          {
            "lineNumber": 218
          },
          {
            "text": "        mmcif_to_author_chain_id = {}",
            "lineNumber": 219
          },
          {
            "text": "        seq_to_structure_mappings = {}",
            "lineNumber": 220
          },
          {
            "text": "        for atom in _get_atom_site_list(parsed_info):",
            "lineNumber": 221
          },
          {
            "text": "            if atom.model_num != \"1\":",
            "lineNumber": 222
          },
          {
            "text": "                # We only process the first model at the moment.",
            "lineNumber": 223
          },
          {
            "text": "                continue",
            "lineNumber": 224
          },
          {
            "lineNumber": 225
          },
          {
            "text": "            mmcif_to_author_chain_id[atom.mmcif_chain_id] = atom.author_chain_id",
            "lineNumber": 226
          },
          {
            "lineNumber": 227
          },
          {
            "text": "            if atom.mmcif_chain_id in valid_chains:",
            "lineNumber": 228
          },
          {
            "text": "                hetflag = \" \"",
            "lineNumber": 229
          },
          {
            "text": "                if atom.hetatm_atom == \"HETATM\":",
            "lineNumber": 230
          },
          {
            "text": "                    # Water atoms are assigned a special hetflag of W in Biopython. We",
            "lineNumber": 231
          },
          {
            "text": "                    # need to do the same, so that this hetflag can be used to fetch",
            "lineNumber": 232
          },
          {
            "text": "                    # a residue from the Biopython structure by id.",
            "lineNumber": 233
          },
          {
            "text": "                    if atom.residue_name in (\"HOH\", \"WAT\"):",
            "lineNumber": 234
          },
          {
            "text": "                        hetflag = \"W\"",
            "lineNumber": 235
          },
          {
            "text": "                    else:",
            "lineNumber": 236
          },
          {
            "text": "                        hetflag = \"H_\" + atom.residue_name",
            "lineNumber": 237
          },
          {
            "text": "                insertion_code = atom.insertion_code",
            "lineNumber": 238
          },
          {
            "text": "                if not _is_set(atom.insertion_code):",
            "lineNumber": 239
          },
          {
            "text": "                    insertion_code = \" \"",
            "lineNumber": 240
          },
          {
            "text": "                position = ResiduePosition(",
            "lineNumber": 241
          },
          {
            "text": "                    chain_id=atom.author_chain_id,",
            "lineNumber": 242
          },
          {
            "text": "                    residue_number=int(atom.author_seq_num),",
            "lineNumber": 243
          },
          {
            "text": "                    insertion_code=insertion_code,",
            "lineNumber": 244
          },
          {
            "text": "                )",
            "lineNumber": 245
          },
          {
            "text": "                seq_idx = int(atom.mmcif_seq_num) - seq_start_num[atom.mmcif_chain_id]",
            "lineNumber": 246
          },
          {
            "text": "                current = seq_to_structure_mappings.get(atom.author_chain_id, {})",
            "lineNumber": 247
          },
          {
            "text": "                current[seq_idx] = ResidueAtPosition(",
            "lineNumber": 248
          },
          {
            "text": "                    position=position,",
            "lineNumber": 249
          },
          {
            "text": "                    name=atom.residue_name,",
            "lineNumber": 250
          },
          {
            "text": "                    is_missing=False,",
            "lineNumber": 251
          },
          {
            "text": "                    hetflag=hetflag,",
            "lineNumber": 252
          },
          {
            "text": "                )",
            "lineNumber": 253
          },
          {
            "text": "                seq_to_structure_mappings[atom.author_chain_id] = current",
            "lineNumber": 254
          },
          {
            "lineNumber": 255
          },
          {
            "text": "        # Add missing residue information to seq_to_structure_mappings.",
            "lineNumber": 256
          },
          {
            "text": "        for",
            "lineNumber": 257
          }
        ]
      },
      "score": 0.2573244869709015
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/mmcif_parsing.py",
        "range": {
          "startPosition": {
            "line": 355,
            "column": 5
          },
          "endPosition": {
            "line": 414
          }
        },
        "contents": "def _get_protein_chains(\n    *, parsed_info: Mapping[str, Any]\n) -&gt; Mapping[ChainId, Sequence[Monomer]]:\n    \"\"\"Extracts polymer information for protein chains only.\n\n    Args:\n      parsed_info: _mmcif_dict produced by the Biopython parser.\n\n    Returns:\n      A dict mapping mmcif chain id to a list of Monomers.\n    \"\"\"\n    # Get polymer information for each entity in the structure.\n    entity_poly_seqs = mmcif_loop_to_list(\"_entity_poly_seq.\", parsed_info)\n\n    polymers = collections.defaultdict(list)\n    for entity_poly_seq in entity_poly_seqs:\n        polymers[entity_poly_seq[\"_entity_poly_seq.entity_id\"]].append(\n            Monomer(\n                id=entity_poly_seq[\"_entity_poly_seq.mon_id\"],\n                num=int(entity_poly_seq[\"_entity_poly_seq.num\"]),\n            )\n        )\n\n    # Get chemical compositions. Will allow us to identify which of these polymers\n    # are proteins.\n    chem_comps = mmcif_loop_to_dict(\"_chem_comp.\", \"_chem_comp.id\", parsed_info)\n\n    # Get chains information for each entity. Necessary so that we can return a\n    # dict keyed on chain id rather than entity.\n    struct_asyms = mmcif_loop_to_list(\"_struct_asym.\", parsed_info)\n\n    entity_to_mmcif_chains = collections.defaultdict(list)\n    for struct_asym in struct_asyms:\n        chain_id = struct_asym[\"_struct_asym.id\"]\n        entity_id = struct_asym[\"_struct_asym.entity_id\"]\n        entity_to_mmcif_chains[entity_id].append(chain_id)\n\n    # Identify and return the valid protein chains.\n    valid_chains = {}\n    for entity_id, seq_info in polymers.items():\n        chain_ids = entity_to_mmcif_chains[entity_id]\n\n        # Reject polymers without any peptide-like components, such as DNA/RNA.\n        if any(\n            [\n                \"peptide\" in chem_comps[monomer.id][\"_chem_comp.type\"].lower()\n                for monomer in seq_info\n            ]\n        ):\n            for chain_id in chain_ids:\n                valid_chains[chain_id] = seq_info\n    return valid_chains\n\n\ndef _is_set(data: str) -&gt; bool:\n    \"\"\"Returns False if data is a special mmCIF character indicating 'unset'.\"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def _get_protein_chains(",
            "lineNumber": 359,
            "isSignature": true
          },
          {
            "text": "    *, parsed_info: Mapping[str, Any]",
            "lineNumber": 360,
            "isSignature": true
          },
          {
            "text": ") -&gt; Mapping[ChainId, Sequence[Monomer]]:",
            "lineNumber": 361,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Extracts polymer information for protein chains only.",
            "lineNumber": 362
          },
          {
            "lineNumber": 363
          },
          {
            "text": "    Args:",
            "lineNumber": 364
          },
          {
            "text": "      parsed_info: _mmcif_dict produced by the Biopython parser.",
            "lineNumber": 365
          },
          {
            "lineNumber": 366
          },
          {
            "text": "    Returns:",
            "lineNumber": 367
          },
          {
            "text": "      A dict mapping mmcif chain id to a list of Monomers.",
            "lineNumber": 368
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 369
          },
          {
            "text": "    # Get polymer information for each entity in the structure.",
            "lineNumber": 370
          },
          {
            "text": "    entity_poly_seqs = mmcif_loop_to_list(\"_entity_poly_seq.\", parsed_info)",
            "lineNumber": 371
          },
          {
            "lineNumber": 372
          },
          {
            "text": "    polymers = collections.defaultdict(list)",
            "lineNumber": 373
          },
          {
            "text": "    for entity_poly_seq in entity_poly_seqs:",
            "lineNumber": 374
          },
          {
            "text": "        polymers[entity_poly_seq[\"_entity_poly_seq.entity_id\"]].append(",
            "lineNumber": 375
          },
          {
            "text": "            Monomer(",
            "lineNumber": 376
          },
          {
            "text": "                id=entity_poly_seq[\"_entity_poly_seq.mon_id\"],",
            "lineNumber": 377
          },
          {
            "text": "                num=int(entity_poly_seq[\"_entity_poly_seq.num\"]),",
            "lineNumber": 378
          },
          {
            "text": "            )",
            "lineNumber": 379
          },
          {
            "text": "        )",
            "lineNumber": 380
          },
          {
            "lineNumber": 381
          },
          {
            "text": "    # Get chemical compositions. Will allow us to identify which of these polymers",
            "lineNumber": 382
          },
          {
            "text": "    # are proteins.",
            "lineNumber": 383
          },
          {
            "text": "    chem_comps = mmcif_loop_to_dict(\"_chem_comp.\", \"_chem_comp.id\", parsed_info)",
            "lineNumber": 384
          },
          {
            "lineNumber": 385
          },
          {
            "text": "    # Get chains information for each entity. Necessary so that we can return a",
            "lineNumber": 386
          },
          {
            "text": "    # dict keyed on chain id rather than entity.",
            "lineNumber": 387
          },
          {
            "text": "    struct_asyms = mmcif_loop_to_list(\"_struct_asym.\", parsed_info)",
            "lineNumber": 388
          },
          {
            "lineNumber": 389
          },
          {
            "text": "    entity_to_mmcif_chains = collections.defaultdict(list)",
            "lineNumber": 390
          },
          {
            "text": "    for struct_asym in struct_asyms:",
            "lineNumber": 391
          },
          {
            "text": "        chain_id = struct_asym[\"_struct_asym.id\"]",
            "lineNumber": 392
          },
          {
            "text": "        entity_id = struct_asym[\"_struct_asym.entity_id\"]",
            "lineNumber": 393
          },
          {
            "text": "        entity_to_mmcif_chains[entity_id].append(chain_id)",
            "lineNumber": 394
          },
          {
            "lineNumber": 395
          },
          {
            "text": "    # Identify and return the valid protein chains.",
            "lineNumber": 396
          },
          {
            "text": "    valid_chains = {}",
            "lineNumber": 397
          },
          {
            "text": "    for entity_id, seq_info in polymers.items():",
            "lineNumber": 398
          },
          {
            "text": "        chain_ids = entity_to_mmcif_chains[entity_id]",
            "lineNumber": 399
          },
          {
            "lineNumber": 400
          },
          {
            "text": "        # Reject polymers without any peptide-like components, such as DNA/RNA.",
            "lineNumber": 401
          },
          {
            "text": "        if any(",
            "lineNumber": 402
          },
          {
            "text": "            [",
            "lineNumber": 403
          },
          {
            "text": "                \"peptide\" in chem_comps[monomer.id][\"_chem_comp.type\"].lower()",
            "lineNumber": 404
          },
          {
            "text": "                for monomer in seq_info",
            "lineNumber": 405
          },
          {
            "text": "            ]",
            "lineNumber": 406
          },
          {
            "text": "        ):",
            "lineNumber": 407
          },
          {
            "text": "            for chain_id in chain_ids:",
            "lineNumber": 408
          },
          {
            "text": "                valid_chains[chain_id] = seq_info",
            "lineNumber": 409
          },
          {
            "text": "    return valid_chains",
            "lineNumber": 410,
            "isSignature": true
          },
          {
            "lineNumber": 411
          },
          {
            "lineNumber": 412
          },
          {
            "text": "def _is_set(data: str) -&gt; bool:",
            "lineNumber": 413,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Returns False if data is a special mmCIF character indicating 'unset'.\"\"\"",
            "lineNumber": 414
          }
        ]
      },
      "score": 0.2562834918498993
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/common/protein.py",
        "range": {
          "startPosition": {
            "line": 378,
            "column": 5
          },
          "endPosition": {
            "line": 515
          }
        },
        "contents": "def to_mmcif(\n    prot: Protein,\n    file_id: str,\n    model_type: str,\n) -&gt; str:\n    \"\"\"Converts a &#96;Protein&#96; instance to an mmCIF string.\n\n    WARNING 1: The _entity_poly_seq is filled with unknown (UNK) residues for any\n      missing residue indices in the range from min(1, min(residue_index)) to\n      max(residue_index). E.g. for a protein object with positions for residues\n      2 (MET), 3 (LYS), 6 (GLY), this method would set the _entity_poly_seq to:\n      1 UNK\n      2 MET\n      3 LYS\n      4 UNK\n      5 UNK\n      6 GLY\n      This is done to preserve the residue numbering.\n\n    WARNING 2: Converting ground truth mmCIF file to Protein and then back to\n      mmCIF using this method will convert all non-standard residue types to UNK.\n      If you need this behaviour, you need to store more mmCIF metadata in the\n      Protein object (e.g. all fields except for the _atom_site loop).\n\n    WARNING 3: Converting ground truth mmCIF file to Protein and then back to\n      mmCIF using this method will not retain the original chain indices.\n\n    WARNING 4: In case of multiple identical chains, they are assigned different\n      &#96;_atom_site.label_entity_id&#96; values.\n\n    Args:\n      prot: A protein to convert to mmCIF string.\n      file_id: The file ID (usually the PDB ID) to be used in the mmCIF.\n      model_type: 'Multimer' or 'Monomer'.\n\n    Returns:\n      A valid mmCIF string.\n\n    Raises:\n      ValueError: If aminoacid types array contains entries with too many protein\n      types.\n    \"\"\"\n    atom_mask = prot.atom_mask\n    aatype = prot.aatype\n    atom_positions = prot.atom_positions\n    residue_index = prot.residue_index.astype(np.int32)\n    chain_index = prot.chain_index.astype(np.int32)\n    b_factors = prot.b_factors\n\n    # Construct a mapping from chain integer indices to chain ID strings.\n    chain_ids = {}\n    # We count unknown residues as protein residues.\n    for entity_id in np.unique(chain_index):  # np.unique gives sorted output.\n        chain_ids[entity_id] = _int_id_to_str_id(entity_id + 1)\n\n    mmcif_dict = collections.defaultdict(list)",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def to_mmcif(",
            "lineNumber": 382,
            "isSignature": true
          },
          {
            "text": "    prot: Protein,",
            "lineNumber": 383,
            "isSignature": true
          },
          {
            "text": "    file_id: str,",
            "lineNumber": 384,
            "isSignature": true
          },
          {
            "text": "    model_type: str,",
            "lineNumber": 385,
            "isSignature": true
          },
          {
            "text": ") -&gt; str:",
            "lineNumber": 386,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Converts a &#96;Protein&#96; instance to an mmCIF string.",
            "lineNumber": 387
          },
          {
            "lineNumber": 388
          },
          {
            "text": "    WARNING 1: The _entity_poly_seq is filled with unknown (UNK) residues for any",
            "lineNumber": 389
          },
          {
            "text": "      missing residue indices in the range from min(1, min(residue_index)) to",
            "lineNumber": 390
          },
          {
            "text": "      max(residue_index). E.g. for a protein object with positions for residues",
            "lineNumber": 391
          },
          {
            "text": "      2 (MET), 3 (LYS), 6 (GLY), this method would set the _entity_poly_seq to:",
            "lineNumber": 392
          },
          {
            "text": "      1 UNK",
            "lineNumber": 393
          },
          {
            "text": "      2 MET",
            "lineNumber": 394
          },
          {
            "text": "      3 LYS",
            "lineNumber": 395
          },
          {
            "text": "      4 UNK",
            "lineNumber": 396
          },
          {
            "text": "      5 UNK",
            "lineNumber": 397
          },
          {
            "text": "      6 GLY",
            "lineNumber": 398
          },
          {
            "text": "      This is done to preserve the residue numbering.",
            "lineNumber": 399
          },
          {
            "lineNumber": 400
          },
          {
            "text": "    WARNING 2: Converting ground truth mmCIF file to Protein and then back to",
            "lineNumber": 401
          },
          {
            "text": "      mmCIF using this method will convert all non-standard residue types to UNK.",
            "lineNumber": 402
          },
          {
            "text": "      If you need this behaviour, you need to store more mmCIF metadata in the",
            "lineNumber": 403
          },
          {
            "text": "      Protein object (e.g. all fields except for the _atom_site loop).",
            "lineNumber": 404
          },
          {
            "lineNumber": 405
          },
          {
            "text": "    WARNING 3: Converting ground truth mmCIF file to Protein and then back to",
            "lineNumber": 406
          },
          {
            "text": "      mmCIF using this method will not retain the original chain indices.",
            "lineNumber": 407
          },
          {
            "lineNumber": 408
          },
          {
            "text": "    WARNING 4: In case of multiple identical chains, they are assigned different",
            "lineNumber": 409
          },
          {
            "text": "      &#96;_atom_site.label_entity_id&#96; values.",
            "lineNumber": 410
          },
          {
            "lineNumber": 411
          },
          {
            "text": "    Args:",
            "lineNumber": 412
          },
          {
            "text": "      prot: A protein to convert to mmCIF string.",
            "lineNumber": 413
          },
          {
            "text": "      file_id: The file ID (usually the PDB ID) to be used in the mmCIF.",
            "lineNumber": 414
          },
          {
            "text": "      model_type: 'Multimer' or 'Monomer'.",
            "lineNumber": 415
          },
          {
            "lineNumber": 416
          },
          {
            "text": "    Returns:",
            "lineNumber": 417
          },
          {
            "text": "      A valid mmCIF string.",
            "lineNumber": 418
          },
          {
            "lineNumber": 419
          },
          {
            "text": "    Raises:",
            "lineNumber": 420
          },
          {
            "text": "      ValueError: If aminoacid types array contains entries with too many protein",
            "lineNumber": 421
          },
          {
            "text": "      types.",
            "lineNumber": 422
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 423
          },
          {
            "text": "    atom_mask = prot.atom_mask",
            "lineNumber": 424
          },
          {
            "text": "    aatype = prot.aatype",
            "lineNumber": 425
          },
          {
            "text": "    atom_positions = prot.atom_positions",
            "lineNumber": 426
          },
          {
            "text": "    residue_index = prot.residue_index.astype(np.int32)",
            "lineNumber": 427
          },
          {
            "text": "    chain_index = prot.chain_index.astype(np.int32)",
            "lineNumber": 428
          },
          {
            "text": "    b_factors = prot.b_factors",
            "lineNumber": 429
          },
          {
            "lineNumber": 430
          },
          {
            "text": "    # Construct a mapping from chain integer indices to chain ID strings.",
            "lineNumber": 431
          },
          {
            "text": "    chain_ids = {}",
            "lineNumber": 432
          },
          {
            "text": "    # We count unknown residues as protein residues.",
            "lineNumber": 433
          },
          {
            "text": "    for entity_id in np.unique(chain_index):  # np.unique gives sorted output.",
            "lineNumber": 434
          },
          {
            "text": "        chain_ids[entity_id] = _int_id_to_str_id(entity_id + 1)",
            "lineNumber": 435
          },
          {
            "lineNumber": 436
          },
          {
            "text": "    mmcif_dict = collections.defaultdict(list)",
            "lineNumber": 437
          }
        ]
      },
      "score": 0.25587621331214905
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/sasa.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 212
          }
        },
        "contents": "import logging\nfrom pathlib import Path\nfrom typing import List, Dict, Optional, Tuple, Callable\nfrom tempfile import NamedTemporaryFile\nimport os\nimport random\nimport re\n\nimport numpy as np\nimport biotite.structure as struc\nimport biotite.structure.io.pdb as pdb\nfrom biotite.structure import sasa\n\nfrom mber.utils.regions import RegionSpec\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\n\nclass SASAHotspotFinder:\n    def __init__(self, \n                 pdb_file: str,\n                 sasa_threshold: float = 50.0,\n                 min_distance: int = 0,\n                 regions: Optional[List[RegionSpec]] = None):\n        \"\"\"\n        Initialize the SASA hotspot finder.\n        \"\"\"\n        self.pdb_file = Path(pdb_file)\n        self.sasa_threshold = sasa_threshold\n        self.min_distance = min_distance\n        self.regions = regions if regions else []\n        \n        # Load structure using Biotite\n        pdb_file_obj = pdb.PDBFile.read(pdb_file)\n        self.atom_array = pdb.get_structure(pdb_file_obj, model=1)\n        \n        # Calculate SASA\n        try:\n            self.atom_sasa = sasa(\n                self.atom_array,\n                probe_radius=1.4,\n                point_number=100\n            )\n        except Exception as e:\n            logging.error(f\"Error calculating SASA: {e}\")\n            # Create a fallback array of zeros\n            self.atom_sasa = np.zeros(len(self.atom_array))\n        \n        # Process residues\n        self.residues = self._process_residues()\n    \n    def _process_residues(self):\n        \"\"\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "import logging",
            "lineNumber": 1
          },
          {
            "text": "from pathlib import Path",
            "lineNumber": 2
          },
          {
            "text": "from typing import List, Dict, Optional, Tuple, Callable",
            "lineNumber": 3
          },
          {
            "text": "from tempfile import NamedTemporaryFile",
            "lineNumber": 4
          },
          {
            "text": "import os",
            "lineNumber": 5
          },
          {
            "text": "import random",
            "lineNumber": 6
          },
          {
            "text": "import re",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "text": "import numpy as np",
            "lineNumber": 9
          },
          {
            "text": "import biotite.structure as struc",
            "lineNumber": 10
          },
          {
            "text": "import biotite.structure.io.pdb as pdb",
            "lineNumber": 11
          },
          {
            "text": "from biotite.structure import sasa",
            "lineNumber": 12
          },
          {
            "lineNumber": 13
          },
          {
            "text": "from mber.utils.regions import RegionSpec",
            "lineNumber": 14
          },
          {
            "lineNumber": 15
          },
          {
            "text": "# Set up logging",
            "lineNumber": 16
          },
          {
            "text": "logging.basicConfig(",
            "lineNumber": 17
          },
          {
            "text": "    level=logging.INFO,",
            "lineNumber": 18
          },
          {
            "text": "    format='%(asctime)s - %(levelname)s - %(message)s'",
            "lineNumber": 19
          },
          {
            "text": ")",
            "lineNumber": 20
          },
          {
            "lineNumber": 21
          },
          {
            "text": "class SASAHotspotFinder:",
            "lineNumber": 22,
            "isSignature": true
          },
          {
            "text": "    def __init__(self, ",
            "lineNumber": 23
          },
          {
            "text": "                 pdb_file: str,",
            "lineNumber": 24
          },
          {
            "text": "                 sasa_threshold: float = 50.0,",
            "lineNumber": 25
          },
          {
            "text": "                 min_distance: int = 0,",
            "lineNumber": 26
          },
          {
            "text": "                 regions: Optional[List[RegionSpec]] = None):",
            "lineNumber": 27
          },
          {
            "text": "        \"\"\"",
            "lineNumber": 28
          },
          {
            "text": "        Initialize the SASA hotspot finder.",
            "lineNumber": 29
          },
          {
            "text": "        \"\"\"",
            "lineNumber": 30
          },
          {
            "text": "        self.pdb_file = Path(pdb_file)",
            "lineNumber": 31
          },
          {
            "text": "        self.sasa_threshold = sasa_threshold",
            "lineNumber": 32
          },
          {
            "text": "        self.min_distance = min_distance",
            "lineNumber": 33
          },
          {
            "text": "        self.regions = regions if regions else []",
            "lineNumber": 34
          },
          {
            "text": "        ",
            "lineNumber": 35
          },
          {
            "text": "        # Load structure using Biotite",
            "lineNumber": 36
          },
          {
            "text": "        pdb_file_obj = pdb.PDBFile.read(pdb_file)",
            "lineNumber": 37
          },
          {
            "text": "        self.atom_array = pdb.get_structure(pdb_file_obj, model=1)",
            "lineNumber": 38
          },
          {
            "text": "        ",
            "lineNumber": 39
          },
          {
            "text": "        # Calculate SASA",
            "lineNumber": 40
          },
          {
            "text": "        try:",
            "lineNumber": 41
          },
          {
            "text": "            self.atom_sasa = sasa(",
            "lineNumber": 42
          },
          {
            "text": "                self.atom_array,",
            "lineNumber": 43
          },
          {
            "text": "                probe_radius=1.4,",
            "lineNumber": 44
          },
          {
            "text": "                point_number=100",
            "lineNumber": 45
          },
          {
            "text": "            )",
            "lineNumber": 46
          },
          {
            "text": "        except Exception as e:",
            "lineNumber": 47
          },
          {
            "text": "            logging.error(f\"Error calculating SASA: {e}\")",
            "lineNumber": 48
          },
          {
            "text": "            # Create a fallback array of zeros",
            "lineNumber": 49
          },
          {
            "text": "            self.atom_sasa = np.zeros(len(self.atom_array))",
            "lineNumber": 50
          },
          {
            "text": "        ",
            "lineNumber": 51
          },
          {
            "text": "        # Process residues",
            "lineNumber": 52
          },
          {
            "text": "        self.residues = self._process_residues()",
            "lineNumber": 53
          },
          {
            "text": "    ",
            "lineNumber": 54
          },
          {
            "text": "    def _process_residues(self):",
            "lineNumber": 55
          },
          {
            "text": "        \"\"\"",
            "lineNumber": 56
          }
        ]
      },
      "score": 0.25050029158592224
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/pipeline.py",
        "range": {
          "startPosition": {
            "line": 116,
            "column": 17
          },
          "endPosition": {
            "line": 267
          }
        },
        "contents": "class DataPipeline:\n    \"\"\"Runs the alignment tools and assembles the input features.\"\"\"\n\n    def __init__(\n        self,\n        jackhmmer_binary_path: str,\n        hhblits_binary_path: str,\n        uniref90_database_path: str,\n        mgnify_database_path: str,\n        bfd_database_path: Optional[str],\n        uniref30_database_path: Optional[str],\n        small_bfd_database_path: Optional[str],\n        template_searcher: TemplateSearcher,\n        template_featurizer: templates.TemplateHitFeaturizer,\n        use_small_bfd: bool,\n        mgnify_max_hits: int = 501,\n        uniref_max_hits: int = 10000,\n        use_precomputed_msas: bool = False,\n    ):\n        \"\"\"Initializes the data pipeline.\"\"\"\n        self._use_small_bfd = use_small_bfd\n        self.jackhmmer_uniref90_runner = jackhmmer.Jackhmmer(\n            binary_path=jackhmmer_binary_path, database_path=uniref90_database_path\n        )\n        if use_small_bfd:\n            self.jackhmmer_small_bfd_runner = jackhmmer.Jackhmmer(\n                binary_path=jackhmmer_binary_path, database_path=small_bfd_database_path\n            )\n        else:\n            self.hhblits_bfd_uniref_runner = hhblits.HHBlits(\n                binary_path=hhblits_binary_path,\n                databases=[bfd_database_path, uniref30_database_path],\n            )\n        self.jackhmmer_mgnify_runner = jackhmmer.Jackhmmer(\n            binary_path=jackhmmer_binary_path, database_path=mgnify_database_path\n        )\n        self.template_searcher = template_searcher\n        self.template_featurizer = template_featurizer\n        self.mgnify_max_hits = mgnify_max_hits\n        self.uniref_max_hits = uniref_max_hits\n        self.use_precomputed_msas = use_precomputed_msas\n\n    def process(self, input_fasta_path: str, msa_output_dir: str) -&gt; FeatureDict:\n        ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "class DataPipeline:",
            "lineNumber": 120,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Runs the alignment tools and assembles the input features.\"\"\"",
            "lineNumber": 121
          },
          {
            "lineNumber": 122
          },
          {
            "text": "    def __init__(",
            "lineNumber": 123
          },
          {
            "text": "        self,",
            "lineNumber": 124
          },
          {
            "text": "        jackhmmer_binary_path: str,",
            "lineNumber": 125
          },
          {
            "text": "        hhblits_binary_path: str,",
            "lineNumber": 126
          },
          {
            "text": "        uniref90_database_path: str,",
            "lineNumber": 127
          },
          {
            "text": "        mgnify_database_path: str,",
            "lineNumber": 128
          },
          {
            "text": "        bfd_database_path: Optional[str],",
            "lineNumber": 129
          },
          {
            "text": "        uniref30_database_path: Optional[str],",
            "lineNumber": 130
          },
          {
            "text": "        small_bfd_database_path: Optional[str],",
            "lineNumber": 131
          },
          {
            "text": "        template_searcher: TemplateSearcher,",
            "lineNumber": 132
          },
          {
            "text": "        template_featurizer: templates.TemplateHitFeaturizer,",
            "lineNumber": 133
          },
          {
            "text": "        use_small_bfd: bool,",
            "lineNumber": 134
          },
          {
            "text": "        mgnify_max_hits: int = 501,",
            "lineNumber": 135
          },
          {
            "text": "        uniref_max_hits: int = 10000,",
            "lineNumber": 136
          },
          {
            "text": "        use_precomputed_msas: bool = False,",
            "lineNumber": 137
          },
          {
            "text": "    ):",
            "lineNumber": 138
          },
          {
            "text": "        \"\"\"Initializes the data pipeline.\"\"\"",
            "lineNumber": 139
          },
          {
            "text": "        self._use_small_bfd = use_small_bfd",
            "lineNumber": 140
          },
          {
            "text": "        self.jackhmmer_uniref90_runner = jackhmmer.Jackhmmer(",
            "lineNumber": 141
          },
          {
            "text": "            binary_path=jackhmmer_binary_path, database_path=uniref90_database_path",
            "lineNumber": 142
          },
          {
            "text": "        )",
            "lineNumber": 143
          },
          {
            "text": "        if use_small_bfd:",
            "lineNumber": 144
          },
          {
            "text": "            self.jackhmmer_small_bfd_runner = jackhmmer.Jackhmmer(",
            "lineNumber": 145
          },
          {
            "text": "                binary_path=jackhmmer_binary_path, database_path=small_bfd_database_path",
            "lineNumber": 146
          },
          {
            "text": "            )",
            "lineNumber": 147
          },
          {
            "text": "        else:",
            "lineNumber": 148
          },
          {
            "text": "            self.hhblits_bfd_uniref_runner = hhblits.HHBlits(",
            "lineNumber": 149
          },
          {
            "text": "                binary_path=hhblits_binary_path,",
            "lineNumber": 150
          },
          {
            "text": "                databases=[bfd_database_path, uniref30_database_path],",
            "lineNumber": 151
          },
          {
            "text": "            )",
            "lineNumber": 152
          },
          {
            "text": "        self.jackhmmer_mgnify_runner = jackhmmer.Jackhmmer(",
            "lineNumber": 153
          },
          {
            "text": "            binary_path=jackhmmer_binary_path, database_path=mgnify_database_path",
            "lineNumber": 154
          },
          {
            "text": "        )",
            "lineNumber": 155
          },
          {
            "text": "        self.template_searcher = template_searcher",
            "lineNumber": 156
          },
          {
            "text": "        self.template_featurizer = template_featurizer",
            "lineNumber": 157
          },
          {
            "text": "        self.mgnify_max_hits = mgnify_max_hits",
            "lineNumber": 158
          },
          {
            "text": "        self.uniref_max_hits = uniref_max_hits",
            "lineNumber": 159
          },
          {
            "text": "        self.use_precomputed_msas = use_precomputed_msas",
            "lineNumber": 160
          },
          {
            "lineNumber": 161
          },
          {
            "text": "    def process(self, input_fasta_path: str, msa_output_dir: str) -&gt; FeatureDict:",
            "lineNumber": 162
          },
          {
            "text": "        ",
            "lineNumber": 163
          }
        ]
      },
      "score": 0.24812734127044678
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/pipeline.py",
        "range": {
          "startPosition": {
            "line": 119
          },
          "endPosition": {
            "line": 267
          }
        },
        "contents": "class DataPipeline:\n\n\n    def process(self, input_fasta_path: str, msa_output_dir: str) -&gt; FeatureDict:\n        \"\"\"Runs alignment tools on the input sequence and creates features.\"\"\"\n        with open(input_fasta_path) as f:\n            input_fasta_str = f.read()\n        input_seqs, input_descs = parsers.parse_fasta(input_fasta_str)\n        if len(input_seqs) != 1:\n            raise ValueError(\n                f\"More than one input sequence found in {input_fasta_path}.\"\n            )\n        input_sequence = input_seqs[0]\n        input_description = input_descs[0]\n        num_res = len(input_sequence)\n\n        uniref90_out_path = os.path.join(msa_output_dir, \"uniref90_hits.sto\")\n        jackhmmer_uniref90_result = run_msa_tool(\n            msa_runner=self.jackhmmer_uniref90_runner,\n            input_fasta_path=input_fasta_path,\n            msa_out_path=uniref90_out_path,\n            msa_format=\"sto\",\n            use_precomputed_msas=self.use_precomputed_msas,\n            max_sto_sequences=self.uniref_max_hits,\n        )\n        mgnify_out_path = os.path.join(msa_output_dir, \"mgnify_hits.sto\")\n        jackhmmer_mgnify_result = run_msa_tool(\n            msa_runner=self.jackhmmer_mgnify_runner,\n            input_fasta_path=input_fasta_path,\n            msa_out_path=mgnify_out_path,\n            msa_format=\"sto\",\n            use_precomputed_msas=self.use_precomputed_msas,\n            max_sto_sequences=self.mgnify_max_hits,\n        )\n\n        msa_for_templates = jackhmmer_uniref90_result[\"sto\"]\n        msa_for_templates = parsers.deduplicate_stockholm_msa(msa_for_templates)\n        msa_for_templates = parsers.remove_empty_columns_from_stockholm_msa(\n            msa_for_templates\n        )\n\n        if self.template_searcher.input_format == \"sto\":",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 120,
                "column": 1
              },
              "endPosition": {
                "line": 121,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class DataPipeline:",
            "lineNumber": 120,
            "isSignature": true
          },
          {
            "lineNumber": 160
          },
          {
            "lineNumber": 161
          },
          {
            "text": "    def process(self, input_fasta_path: str, msa_output_dir: str) -&gt; FeatureDict:",
            "lineNumber": 162
          },
          {
            "text": "        \"\"\"Runs alignment tools on the input sequence and creates features.\"\"\"",
            "lineNumber": 163
          },
          {
            "text": "        with open(input_fasta_path) as f:",
            "lineNumber": 164
          },
          {
            "text": "            input_fasta_str = f.read()",
            "lineNumber": 165
          },
          {
            "text": "        input_seqs, input_descs = parsers.parse_fasta(input_fasta_str)",
            "lineNumber": 166
          },
          {
            "text": "        if len(input_seqs) != 1:",
            "lineNumber": 167
          },
          {
            "text": "            raise ValueError(",
            "lineNumber": 168
          },
          {
            "text": "                f\"More than one input sequence found in {input_fasta_path}.\"",
            "lineNumber": 169
          },
          {
            "text": "            )",
            "lineNumber": 170
          },
          {
            "text": "        input_sequence = input_seqs[0]",
            "lineNumber": 171
          },
          {
            "text": "        input_description = input_descs[0]",
            "lineNumber": 172
          },
          {
            "text": "        num_res = len(input_sequence)",
            "lineNumber": 173
          },
          {
            "lineNumber": 174
          },
          {
            "text": "        uniref90_out_path = os.path.join(msa_output_dir, \"uniref90_hits.sto\")",
            "lineNumber": 175
          },
          {
            "text": "        jackhmmer_uniref90_result = run_msa_tool(",
            "lineNumber": 176
          },
          {
            "text": "            msa_runner=self.jackhmmer_uniref90_runner,",
            "lineNumber": 177
          },
          {
            "text": "            input_fasta_path=input_fasta_path,",
            "lineNumber": 178
          },
          {
            "text": "            msa_out_path=uniref90_out_path,",
            "lineNumber": 179
          },
          {
            "text": "            msa_format=\"sto\",",
            "lineNumber": 180
          },
          {
            "text": "            use_precomputed_msas=self.use_precomputed_msas,",
            "lineNumber": 181
          },
          {
            "text": "            max_sto_sequences=self.uniref_max_hits,",
            "lineNumber": 182
          },
          {
            "text": "        )",
            "lineNumber": 183
          },
          {
            "text": "        mgnify_out_path = os.path.join(msa_output_dir, \"mgnify_hits.sto\")",
            "lineNumber": 184
          },
          {
            "text": "        jackhmmer_mgnify_result = run_msa_tool(",
            "lineNumber": 185
          },
          {
            "text": "            msa_runner=self.jackhmmer_mgnify_runner,",
            "lineNumber": 186
          },
          {
            "text": "            input_fasta_path=input_fasta_path,",
            "lineNumber": 187
          },
          {
            "text": "            msa_out_path=mgnify_out_path,",
            "lineNumber": 188
          },
          {
            "text": "            msa_format=\"sto\",",
            "lineNumber": 189
          },
          {
            "text": "            use_precomputed_msas=self.use_precomputed_msas,",
            "lineNumber": 190
          },
          {
            "text": "            max_sto_sequences=self.mgnify_max_hits,",
            "lineNumber": 191
          },
          {
            "text": "        )",
            "lineNumber": 192
          },
          {
            "lineNumber": 193
          },
          {
            "text": "        msa_for_templates = jackhmmer_uniref90_result[\"sto\"]",
            "lineNumber": 194
          },
          {
            "text": "        msa_for_templates = parsers.deduplicate_stockholm_msa(msa_for_templates)",
            "lineNumber": 195
          },
          {
            "text": "        msa_for_templates = parsers.remove_empty_columns_from_stockholm_msa(",
            "lineNumber": 196
          },
          {
            "text": "            msa_for_templates",
            "lineNumber": 197
          },
          {
            "text": "        )",
            "lineNumber": 198
          },
          {
            "lineNumber": 199
          },
          {
            "text": "        if self.template_searcher.input_format == \"sto\":",
            "lineNumber": 200
          }
        ]
      },
      "score": 0.24792814254760742
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/utils/plm_utils.py",
        "range": {
          "startPosition": {},
          "endPosition": {
            "line": 59
          }
        },
        "contents": "from typing import Optional, List, Tuple, Dict, Union\nimport numpy as np\n\nfrom colabdesign.shared.model import aa_order\n\nfrom mber.models.plm import ProteinLanguageModel\nfrom mber.core.data.state import TemplateData\n\n\ndef generate_sequence_from_mask(\n    model: ProteinLanguageModel,\n    masked_sequence: str,\n    temperature: float = 0.1,\n    num_samples: int = 1,\n) -&gt; str:\n    \"\"\"Generate full sequence from masked sequence using a protein language model.\"\"\"\n    # Sample from model to fill masked positions\n    sequences = model.sample_sequences(\n        masked_sequence, num_samples=num_samples, temperature=temperature\n    )\n\n    # Return first sequence\n    return sequences[0]\n\n\ndef generate_bias_from_mask(\n    model: ProteinLanguageModel,\n    template_data: TemplateData,\n    omit_aas: str = None,\n    temperature=1.0,\n) -&gt; np.ndarray:\n    ",
        "signatures": {},
        "detailedLines": [
          {
            "text": "from typing import Optional, List, Tuple, Dict, Union",
            "lineNumber": 1
          },
          {
            "text": "import numpy as np",
            "lineNumber": 2
          },
          {
            "lineNumber": 3
          },
          {
            "text": "from colabdesign.shared.model import aa_order",
            "lineNumber": 4
          },
          {
            "lineNumber": 5
          },
          {
            "text": "from mber.models.plm import ProteinLanguageModel",
            "lineNumber": 6
          },
          {
            "text": "from mber.core.data.state import TemplateData",
            "lineNumber": 7
          },
          {
            "lineNumber": 8
          },
          {
            "lineNumber": 9
          },
          {
            "text": "def generate_sequence_from_mask(",
            "lineNumber": 10,
            "isSignature": true
          },
          {
            "text": "    model: ProteinLanguageModel,",
            "lineNumber": 11,
            "isSignature": true
          },
          {
            "text": "    masked_sequence: str,",
            "lineNumber": 12,
            "isSignature": true
          },
          {
            "text": "    temperature: float = 0.1,",
            "lineNumber": 13,
            "isSignature": true
          },
          {
            "text": "    num_samples: int = 1,",
            "lineNumber": 14,
            "isSignature": true
          },
          {
            "text": ") -&gt; str:",
            "lineNumber": 15,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Generate full sequence from masked sequence using a protein language model.\"\"\"",
            "lineNumber": 16
          },
          {
            "text": "    # Sample from model to fill masked positions",
            "lineNumber": 17
          },
          {
            "text": "    sequences = model.sample_sequences(",
            "lineNumber": 18
          },
          {
            "text": "        masked_sequence, num_samples=num_samples, temperature=temperature",
            "lineNumber": 19
          },
          {
            "text": "    )",
            "lineNumber": 20
          },
          {
            "lineNumber": 21
          },
          {
            "text": "    # Return first sequence",
            "lineNumber": 22
          },
          {
            "text": "    return sequences[0]",
            "lineNumber": 23,
            "isSignature": true
          },
          {
            "lineNumber": 24
          },
          {
            "lineNumber": 25
          },
          {
            "text": "def generate_bias_from_mask(",
            "lineNumber": 26,
            "isSignature": true
          },
          {
            "text": "    model: ProteinLanguageModel,",
            "lineNumber": 27,
            "isSignature": true
          },
          {
            "text": "    template_data: TemplateData,",
            "lineNumber": 28,
            "isSignature": true
          },
          {
            "text": "    omit_aas: str = None,",
            "lineNumber": 29,
            "isSignature": true
          },
          {
            "text": "    temperature=1.0,",
            "lineNumber": 30,
            "isSignature": true
          },
          {
            "text": ") -&gt; np.ndarray:",
            "lineNumber": 31,
            "isSignature": true
          },
          {
            "text": "    ",
            "lineNumber": 32
          }
        ]
      },
      "score": 0.24627184867858887
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/data/pipeline_multimer.py",
        "range": {
          "startPosition": {
            "line": 181
          },
          "endPosition": {
            "line": 308
          }
        },
        "contents": "class DataPipeline:\ndef _process_single_chain(\n        self,\n        chain_id: str,\n        sequence: str,\n        description: str,\n        msa_output_dir: str,\n        is_homomer_or_monomer: bool,\n    ) -&gt; pipeline.FeatureDict:\n\n        return chain_features\n\n    def _all_seq_msa_features(self, input_fasta_path, msa_output_dir):\n        \"\"\"Get MSA features for unclustered uniprot, for pairing.\"\"\"\n        out_path = os.path.join(msa_output_dir, \"uniprot_hits.sto\")\n        result = pipeline.run_msa_tool(\n            self._uniprot_msa_runner,\n            input_fasta_path,\n            out_path,\n            \"sto\",\n            self.use_precomputed_msas,\n        )\n        msa = parsers.parse_stockholm(result[\"sto\"])\n        msa = msa.truncate(max_seqs=self._max_uniprot_hits)\n        all_seq_features = pipeline.make_msa_features([msa])\n        valid_feats = msa_pairing.MSA_FEATURES + (\"msa_species_identifiers\",)\n        feats = {\n            f\"{k}_all_seq\": v for k, v in all_seq_features.items() if k in valid_feats\n        }\n        return feats\n\n    def process(\n        self, input_fasta_path: str, msa_output_dir: str\n    ) -&gt; pipeline.FeatureDict:\n        \"\"\"Runs alignment tools on the input sequences and creates features.\"\"\"\n        with open(input_fasta_path) as f:\n            input_fasta_str = f.read()\n        input_seqs, input_descs = parsers.parse_fasta(input_fasta_str)\n\n        chain_id_map = _make_chain_id_map(\n            sequences=input_seqs, descriptions=input_descs\n        )\n        chain_id_map_path = os.path.join(msa_output_dir, \"chain_id_map.json\")\n        with open(chain_id_map_path, \"w\") as f:\n            chain_id_map_dict = {\n                chain_id: dataclasses.asdict(fasta_chain)\n                for chain_id, fasta_chain in chain_id_map.items()\n            }\n            json.dump(chain_id_map_dict, f, indent=4, sort_keys=True)\n\n        all_chain_features = {}\n        sequence_features = {}\n        is_homomer_or_monomer = len(set(input_seqs)) == 1\n        for chain_id, fasta_chain in chain_id_map.items():\n            if fasta_chain.sequence in sequence_features:",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 182,
                "column": 1
              },
              "endPosition": {
                "line": 183,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class DataPipeline:",
            "lineNumber": 182,
            "isSignature": true
          },
          {
            "text": "def _process_single_chain(",
            "lineNumber": 211
          },
          {
            "text": "        self,",
            "lineNumber": 212
          },
          {
            "text": "        chain_id: str,",
            "lineNumber": 213
          },
          {
            "text": "        sequence: str,",
            "lineNumber": 214
          },
          {
            "text": "        description: str,",
            "lineNumber": 215
          },
          {
            "text": "        msa_output_dir: str,",
            "lineNumber": 216
          },
          {
            "text": "        is_homomer_or_monomer: bool,",
            "lineNumber": 217
          },
          {
            "text": "    ) -&gt; pipeline.FeatureDict:",
            "lineNumber": 218
          },
          {
            "lineNumber": 238
          },
          {
            "text": "        return chain_features",
            "lineNumber": 239
          },
          {
            "lineNumber": 240
          },
          {
            "text": "    def _all_seq_msa_features(self, input_fasta_path, msa_output_dir):",
            "lineNumber": 241
          },
          {
            "text": "        \"\"\"Get MSA features for unclustered uniprot, for pairing.\"\"\"",
            "lineNumber": 242
          },
          {
            "text": "        out_path = os.path.join(msa_output_dir, \"uniprot_hits.sto\")",
            "lineNumber": 243
          },
          {
            "text": "        result = pipeline.run_msa_tool(",
            "lineNumber": 244
          },
          {
            "text": "            self._uniprot_msa_runner,",
            "lineNumber": 245
          },
          {
            "text": "            input_fasta_path,",
            "lineNumber": 246
          },
          {
            "text": "            out_path,",
            "lineNumber": 247
          },
          {
            "text": "            \"sto\",",
            "lineNumber": 248
          },
          {
            "text": "            self.use_precomputed_msas,",
            "lineNumber": 249
          },
          {
            "text": "        )",
            "lineNumber": 250
          },
          {
            "text": "        msa = parsers.parse_stockholm(result[\"sto\"])",
            "lineNumber": 251
          },
          {
            "text": "        msa = msa.truncate(max_seqs=self._max_uniprot_hits)",
            "lineNumber": 252
          },
          {
            "text": "        all_seq_features = pipeline.make_msa_features([msa])",
            "lineNumber": 253
          },
          {
            "text": "        valid_feats = msa_pairing.MSA_FEATURES + (\"msa_species_identifiers\",)",
            "lineNumber": 254
          },
          {
            "text": "        feats = {",
            "lineNumber": 255
          },
          {
            "text": "            f\"{k}_all_seq\": v for k, v in all_seq_features.items() if k in valid_feats",
            "lineNumber": 256
          },
          {
            "text": "        }",
            "lineNumber": 257
          },
          {
            "text": "        return feats",
            "lineNumber": 258
          },
          {
            "lineNumber": 259
          },
          {
            "text": "    def process(",
            "lineNumber": 260
          },
          {
            "text": "        self, input_fasta_path: str, msa_output_dir: str",
            "lineNumber": 261
          },
          {
            "text": "    ) -&gt; pipeline.FeatureDict:",
            "lineNumber": 262
          },
          {
            "text": "        \"\"\"Runs alignment tools on the input sequences and creates features.\"\"\"",
            "lineNumber": 263
          },
          {
            "text": "        with open(input_fasta_path) as f:",
            "lineNumber": 264
          },
          {
            "text": "            input_fasta_str = f.read()",
            "lineNumber": 265
          },
          {
            "text": "        input_seqs, input_descs = parsers.parse_fasta(input_fasta_str)",
            "lineNumber": 266
          },
          {
            "lineNumber": 267
          },
          {
            "text": "        chain_id_map = _make_chain_id_map(",
            "lineNumber": 268
          },
          {
            "text": "            sequences=input_seqs, descriptions=input_descs",
            "lineNumber": 269
          },
          {
            "text": "        )",
            "lineNumber": 270
          },
          {
            "text": "        chain_id_map_path = os.path.join(msa_output_dir, \"chain_id_map.json\")",
            "lineNumber": 271
          },
          {
            "text": "        with open(chain_id_map_path, \"w\") as f:",
            "lineNumber": 272
          },
          {
            "text": "            chain_id_map_dict = {",
            "lineNumber": 273
          },
          {
            "text": "                chain_id: dataclasses.asdict(fasta_chain)",
            "lineNumber": 274
          },
          {
            "text": "                for chain_id, fasta_chain in chain_id_map.items()",
            "lineNumber": 275
          },
          {
            "text": "            }",
            "lineNumber": 276
          },
          {
            "text": "            json.dump(chain_id_map_dict, f, indent=4, sort_keys=True)",
            "lineNumber": 277
          },
          {
            "lineNumber": 278
          },
          {
            "text": "        all_chain_features = {}",
            "lineNumber": 279
          },
          {
            "text": "        sequence_features = {}",
            "lineNumber": 280
          },
          {
            "text": "        is_homomer_or_monomer = len(set(input_seqs)) == 1",
            "lineNumber": 281
          },
          {
            "text": "        for chain_id, fasta_chain in chain_id_map.items():",
            "lineNumber": 282
          },
          {
            "text": "            if fasta_chain.sequence in sequence_features:",
            "lineNumber": 283
          }
        ]
      },
      "score": 0.24487219750881195
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/common/protein.py",
        "range": {
          "startPosition": {
            "line": 381
          },
          "endPosition": {
            "line": 515
          }
        },
        "contents": "def to_mmcif(\n    prot: Protein,\n    file_id: str,\n    model_type: str,\n) -&gt; str:\n\n\n    mmcif_dict = collections.defaultdict(list)\n\n    mmcif_dict[\"data_\"] = file_id.upper()\n    mmcif_dict[\"_entry.id\"] = file_id.upper()\n\n    label_asym_id_to_entity_id = {}\n    # Entity and chain information.\n    for entity_id, chain_id in chain_ids.items():\n        # Add all chain information to the _struct_asym table.\n        label_asym_id_to_entity_id[str(chain_id)] = str(entity_id)\n        mmcif_dict[\"_struct_asym.id\"].append(chain_id)\n        mmcif_dict[\"_struct_asym.entity_id\"].append(str(entity_id))\n        # Add information about the entity to the _entity_poly table.\n        mmcif_dict[\"_entity_poly.entity_id\"].append(str(entity_id))\n        mmcif_dict[\"_entity_poly.type\"].append(residue_constants.PROTEIN_CHAIN)\n        mmcif_dict[\"_entity_poly.pdbx_strand_id\"].append(chain_id)\n        # Generate the _entity table.\n        mmcif_dict[\"_entity.id\"].append(str(entity_id))\n        mmcif_dict[\"_entity.type\"].append(residue_constants.POLYMER_CHAIN)\n\n    # Add the residues to the _entity_poly_seq table.\n    for entity_id, (res_ids, aas) in _get_entity_poly_seq(\n        aatype, residue_index, chain_index\n    ).items():\n        for res_id, aa in zip(res_ids, aas):\n            mmcif_dict[\"_entity_poly_seq.entity_id\"].append(str(entity_id))\n            mmcif_dict[\"_entity_poly_seq.num\"].append(str(res_id))\n            mmcif_dict[\"_entity_poly_seq.mon_id\"].append(residue_constants.resnames[aa])\n\n    # Populate the chem comp table.\n    for chem_type, chem_comp in _CHEM_COMP.items():\n        for chem_id, chem_name in chem_comp:\n            mmcif_dict[\"_chem_comp.id\"].append(chem_id)\n            mmcif_dict[\"_chem_comp.type\"].append(chem_type)\n            mmcif_dict[\"_chem_comp.name\"].append(chem_name)\n\n    # Add all atom sites.\n    atom_index = 1\n    for i in range(aatype.shape[0]):\n        res_name_3 =",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 382,
                "column": 1
              },
              "endPosition": {
                "line": 387,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "def to_mmcif(",
            "lineNumber": 382,
            "isSignature": true
          },
          {
            "text": "    prot: Protein,",
            "lineNumber": 383,
            "isSignature": true
          },
          {
            "text": "    file_id: str,",
            "lineNumber": 384,
            "isSignature": true
          },
          {
            "text": "    model_type: str,",
            "lineNumber": 385,
            "isSignature": true
          },
          {
            "text": ") -&gt; str:",
            "lineNumber": 386,
            "isSignature": true
          },
          {
            "lineNumber": 435
          },
          {
            "lineNumber": 436
          },
          {
            "text": "    mmcif_dict = collections.defaultdict(list)",
            "lineNumber": 437
          },
          {
            "lineNumber": 438
          },
          {
            "text": "    mmcif_dict[\"data_\"] = file_id.upper()",
            "lineNumber": 439
          },
          {
            "text": "    mmcif_dict[\"_entry.id\"] = file_id.upper()",
            "lineNumber": 440
          },
          {
            "lineNumber": 441
          },
          {
            "text": "    label_asym_id_to_entity_id = {}",
            "lineNumber": 442
          },
          {
            "text": "    # Entity and chain information.",
            "lineNumber": 443
          },
          {
            "text": "    for entity_id, chain_id in chain_ids.items():",
            "lineNumber": 444
          },
          {
            "text": "        # Add all chain information to the _struct_asym table.",
            "lineNumber": 445
          },
          {
            "text": "        label_asym_id_to_entity_id[str(chain_id)] = str(entity_id)",
            "lineNumber": 446
          },
          {
            "text": "        mmcif_dict[\"_struct_asym.id\"].append(chain_id)",
            "lineNumber": 447
          },
          {
            "text": "        mmcif_dict[\"_struct_asym.entity_id\"].append(str(entity_id))",
            "lineNumber": 448
          },
          {
            "text": "        # Add information about the entity to the _entity_poly table.",
            "lineNumber": 449
          },
          {
            "text": "        mmcif_dict[\"_entity_poly.entity_id\"].append(str(entity_id))",
            "lineNumber": 450
          },
          {
            "text": "        mmcif_dict[\"_entity_poly.type\"].append(residue_constants.PROTEIN_CHAIN)",
            "lineNumber": 451
          },
          {
            "text": "        mmcif_dict[\"_entity_poly.pdbx_strand_id\"].append(chain_id)",
            "lineNumber": 452
          },
          {
            "text": "        # Generate the _entity table.",
            "lineNumber": 453
          },
          {
            "text": "        mmcif_dict[\"_entity.id\"].append(str(entity_id))",
            "lineNumber": 454
          },
          {
            "text": "        mmcif_dict[\"_entity.type\"].append(residue_constants.POLYMER_CHAIN)",
            "lineNumber": 455
          },
          {
            "lineNumber": 456
          },
          {
            "text": "    # Add the residues to the _entity_poly_seq table.",
            "lineNumber": 457
          },
          {
            "text": "    for entity_id, (res_ids, aas) in _get_entity_poly_seq(",
            "lineNumber": 458
          },
          {
            "text": "        aatype, residue_index, chain_index",
            "lineNumber": 459
          },
          {
            "text": "    ).items():",
            "lineNumber": 460
          },
          {
            "text": "        for res_id, aa in zip(res_ids, aas):",
            "lineNumber": 461
          },
          {
            "text": "            mmcif_dict[\"_entity_poly_seq.entity_id\"].append(str(entity_id))",
            "lineNumber": 462
          },
          {
            "text": "            mmcif_dict[\"_entity_poly_seq.num\"].append(str(res_id))",
            "lineNumber": 463
          },
          {
            "text": "            mmcif_dict[\"_entity_poly_seq.mon_id\"].append(residue_constants.resnames[aa])",
            "lineNumber": 464
          },
          {
            "lineNumber": 465
          },
          {
            "text": "    # Populate the chem comp table.",
            "lineNumber": 466
          },
          {
            "text": "    for chem_type, chem_comp in _CHEM_COMP.items():",
            "lineNumber": 467
          },
          {
            "text": "        for chem_id, chem_name in chem_comp:",
            "lineNumber": 468
          },
          {
            "text": "            mmcif_dict[\"_chem_comp.id\"].append(chem_id)",
            "lineNumber": 469
          },
          {
            "text": "            mmcif_dict[\"_chem_comp.type\"].append(chem_type)",
            "lineNumber": 470
          },
          {
            "text": "            mmcif_dict[\"_chem_comp.name\"].append(chem_name)",
            "lineNumber": 471
          },
          {
            "lineNumber": 472
          },
          {
            "text": "    # Add all atom sites.",
            "lineNumber": 473
          },
          {
            "text": "    atom_index = 1",
            "lineNumber": 474
          },
          {
            "text": "    for i in range(aatype.shape[0]):",
            "lineNumber": 475
          },
          {
            "text": "        res_name_3 =",
            "lineNumber": 476
          }
        ]
      },
      "score": 0.2435297966003418
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/models/alphafold/common/protein.py",
        "range": {
          "startPosition": {
            "line": 198,
            "column": 55
          },
          "endPosition": {
            "line": 226
          }
        },
        "contents": "def from_mmcif_string(mmcif_str: str, chain_id: Optional[str] = None) -&gt; Protein:\n    \"\"\"Takes a mmCIF string and constructs a &#96;Protein&#96; object.\n\n    WARNING: All non-standard residue types will be converted into UNK. All\n      non-standard atoms will be ignored.\n\n    Args:\n      mmcif_str: The contents of the mmCIF file\n      chain_id: If chain_id is specified (e.g. A), then only that chain is parsed.\n        Otherwise all chains are parsed.\n\n    Returns:\n      A new &#96;Protein&#96; parsed from the mmCIF contents.\n    \"\"\"\n    with io.StringIO(mmcif_str) as mmcif_fh:\n        parser = MMCIFParser(QUIET=True)\n        structure = parser.get_structure(structure_id=\"none\", filename=mmcif_fh)\n        return _from_bio_structure(structure, chain_id)\n\n\ndef _chain_end(atom_index, end_resname, chain_name, residue_index) -&gt; str:\n    chain_end = \"TER\"",
        "signatures": {},
        "detailedLines": [
          {
            "text": "def from_mmcif_string(mmcif_str: str, chain_id: Optional[str] = None) -&gt; Protein:",
            "lineNumber": 202,
            "isSignature": true
          },
          {
            "text": "    \"\"\"Takes a mmCIF string and constructs a &#96;Protein&#96; object.",
            "lineNumber": 203
          },
          {
            "lineNumber": 204
          },
          {
            "text": "    WARNING: All non-standard residue types will be converted into UNK. All",
            "lineNumber": 205
          },
          {
            "text": "      non-standard atoms will be ignored.",
            "lineNumber": 206
          },
          {
            "lineNumber": 207
          },
          {
            "text": "    Args:",
            "lineNumber": 208
          },
          {
            "text": "      mmcif_str: The contents of the mmCIF file",
            "lineNumber": 209
          },
          {
            "text": "      chain_id: If chain_id is specified (e.g. A), then only that chain is parsed.",
            "lineNumber": 210
          },
          {
            "text": "        Otherwise all chains are parsed.",
            "lineNumber": 211
          },
          {
            "lineNumber": 212
          },
          {
            "text": "    Returns:",
            "lineNumber": 213
          },
          {
            "text": "      A new &#96;Protein&#96; parsed from the mmCIF contents.",
            "lineNumber": 214
          },
          {
            "text": "    \"\"\"",
            "lineNumber": 215
          },
          {
            "text": "    with io.StringIO(mmcif_str) as mmcif_fh:",
            "lineNumber": 216
          },
          {
            "text": "        parser = MMCIFParser(QUIET=True)",
            "lineNumber": 217
          },
          {
            "text": "        structure = parser.get_structure(structure_id=\"none\", filename=mmcif_fh)",
            "lineNumber": 218
          },
          {
            "text": "        return _from_bio_structure(structure, chain_id)",
            "lineNumber": 219,
            "isSignature": true
          },
          {
            "lineNumber": 220
          },
          {
            "lineNumber": 221
          },
          {
            "text": "def _chain_end(atom_index, end_resname, chain_name, residue_index) -&gt; str:",
            "lineNumber": 222,
            "isSignature": true
          },
          {
            "text": "    chain_end = \"TER\"",
            "lineNumber": 223
          }
        ]
      },
      "score": 0.2428452968597412
    },
    {
      "codeBlock": {
        "relativeWorkspacePath": "./mber-open/src/mber/core/modules/evaluation.py",
        "range": {
          "startPosition": {
            "line": 32
          },
          "endPosition": {
            "line": 337
          }
        },
        "contents": "class BaseEvaluationModule(BaseModule):\n\n\n    @time_method()\n    def _setup_models(self, design_state: DesignState) -&gt; None:\n        \"\"\"Initialize models needed for evaluation.\"\"\"\n        with timer(\n            \"Initialize AF complex model\",\n            self._log,\n            design_state.evaluation_data.timings,\n        ):\n            self._log(\"Initializing AlphaFold model for complex evaluation\")\n            self.af_complex_model = AFModel(\n                protocol=\"binder\",\n                debug=False,\n                data_dir=self.environment_config.af_params_dir,\n                use_multimer=self.model_config.use_multimer_eval,\n                num_recycles=self.model_config.num_recycles_eval,\n            )\n\n        with timer(\n            \"Initialize ESM model\", self._log, design_state.evaluation_data.timings\n        ):\n            self._log(\"Initializing ESM model for sequence evaluation\")\n            self.esm_model = PLM_MODELS[self.evaluation_config.plm_model](device=\"cpu\")\n\n        # Add monomer folding model initialization\n        with timer(\n            \"Initialize monomer folding model\",\n            self._log,\n            design_state.evaluation_data.timings,\n        ):\n            self._log(\n                f\"Initializing monomer folding model: {self.evaluation_config.monomer_folding_model}\"\n            )\n            self.monomer_folding_model = FOLDING_MODELS[\n                self.evaluation_config.monomer_folding_model\n            ]()\n\n    @time_method()\n    def _fold_monomer(self, design_state: DesignState, binder_seq: str) -&gt; str:\n        \"\"\"Fold binder sequence as a monomer.\"\"\"\n        with tempfile.TemporaryDirectory() as tmpdir:\n            temp_dir_path = Path(tmpdir)\n            # Fold the binder structure\n            from mber.utils.pdb_utils import fold_binder\n\n            monomer_pdb = fold_binder(\n                self.monomer_folding_model, binder_seq, output_dir=temp_dir_path\n            )\n        return monomer_pdb\n\n    def _evaluate_binder_sequence(\n        self, design_state: DesignState, binder_seq: str, index: int\n    ) -&gt; None:\n        ",
        "signatures": {
          "ranges": [
            {
              "startPosition": {
                "line": 33,
                "column": 1
              },
              "endPosition": {
                "line": 34,
                "column": 5
              }
            }
          ]
        },
        "detailedLines": [
          {
            "text": "class BaseEvaluationModule(BaseModule):",
            "lineNumber": 33,
            "isSignature": true
          },
          {
            "lineNumber": 108
          },
          {
            "lineNumber": 109
          },
          {
            "text": "    @time_method()",
            "lineNumber": 110
          },
          {
            "text": "    def _setup_models(self, design_state: DesignState) -&gt; None:",
            "lineNumber": 111
          },
          {
            "text": "        \"\"\"Initialize models needed for evaluation.\"\"\"",
            "lineNumber": 112
          },
          {
            "text": "        with timer(",
            "lineNumber": 113
          },
          {
            "text": "            \"Initialize AF complex model\",",
            "lineNumber": 114
          },
          {
            "text": "            self._log,",
            "lineNumber": 115
          },
          {
            "text": "            design_state.evaluation_data.timings,",
            "lineNumber": 116
          },
          {
            "text": "        ):",
            "lineNumber": 117
          },
          {
            "text": "            self._log(\"Initializing AlphaFold model for complex evaluation\")",
            "lineNumber": 118
          },
          {
            "text": "            self.af_complex_model = AFModel(",
            "lineNumber": 119
          },
          {
            "text": "                protocol=\"binder\",",
            "lineNumber": 120
          },
          {
            "text": "                debug=False,",
            "lineNumber": 121
          },
          {
            "text": "                data_dir=self.environment_config.af_params_dir,",
            "lineNumber": 122
          },
          {
            "text": "                use_multimer=self.model_config.use_multimer_eval,",
            "lineNumber": 123
          },
          {
            "text": "                num_recycles=self.model_config.num_recycles_eval,",
            "lineNumber": 124
          },
          {
            "text": "            )",
            "lineNumber": 125
          },
          {
            "lineNumber": 126
          },
          {
            "text": "        with timer(",
            "lineNumber": 127
          },
          {
            "text": "            \"Initialize ESM model\", self._log, design_state.evaluation_data.timings",
            "lineNumber": 128
          },
          {
            "text": "        ):",
            "lineNumber": 129
          },
          {
            "text": "            self._log(\"Initializing ESM model for sequence evaluation\")",
            "lineNumber": 130
          },
          {
            "text": "            self.esm_model = PLM_MODELS[self.evaluation_config.plm_model](device=\"cpu\")",
            "lineNumber": 131
          },
          {
            "lineNumber": 132
          },
          {
            "text": "        # Add monomer folding model initialization",
            "lineNumber": 133
          },
          {
            "text": "        with timer(",
            "lineNumber": 134
          },
          {
            "text": "            \"Initialize monomer folding model\",",
            "lineNumber": 135
          },
          {
            "text": "            self._log,",
            "lineNumber": 136
          },
          {
            "text": "            design_state.evaluation_data.timings,",
            "lineNumber": 137
          },
          {
            "text": "        ):",
            "lineNumber": 138
          },
          {
            "text": "            self._log(",
            "lineNumber": 139
          },
          {
            "text": "                f\"Initializing monomer folding model: {self.evaluation_config.monomer_folding_model}\"",
            "lineNumber": 140
          },
          {
            "text": "            )",
            "lineNumber": 141
          },
          {
            "text": "            self.monomer_folding_model = FOLDING_MODELS[",
            "lineNumber": 142
          },
          {
            "text": "                self.evaluation_config.monomer_folding_model",
            "lineNumber": 143
          },
          {
            "text": "            ]()",
            "lineNumber": 144
          },
          {
            "lineNumber": 145
          },
          {
            "text": "    @time_method()",
            "lineNumber": 146
          },
          {
            "text": "    def _fold_monomer(self, design_state: DesignState, binder_seq: str) -&gt; str:",
            "lineNumber": 147
          },
          {
            "text": "        \"\"\"Fold binder sequence as a monomer.\"\"\"",
            "lineNumber": 148
          },
          {
            "text": "        with tempfile.TemporaryDirectory() as tmpdir:",
            "lineNumber": 149
          },
          {
            "text": "            temp_dir_path = Path(tmpdir)",
            "lineNumber": 150
          },
          {
            "text": "            # Fold the binder structure",
            "lineNumber": 151
          },
          {
            "text": "            from mber.utils.pdb_utils import fold_binder",
            "lineNumber": 152
          },
          {
            "lineNumber": 153
          },
          {
            "text": "            monomer_pdb = fold_binder(",
            "lineNumber": 154
          },
          {
            "text": "                self.monomer_folding_model, binder_seq, output_dir=temp_dir_path",
            "lineNumber": 155
          },
          {
            "text": "            )",
            "lineNumber": 156
          },
          {
            "text": "        return monomer_pdb",
            "lineNumber": 157
          },
          {
            "lineNumber": 158
          },
          {
            "text": "    def _evaluate_binder_sequence(",
            "lineNumber": 159
          },
          {
            "text": "        self, design_state: DesignState, binder_seq: str, index: int",
            "lineNumber": 160
          },
          {
            "text": "    ) -&gt; None:",
            "lineNumber": 161
          },
          {
            "text": "        ",
            "lineNumber": 162
          }
        ]
      },
      "score": 0.24244600534439087
    }
  ]
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/models/colabdesign/loss.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design/state.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design/template.py</summary>

</details>
</tool-use>

---


Checking the base template module's use of `target_id` and how the trajectory applies the loss:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/core/modules/template.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design/trajectory.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/protocols/src/mber_protocols/stable/VHH_binder_design/config.py</summary>

</details>
</tool-use>

---


Checking how the trajectory registers losses and whether binder regions (e.g., CDRs) are specified:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/core/modules/trajectory.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/utils/regions.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/core/modules/config.py</summary>

</details>
</tool-use>

---


Checking the rest of `_setup_loss` and how colabdesign uses contact loss:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/core/modules/trajectory.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="unknown" data-tool-name="ripgrep_raw_search">
<details>
<summary>Tool use: **ripgrep_raw_search**</summary>


Parameters:

```json
{
  "pattern": "con|contact|CDR|interface",
  "path": "/home/ec2-user/snap/mber-open/src/mber",
  "caseInsensitive": false
}
```
Result:

```json
{
  "success": {
    "pattern": "con|contact|CDR|interface",
    "path": "/home/ec2-user/snap/mber-open/src/mber",
    "outputMode": "content",
    "workspaceResults": {
      "/home/ec2-user/snap": {
        "content": {
          "matches": [
            {
              "file": "mber-open/src/mber/utils/yaml_summary_utils.py",
              "matches": [
                {
                  "lineNumber": 31,
                  "content": "    # Extract configuration information (particularly loss config)"
                },
                {
                  "lineNumber": 32,
                  "content": "    if hasattr(design_state, \"config_data\") and design_state.config_data:"
                },
                {
                  "lineNumber": 33,
                  "content": "        config_data = design_state.config_data"
                },
                {
                  "lineNumber": 34,
                  "content": "        summary[\"config\"] = {}"
                },
                {
                  "lineNumber": 36,
                  "content": "        # Add loss configuration weights"
                },
                {
                  "lineNumber": 37,
                  "content": "        if config_data.loss_config:"
                },
                {
                  "lineNumber": 38,
                  "content": "            summary[\"config\"][\"loss_weights\"] = {}"
                },
                {
                  "lineNumber": 40,
                  "content": "            for key, value in config_data.loss_config.items():"
                },
                {
                  "lineNumber": 42,
                  "content": "                    summary[\"config\"][\"loss_weights\"][key] = value"
                },
                {
                  "lineNumber": 44,
                  "content": "        # Add trajectory configuration"
                },
                {
                  "lineNumber": 45,
                  "content": "        if config_data.trajectory_config:"
                },
                {
                  "lineNumber": 46,
                  "content": "            summary[\"config\"][\"trajectory\"] = {"
                },
                {
                  "lineNumber": 47,
                  "content": "                \"optimizer_type\": config_data.trajectory_config.get(\"optimizer_type\"),"
                },
                {
                  "lineNumber": 48,
                  "content": "                \"optimizer_learning_rate\": config_data.trajectory_config.get(\"optimizer_learning_rate\"),"
                },
                {
                  "lineNumber": 49,
                  "content": "                \"optimizer_b1\": config_data.trajectory_config.get(\"optimizer_b1\"),"
                },
                {
                  "lineNumber": 50,
                  "content": "                \"optimizer_b2\": config_data.trajectory_config.get(\"optimizer_b2\"),"
                },
                {
                  "lineNumber": 51,
                  "content": "                \"soft_iters\": config_data.trajectory_config.get(\"soft_iters\"),"
                },
                {
                  "lineNumber": 52,
                  "content": "                \"temp_iters\": config_data.trajectory_config.get(\"temp_iters\"),"
                },
                {
                  "lineNumber": 53,
                  "content": "                \"hard_iters\": config_data.trajectory_config.get(\"hard_iters\"),"
                },
                {
                  "lineNumber": 54,
                  "content": "                \"pssm_iters\": config_data.trajectory_config.get(\"pssm_iters\"),"
                },
                {
                  "lineNumber": 57,
                  "content": "            summary[\"config\"][\"trajectory\"] = {k: v for k, v in summary[\"config\"][\"trajectory\"].items() if v is not None}"
                },
                {
                  "lineNumber": 59,
                  "content": "        # Add model configuration"
                },
                {
                  "lineNumber": 60,
                  "content": "        if config_data.model_config:"
                },
                {
                  "lineNumber": 61,
                  "content": "            summary[\"config\"][\"model\"] = {"
                },
                {
                  "lineNumber": 62,
                  "content": "                \"num_recycles_design\": config_data.model_config.get(\"num_recycles_design\"),"
                },
                {
                  "lineNumber": 63,
                  "content": "                \"num_recycles_eval\": config_data.model_config.get(\"num_recycles_eval\"),"
                },
                {
                  "lineNumber": 64,
                  "content": "                \"use_multimer_design\": config_data.model_config.get(\"use_multimer_design\"),"
                },
                {
                  "lineNumber": 67,
                  "content": "            summary[\"config\"][\"model\"] = {k: v for k, v in summary[\"config\"][\"model\"].items() if v is not None}"
                },
                {
                  "lineNumber": 130,
                  "content": "            # Limit to at most 10 sequences to keep summary concise"
                },
                {
                  "lineNumber": 158,
                  "content": "                # Calculate a composite score giving more weight to interface metrics"
                },
                {
                  "lineNumber": 214,
                  "content": "            ):  # Limit to 5 binders for conciseness"
                },
                {
                  "lineNumber": 245,
                  "content": "# This file contains key metrics and information about the design run."
                },
                {
                  "lineNumber": 255,
                  "content": "config:"
                },
                {
                  "lineNumber": 256,
                  "content": "{config}"
                },
                {
                  "lineNumber": 270,
                  "content": "# Total design runtime in seconds"
                },
                {
                  "lineNumber": 298,
                  "content": "    config_data = yaml.dump("
                },
                {
                  "lineNumber": 299,
                  "content": "        summary.get(\"config\", {}), default_flow_style=False, sort_keys=False"
                },
                {
                  "lineNumber": 312,
                  "content": "    config_data = \"\\n\".join([\"  \" + line for line in config_data.splitlines()])"
                },
                {
                  "lineNumber": 322,
                  "content": "        config=config_data,"
                },
                {
                  "lineNumber": 353,
                  "content": "        \"# This file contains key metrics and information about the design run.\""
                },
                {
                  "lineNumber": 360,
                  "content": "        \"config:\": \"\\n# Configuration parameters used for this run\","
                },
                {
                  "lineNumber": 364,
                  "content": "        \"total_runtime:\": \"\\n# Total design runtime in seconds\","
                }
              ]
            },
            {
              "file": "mber-open/src/mber/utils/timing_utils.py",
              "matches": [
                {
                  "lineNumber": 3,
                  "content": "from contextlib import contextmanager"
                },
                {
                  "lineNumber": 11,
                  "content": "@contextmanager"
                },
                {
                  "lineNumber": 40,
                  "content": "        timing_msg = f\"{name} took {elapsed_time:.2f} seconds\""
                },
                {
                  "lineNumber": 95,
                  "content": "            timing_msg = f\"{operation_name} completed in {elapsed_time:.2f} seconds\""
                },
                {
                  "lineNumber": 183,
                  "content": "        timing_msg = f\"{self.name} took {self.elapsed:.2f} seconds\""
                },
                {
                  "lineNumber": 200,
                  "content": "        \"\"\"Support context manager interface\"\"\""
                },
                {
                  "lineNumber": 205,
                  "content": "        \"\"\"Support context manager interface\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/utils/timing_summary.py",
              "matches": [
                {
                  "lineNumber": 13,
                  "content": "        design_state: The design state containing timing information"
                },
                {
                  "lineNumber": 139,
                  "content": "    axes[0].set_ylabel(\"Time (seconds)\")"
                },
                {
                  "lineNumber": 160,
                  "content": "    axes[1].set_xlabel(\"Time (seconds)\")"
                },
                {
                  "lineNumber": 174,
                  "content": "    Print a formatted timing summary to the console."
                },
                {
                  "lineNumber": 177,
                  "content": "        design_state: The design state containing timing information"
                },
                {
                  "lineNumber": 191,
                  "content": "    print(f\"\\nTotal execution time: {total_time:.2f} seconds\\n\")"
                },
                {
                  "lineNumber": 203,
                  "content": "    # Print top 10 most time-consuming operations"
                },
                {
                  "lineNumber": 204,
                  "content": "    print(\"\\nTop 10 most time-consuming operations:\")"
                },
                {
                  "lineNumber": 220,
                  "content": "        design_state: The design state containing timing information"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/utils/regions.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "    def contains_residue(self, residue: Residue) -&gt; bool:"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/utils/pdb_utils.py",
              "matches": [
                {
                  "lineNumber": 20,
                  "content": "    \"\"\"Process target protein from ID or file, returning PDB content and PAE matrix if available.\"\"\""
                },
                {
                  "lineNumber": 74,
                  "content": "            pdb_content = response.text"
                },
                {
                  "lineNumber": 82,
                  "content": "                return pdb_content, pae_matrix"
                },
                {
                  "lineNumber": 84,
                  "content": "                return pdb_content, None  # PAE file not available"
                },
                {
                  "lineNumber": 109,
                  "content": "        raise ValueError(\"PAE file must contain a 'predicted_aligned_error' field\")"
                },
                {
                  "lineNumber": 158,
                  "content": "    # Join to create PDB content"
                },
                {
                  "lineNumber": 230,
                  "content": "    # Read PDB content"
                },
                {
                  "lineNumber": 232,
                  "content": "        pdb_content = f.read()"
                },
                {
                  "lineNumber": 234,
                  "content": "    return pdb_content"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/plm/plm_model_bases.py",
              "matches": [
                {
                  "lineNumber": 57,
                  "content": "            masked_sequence: String containing amino acids and mask tokens (*)"
                },
                {
                  "lineNumber": 60,
                  "content": "            numpy array of shape (sequence_length, num_amino_acids) containing logits"
                },
                {
                  "lineNumber": 77,
                  "content": "            masked_sequence: String containing amino acids and mask tokens (*)"
                },
                {
                  "lineNumber": 81,
                  "content": "            numpy array of shape (sequence_length, 20) containing probabilities"
                },
                {
                  "lineNumber": 132,
                  "content": "                    continue # Skip non-standard amino acids, mostly for dealing with '|' character for now"
                },
                {
                  "lineNumber": 161,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 177,
                  "content": "            masked_sequence: String containing amino acids and mask tokens (*)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/plm/esm2_model.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "    \"\"\"ESM2 implementation of the ProteinLanguageModel interface.\"\"\""
                },
                {
                  "lineNumber": 43,
                  "content": "        self.aa_tokens = [self.tokenizer.convert_tokens_to_ids(aa) for aa in "
                },
                {
                  "lineNumber": 50,
                  "content": "            # checkpoint state dict contains the spurious key \"esm.embeddings.position_ids\". remove it."
                },
                {
                  "lineNumber": 60,
                  "content": "            masked_sequence: String containing amino acids and mask tokens (*)"
                },
                {
                  "lineNumber": 63,
                  "content": "            numpy array of shape (sequence_length, num_amino_acids) containing logits"
                },
                {
                  "lineNumber": 88,
                  "content": "        # Remove CLS and EOS tokens from logits and convert to numpy"
                },
                {
                  "lineNumber": 121,
                  "content": "        aa_list = [self.tokenizer.convert_ids_to_tokens(self.aa_tokens)[i] for i in range(20)]"
                },
                {
                  "lineNumber": 137,
                  "content": "    #     aa_list = [self.tokenizer.convert_ids_to_tokens(self.aa_tokens)[i] for i in range(20)]"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/plm/ablang2_model.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "    \"\"\"AbLang2 implementation of the ProteinLanguageModel interface.\"\"\""
                },
                {
                  "lineNumber": 70,
                  "content": "        \"\"\"Ensure sequence ends with a pipe if it doesn't contain one.\"\"\""
                },
                {
                  "lineNumber": 71,
                  "content": "        # if sequence contains (G4S)3, assume it is scFv and split it into H and L chains"
                },
                {
                  "lineNumber": 87,
                  "content": "            sequence: String containing the sequence to process"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/folding/nbb2_model.py",
              "matches": [
                {
                  "lineNumber": 12,
                  "content": "    \"\"\"NanoBodyBuilder2 implementation of the ProteinFoldingModel interface.\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/colabdesign/prep.py",
              "matches": [
                {
                  "lineNumber": 71,
                  "content": "                                    \"con\":0.0, \"i_con\":0.0, \"i_pae\":0.0})"
                },
                {
                  "lineNumber": 75,
                  "content": "            self.opt[\"weights\"].update({\"plddt\":0.1, \"con\":0.0, \"i_con\":1.0, \"i_pae\":0.0})"
                },
                {
                  "lineNumber": 77,
                  "content": "        # configure input features"
                },
                {
                  "lineNumber": 83,
                  "content": "        # configure template rm masks"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/folding/folding_model_bases.py",
              "matches": [
                {
                  "lineNumber": 23,
                  "content": "            confidence_threshold: Optional threshold for model confidence"
                },
                {
                  "lineNumber": 26,
                  "content": "            Tuple of (path to saved PDB file, predicted confidence score)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/colabdesign/optimizer.py",
              "matches": [
                {
                  "lineNumber": 62,
                  "content": "        optimizer = optax.contrib.schedule_free_adamw("
                },
                {
                  "lineNumber": 77,
                  "content": "        optimizer = optax.contrib.schedule_free_sgd("
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/colabdesign/design.py",
              "matches": [
                {
                  "lineNumber": 28,
                  "content": "        # Use different key to avoid conflict with other ColabDesign methods"
                },
                {
                  "lineNumber": 40,
                  "content": "            # https://www.biorxiv.org/content/10.1101/2021.08.24.457549v1"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/folding/esmfold_model.py",
              "matches": [
                {
                  "lineNumber": 8,
                  "content": "    \"\"\"ESMFold implementation of the ProteinFoldingModel interface.\"\"\""
                },
                {
                  "lineNumber": 53,
                  "content": "        confidence_threshold: Optional[float] = None,"
                },
                {
                  "lineNumber": 61,
                  "content": "            confidence_threshold: Optional threshold for model confidence (unused in this implementation)"
                },
                {
                  "lineNumber": 100,
                  "content": "    def get_confidence_scores(self, sequence: str) -&gt; dict:"
                },
                {
                  "lineNumber": 102,
                  "content": "        Get confidence scores for a predicted structure."
                },
                {
                  "lineNumber": 108,
                  "content": "            Dictionary with confidence metrics"
                },
                {
                  "lineNumber": 118,
                  "content": "                return_confidence=True,"
                },
                {
                  "lineNumber": 121,
                  "content": "            # Extract confidence metrics"
                },
                {
                  "lineNumber": 122,
                  "content": "            confidence_metrics = {}"
                },
                {
                  "lineNumber": 124,
                  "content": "            # pLDDT scores (per-residue confidence)"
                },
                {
                  "lineNumber": 126,
                  "content": "                confidence_metrics[\"plddt\"] = outputs.plddt.cpu().numpy()[0]"
                },
                {
                  "lineNumber": 127,
                  "content": "                confidence_metrics[\"avg_plddt\"] = float(np.mean(confidence_metrics[\"plddt\"]))"
                },
                {
                  "lineNumber": 131,
                  "content": "                confidence_metrics[\"ptm\"] = float(outputs.ptm.cpu().numpy()[0])"
                },
                {
                  "lineNumber": 133,
                  "content": "            return confidence_metrics"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/colabdesign/loss.py",
              "matches": [
                {
                  "lineNumber": 4,
                  "content": "from colabdesign.af.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 5,
                  "content": "from colabdesign.af.loss import _af_loss, get_ptm, mask_loss, get_dgram_bins, _get_con_loss"
                },
                {
                  "lineNumber": 25,
                  "content": "        ca = xyz[\"final_atom_positions\"][:, residue_constants.atom_order[\"CA\"]]"
                },
                {
                  "lineNumber": 37,
                  "content": "# Define interface pTM loss for colabdesign"
                },
                {
                  "lineNumber": 40,
                  "content": "        p = 1 - get_ptm(inputs, outputs, interface=True)"
                },
                {
                  "lineNumber": 65,
                  "content": "        x = _get_con_loss(dgram, dgram_bins, cutoff=6.0, binary=True)"
                },
                {
                  "lineNumber": 91,
                  "content": "        ca = xyz[\"final_atom_positions\"][:, residue_constants.atom_order[\"CA\"]]"
                },
                {
                  "lineNumber": 115,
                  "content": "from colabdesign.af.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 120,
                  "content": "    Add hydrogen bonding loss to encourage H-bonds at the interface."
                },
                {
                  "lineNumber": 122,
                  "content": "    This loss function rewards close contacts between polar residues"
                },
                {
                  "lineNumber": 172,
                  "content": "        # Extract interface distances"
                },
                {
                  "lineNumber": 173,
                  "content": "        interface_dist = expected_dist[:target_len, target_len:]  # [target_len, binder_len]"
                },
                {
                  "lineNumber": 179,
                  "content": "        dist_score = jnp.exp(-((interface_dist - optimal_dist) ** 2) / (2 * dist_std ** 2))"
                },
                {
                  "lineNumber": 208,
                  "content": "    Add salt bridge loss to encourage complementary charged residues at the interface."
                },
                {
                  "lineNumber": 257,
                  "content": "        # Extract interface distances"
                },
                {
                  "lineNumber": 258,
                  "content": "        interface_dist = expected_dist[:target_len, target_len:]"
                },
                {
                  "lineNumber": 263,
                  "content": "        dist_score = jnp.exp(-((interface_dist - optimal_dist) ** 2) / (2 * dist_std ** 2))"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/folding/af2_model.py",
              "matches": [
                {
                  "lineNumber": 10,
                  "content": "    \"\"\"ColabDesign implementation of AlphaFold2 in the ProteinFoldingModel interface.\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/folding/abb2_model.py",
              "matches": [
                {
                  "lineNumber": 9,
                  "content": "    \"\"\"ABodyBuilder2 implementation of the ProteinFoldingModel interface.\"\"\""
                },
                {
                  "lineNumber": 32,
                  "content": "        # if sequence contains (G4S)3, assume it is scFv and split it into H and L chains"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/colabfold/relax.py",
              "matches": [
                {
                  "lineNumber": 56,
                  "content": "        help=\"tolerance level for the relaxation convergence\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/relax/utils.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 23,
                  "content": "    \"\"\"Overwrites the B-factors in pdb_str with contents of bfactors array."
                },
                {
                  "lineNumber": 34,
                  "content": "    if bfactors.shape[-1] != residue_constants.atom_type_num:"
                },
                {
                  "lineNumber": 55,
                  "content": "        atom.bfactor = bfactors[idx, residue_constants.atom_order[\"CA\"]]"
                },
                {
                  "lineNumber": 69,
                  "content": "    oxt = residue_constants.atom_order[\"OXT\"]"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/relax/relax_test.py",
              "matches": [
                {
                  "lineNumber": 33,
                  "content": "        self.test_config = {"
                },
                {
                  "lineNumber": 43,
                  "content": "        amber_relax = relax.AmberRelaxation(**self.test_config)"
                },
                {
                  "lineNumber": 77,
                  "content": "        amber_relax = relax.AmberRelaxation(**self.test_config)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/relax/relax.py",
              "matches": [
                {
                  "lineNumber": 41,
                  "content": "          stiffness: kcal/mol A**2, spring constant of heavy atom restraining"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/relax/cleanup.py",
              "matches": [
                {
                  "lineNumber": 28,
                  "content": "  \"\"\"Apply pdbfixer to the contents of a PDB file; return a PDB string result."
                },
                {
                  "lineNumber": 75,
                  "content": "  \"\"\"Removes the residues that Pdbfixer considers to be heterogens."
                },
                {
                  "lineNumber": 80,
                  "content": "    keep_water: If True, water (HOH) is not considered to be a heterogen."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/relax/amber_minimize_test.py",
              "matches": [
                {
                  "lineNumber": 54,
                  "content": "            \" residues. This protein contains at least one residue with no atoms.\","
                },
                {
                  "lineNumber": 76,
                  "content": "        expected_between_residues_connection_mask = np.zeros((191,), np.float32)"
                },
                {
                  "lineNumber": 78,
                  "content": "            expected_between_residues_connection_mask[residue] = 1.0"
                },
                {
                  "lineNumber": 128,
                  "content": "            viols[\"between_residues\"][\"connections_per_residue_violation_mask\"],"
                },
                {
                  "lineNumber": 129,
                  "content": "            expected_between_residues_connection_mask,"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/relax/amber_minimize.py",
              "matches": [
                {
                  "lineNumber": 23,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 66,
                  "content": "      continue"
                },
                {
                  "lineNumber": 88,
                  "content": "  constraints = openmm_app.HBonds"
                },
                {
                  "lineNumber": 90,
                  "content": "      pdb.topology, constraints=constraints)"
                },
                {
                  "lineNumber": 98,
                  "content": "  simulation.context.setPositions(pdb.positions)"
                },
                {
                  "lineNumber": 101,
                  "content": "  state = simulation.context.getState(getEnergy=True, getPositions=True)"
                },
                {
                  "lineNumber": 106,
                  "content": "  state = simulation.context.getState(getEnergy=True, getPositions=True)"
                },
                {
                  "lineNumber": 140,
                  "content": "  \"\"\"Checks that all residues contain non-empty atom sets.\"\"\""
                },
                {
                  "lineNumber": 143,
                  "content": "                     \" well-defined residues. This protein contains at least\""
                },
                {
                  "lineNumber": 194,
                  "content": "  for rt in residue_constants.restypes:"
                },
                {
                  "lineNumber": 195,
                  "content": "    atom_names = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 196,
                  "content": "        residue_constants.restype_1to3[rt]]"
                },
                {
                  "lineNumber": 199,
                  "content": "        (residue_constants.atom_order[name] if name else 0)"
                },
                {
                  "lineNumber": 206,
                  "content": "        for name in residue_constants.atom_types"
                },
                {
                  "lineNumber": 221,
                  "content": "  # with shape (num_res, 14) containing the atom37 indices for this protein."
                },
                {
                  "lineNumber": 247,
                  "content": "  for restype, restype_letter in enumerate(residue_constants.restypes):"
                },
                {
                  "lineNumber": 248,
                  "content": "    restype_name = residue_constants.restype_1to3[restype_letter]"
                },
                {
                  "lineNumber": 249,
                  "content": "    atom_names = residue_constants.residue_atoms[restype_name]"
                },
                {
                  "lineNumber": 251,
                  "content": "      atom_type = residue_constants.atom_order[atom_name]"
                },
                {
                  "lineNumber": 260,
                  "content": "      residue_constants.restype_1to3[res] for res in residue_constants.restypes"
                },
                {
                  "lineNumber": 266,
                  "content": "  for resname, swap in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 269,
                  "content": "      source_index = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 271,
                  "content": "      target_index = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 302,
                  "content": "  for resname, swap in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 304,
                  "content": "      restype = residue_constants.restype_order["
                },
                {
                  "lineNumber": 305,
                  "content": "          residue_constants.restype_3to1[resname]]"
                },
                {
                  "lineNumber": 306,
                  "content": "      atom_idx1 = residue_constants.restype_name_to_atom14_names[resname].index("
                },
                {
                  "lineNumber": 308,
                  "content": "      atom_idx2 = residue_constants.restype_name_to_atom14_names[resname].index("
                },
                {
                  "lineNumber": 343,
                  "content": "      config=ml_collections.ConfigDict("
                },
                {
                  "lineNumber": 344,
                  "content": "          {\"violation_tolerance_factor\": 12,  # Taken from model config."
                },
                {
                  "lineNumber": 345,
                  "content": "           \"clash_overlap_tolerance\": 1.5,  # Taken from model config."
                },
                {
                  "lineNumber": 385,
                  "content": "    stiffness: kcal/mol A**2, spring constant of heavy atom restraining"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/notebooks/notebook_utils.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 30,
                  "content": "    aatypes = set(residue_constants.restypes)  # 20 standard aatypes."
                },
                {
                  "lineNumber": 33,
                  "content": "            f\"Input sequence contains non-amino acid letters: \""
                },
                {
                  "lineNumber": 143,
                  "content": "            (num_templates, num_res, len(residue_constants.restypes_with_x_and_gap)),"
                },
                {
                  "lineNumber": 147,
                  "content": "            (num_templates, num_res, residue_constants.atom_type_num), dtype=np.float32"
                },
                {
                  "lineNumber": 150,
                  "content": "            (num_templates, num_res, residue_constants.atom_type_num, 3),"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/utils.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "import contextlib"
                },
                {
                  "lineNumber": 43,
                  "content": "def bfloat16_creator(next_creator, shape, dtype, init, context):"
                },
                {
                  "lineNumber": 45,
                  "content": "  if context.original_dtype == jnp.bfloat16:"
                },
                {
                  "lineNumber": 50,
                  "content": "def bfloat16_getter(next_getter, value, context):"
                },
                {
                  "lineNumber": 52,
                  "content": "  if context.original_dtype == jnp.bfloat16:"
                },
                {
                  "lineNumber": 58,
                  "content": "@contextlib.contextmanager"
                },
                {
                  "lineNumber": 59,
                  "content": "def bfloat16_context():"
                },
                {
                  "lineNumber": 64,
                  "content": "def final_init(config):"
                },
                {
                  "lineNumber": 65,
                  "content": "  if config.zero_init:"
                },
                {
                  "lineNumber": 121,
                  "content": "def padding_consistent_rng(f):"
                },
                {
                  "lineNumber": 122,
                  "content": "  \"\"\"Modify any element-wise random function to be consistent with padding."
                },
                {
                  "lineNumber": 128,
                  "content": "  This function makes a random function that is consistent regardless of the"
                },
                {
                  "lineNumber": 131,
                  "content": "  Note: The padding-consistent function is likely to be slower to compile and"
                },
                {
                  "lineNumber": 140,
                  "content": "    An equivalent function to f, that is now consistent for different amounts of"
                },
                {
                  "lineNumber": 144,
                  "content": "    \"\"\"Generate a grid of rng keys that is consistent with different padding."
                },
                {
                  "lineNumber": 154,
                  "content": "      An array of shape &#96;shape&#96; consisting of random keys."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/tf/shape_helpers.py",
              "matches": [
                {
                  "lineNumber": 31,
                  "content": "  x = tf.convert_to_tensor(x)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/tf/proteins_dataset.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\"\"\"Datasets consisting of proteins.\"\"\""
                },
                {
                  "lineNumber": 91,
                  "content": "        new_shape_size = tf.constant(1, dtype=tf.int32)"
                },
                {
                  "lineNumber": 112,
                  "content": "            with tf.control_dependencies([assert_non_empty, assert_equal]):"
                },
                {
                  "lineNumber": 115,
                  "content": "            with tf.control_dependencies([assert_equal]):"
                },
                {
                  "lineNumber": 172,
                  "content": "        k: tf.constant(v) for k, v in np_example.items() if k in features_metadata"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/quat_affine.py",
              "matches": [
                {
                  "lineNumber": 19,
                  "content": "It consists of vectors corresponding to the"
                },
                {
                  "lineNumber": 222,
                  "content": "    return jnp.concatenate("
                },
                {
                  "lineNumber": 265,
                  "content": "        quaternion. 3-vector for translation concatenated."
                },
                {
                  "lineNumber": 435,
                  "content": "  \"\"\"Returns rotation and translation matrices to convert from reference."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/tf/protein_features.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 52,
                  "content": "    \"all_atom_positions\": (tf.float32, [NUM_RES, residue_constants.atom_type_num, 3]),"
                },
                {
                  "lineNumber": 53,
                  "content": "    \"all_atom_mask\": (tf.int64, [NUM_RES, residue_constants.atom_type_num]),"
                },
                {
                  "lineNumber": 60,
                  "content": "        [NUM_TEMPLATES, NUM_RES, residue_constants.atom_type_num, 3],"
                },
                {
                  "lineNumber": 64,
                  "content": "        [NUM_TEMPLATES, NUM_RES, residue_constants.atom_type_num, 1],"
                },
                {
                  "lineNumber": 111,
                  "content": "      ValueError: If a feature is requested but no concrete placeholder value is"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/tf/input_pipeline.py",
              "matches": [
                {
                  "lineNumber": 22,
                  "content": "# Pylint gets confused by the curry1 decorator because it changes the number"
                },
                {
                  "lineNumber": 33,
                  "content": "def nonensembled_map_fns(data_config):"
                },
                {
                  "lineNumber": 35,
                  "content": "    common_cfg = data_config.common"
                },
                {
                  "lineNumber": 68,
                  "content": "def ensembled_map_fns(data_config):"
                },
                {
                  "lineNumber": 70,
                  "content": "    common_cfg = data_config.common"
                },
                {
                  "lineNumber": 71,
                  "content": "    eval_cfg = data_config.eval"
                },
                {
                  "lineNumber": 134,
                  "content": "def process_tensors_from_config(tensors, data_config):"
                },
                {
                  "lineNumber": 135,
                  "content": "    \"\"\"Apply filters and maps to an existing dataset, based on the config.\"\"\""
                },
                {
                  "lineNumber": 140,
                  "content": "        fns = ensembled_map_fns(data_config)"
                },
                {
                  "lineNumber": 145,
                  "content": "    eval_cfg = data_config.eval"
                },
                {
                  "lineNumber": 146,
                  "content": "    tensors = compose(nonensembled_map_fns(data_config))(tensors)"
                },
                {
                  "lineNumber": 148,
                  "content": "    tensors_0 = wrap_ensemble_fn(tensors, tf.constant(0))"
                },
                {
                  "lineNumber": 150,
                  "content": "    if data_config.common.resample_msa_in_recycling:"
                },
                {
                  "lineNumber": 152,
                  "content": "        num_ensemble *= data_config.common.num_recycle + 1"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/tf/data_transforms.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 24,
                  "content": "# Pylint gets confused by the curry1 decorator because it changes the number"
                },
                {
                  "lineNumber": 78,
                  "content": "    protein[\"is_distillation\"] = tf.constant("
                },
                {
                  "lineNumber": 96,
                  "content": "    new_order_list = residue_constants.MAP_HHBLITS_AATYPE_TO_OUR_AATYPE"
                },
                {
                  "lineNumber": 97,
                  "content": "    new_order = tf.constant(new_order_list, dtype=tf.int32)"
                },
                {
                  "lineNumber": 105,
                  "content": "    \"\"\"Correct MSA restype to have the same order as residue_constants.\"\"\""
                },
                {
                  "lineNumber": 106,
                  "content": "    new_order_list = residue_constants.MAP_HHBLITS_AATYPE_TO_OUR_AATYPE"
                },
                {
                  "lineNumber": 107,
                  "content": "    new_order = tf.constant(new_order_list, dtype=protein[\"msa\"].dtype)"
                },
                {
                  "lineNumber": 196,
                  "content": "    index_order = tf.concat([[0], shuffled], axis=0)"
                },
                {
                  "lineNumber": 231,
                  "content": "def block_delete_msa(protein, config):"
                },
                {
                  "lineNumber": 232,
                  "content": "    \"\"\"Sample MSA by deleting contiguous blocks."
                },
                {
                  "lineNumber": 237,
                  "content": "      protein: batch dict containing the msa"
                },
                {
                  "lineNumber": 238,
                  "content": "      config: ConfigDict with parameters"
                },
                {
                  "lineNumber": 245,
                  "content": "        tf.floor(tf.cast(num_seq, tf.float32) * config.msa_fraction_per_block), tf.int32"
                },
                {
                  "lineNumber": 248,
                  "content": "    if config.randomize_num_blocks:"
                },
                {
                  "lineNumber": 249,
                  "content": "        nb = tf.random.uniform([], 0, config.num_blocks + 1, dtype=tf.int32)"
                },
                {
                  "lineNumber": 251,
                  "content": "        nb = config.num_blocks"
                },
                {
                  "lineNumber": 261,
                  "content": "    keep_indices = tf.concat([[0], keep_indices], axis=0)"
                },
                {
                  "lineNumber": 278,
                  "content": "    weights = tf.concat("
                },
                {
                  "lineNumber": 347,
                  "content": "    is_gly = tf.equal(aatype, residue_constants.restype_order[\"G\"])"
                },
                {
                  "lineNumber": 348,
                  "content": "    ca_idx = residue_constants.atom_order[\"CA\"]"
                },
                {
                  "lineNumber": 349,
                  "content": "    cb_idx = residue_constants.atom_order[\"CB\"]"
                },
                {
                  "lineNumber": 381,
                  "content": "def add_constant_field(protein, key, value):"
                },
                {
                  "lineNumber": 382,
                  "content": "    protein[key] = tf.convert_to_tensor(value)"
                },
                {
                  "lineNumber": 406,
                  "content": "def make_masked_msa(protein, config, replace_fraction):"
                },
                {
                  "lineNumber": 409,
                  "content": "    random_aa = tf.constant([0.05] * 20 + [0.0, 0.0], dtype=tf.float32)"
                },
                {
                  "lineNumber": 412,
                  "content": "        config.uniform_prob * random_aa"
                },
                {
                  "lineNumber": 413,
                  "content": "        + config.profile_prob * protein[\"hhblits_profile\"]"
                },
                {
                  "lineNumber": 414,
                  "content": "        + config.same_prob * tf.one_hot(protein[\"msa\"], 22)"
                },
                {
                  "lineNumber": 420,
                  "content": "    mask_prob = 1.0 - config.profile_prob - config.same_prob - config.uniform_prob"
                },
                {
                  "lineNumber": 422,
                  "content": "    categorical_probs = tf.pad(categorical_probs, pad_shapes, constant_values=mask_prob)"
                },
                {
                  "lineNumber": 454,
                  "content": "            continue"
                },
                {
                  "lineNumber": 472,
                  "content": "    \"\"\"Create and concatenate MSA features.\"\"\""
                },
                {
                  "lineNumber": 514,
                  "content": "    protein[\"msa_feat\"] = tf.concat(msa_feat, axis=-1)"
                },
                {
                  "lineNumber": 515,
                  "content": "    protein[\"target_feat\"] = tf.concat(target_feat, axis=-1)"
                },
                {
                  "lineNumber": 543,
                  "content": "        num_templates = tf.constant(0, dtype=tf.int32)"
                },
                {
                  "lineNumber": 582,
                  "content": "            continue"
                },
                {
                  "lineNumber": 616,
                  "content": "    for rt in residue_constants.restypes:"
                },
                {
                  "lineNumber": 617,
                  "content": "        atom_names = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 618,
                  "content": "            residue_constants.restype_1to3[rt]"
                },
                {
                  "lineNumber": 622,
                  "content": "            [(residue_constants.atom_order[name] if name else 0) for name in atom_names]"
                },
                {
                  "lineNumber": 629,
                  "content": "                for name in residue_constants.atom_types"
                },
                {
                  "lineNumber": 645,
                  "content": "    # with shape (num_res, 14) containing the atom37 indices for this protein"
                },
                {
                  "lineNumber": 658,
                  "content": "    for restype, restype_letter in enumerate(residue_constants.restypes):"
                },
                {
                  "lineNumber": 659,
                  "content": "        restype_name = residue_constants.restype_1to3[restype_letter]"
                },
                {
                  "lineNumber": 660,
                  "content": "        atom_names = residue_constants.residue_atoms[restype_name]"
                },
                {
                  "lineNumber": 662,
                  "content": "            atom_type = residue_constants.atom_order[atom_name]"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/modules_multimer.py",
              "matches": [
                {
                  "lineNumber": 26,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 66,
                  "content": "    uniform = utils.padding_consistent_rng(jax.random.uniform)"
                },
                {
                  "lineNumber": 108,
                  "content": "    # This construction is equivalent to jnp.argsort, but using a non stable sort,"
                },
                {
                  "lineNumber": 116,
                  "content": "def make_masked_msa(batch, key, config, epsilon=1e-6):"
                },
                {
                  "lineNumber": 122,
                  "content": "        config.uniform_prob * random_aa"
                },
                {
                  "lineNumber": 123,
                  "content": "        + config.profile_prob * batch[\"msa_profile\"]"
                },
                {
                  "lineNumber": 124,
                  "content": "        + config.same_prob * jax.nn.one_hot(batch[\"msa\"], 22)"
                },
                {
                  "lineNumber": 130,
                  "content": "    mask_prob = 1.0 - config.profile_prob - config.same_prob - config.uniform_prob"
                },
                {
                  "lineNumber": 133,
                  "content": "        categorical_probs, pad_shapes, constant_values=mask_prob"
                },
                {
                  "lineNumber": 137,
                  "content": "    uniform = utils.padding_consistent_rng(jax.random.uniform)"
                },
                {
                  "lineNumber": 138,
                  "content": "    mask_position = uniform(mask_subkey.get(), sh) &lt; config.replace_fraction"
                },
                {
                  "lineNumber": 204,
                  "content": "    \"\"\"Create and concatenate MSA features.\"\"\""
                },
                {
                  "lineNumber": 222,
                  "content": "    return jnp.concatenate(msa_feat, axis=-1)"
                },
                {
                  "lineNumber": 226,
                  "content": "    \"\"\"Expand extra_msa into 1hot and concat with other extra msa features."
                },
                {
                  "lineNumber": 249,
                  "content": "        jnp.concatenate([msa_1hot, has_deletion, deletion_value], axis=-1),"
                },
                {
                  "lineNumber": 270,
                  "content": "            jnp.zeros(batch[\"msa\"].shape[0] - 1), (1, 0), constant_values=1.0"
                },
                {
                  "lineNumber": 302,
                  "content": "    that have been requested by the configuration file."
                },
                {
                  "lineNumber": 305,
                  "content": "    def __init__(self, config, global_config, name=\"alphafold_iteration\"):"
                },
                {
                  "lineNumber": 307,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 308,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 313,
                  "content": "            num_ensemble = np.asarray(self.config.num_ensemble_train)"
                },
                {
                  "lineNumber": 315,
                  "content": "            num_ensemble = np.asarray(self.config.num_ensemble_eval)"
                },
                {
                  "lineNumber": 319,
                  "content": "            self.config.embeddings_and_evoformer, self.global_config"
                },
                {
                  "lineNumber": 352,
                  "content": "        for head_name, head_config in sorted(self.config.heads.items()):"
                },
                {
                  "lineNumber": 353,
                  "content": "            if not head_config.weight:"
                },
                {
                  "lineNumber": 354,
                  "content": "                continue  # Do not instantiate zero-weight heads."
                },
                {
                  "lineNumber": 365,
                  "content": "                head_config,"
                },
                {
                  "lineNumber": 366,
                  "content": "                head_factory(head_config, self.global_config),"
                },
                {
                  "lineNumber": 377,
                  "content": "        for name, (head_config, module) in self.heads.items():"
                },
                {
                  "lineNumber": 381,
                  "content": "            # Skip confidence heads until StructureModule is executed."
                },
                {
                  "lineNumber": 387,
                  "content": "                continue"
                },
                {
                  "lineNumber": 391,
                  "content": "        # Add confidence heads after StructureModule is executed."
                },
                {
                  "lineNumber": 392,
                  "content": "        if self.config.heads.get(\"predicted_lddt.weight\", 0.0):"
                },
                {
                  "lineNumber": 394,
                  "content": "            head_config, module = self.heads[name]"
                },
                {
                  "lineNumber": 397,
                  "content": "        if self.config.heads.experimentally_resolved.weight:"
                },
                {
                  "lineNumber": 399,
                  "content": "            head_config, module = self.heads[name]"
                },
                {
                  "lineNumber": 402,
                  "content": "        if self.config.heads.get(\"predicted_aligned_error.weight\", 0.0):"
                },
                {
                  "lineNumber": 404,
                  "content": "            head_config, module = self.heads[name]"
                },
                {
                  "lineNumber": 415,
                  "content": "    def __init__(self, config, name=\"alphafold\"):"
                },
                {
                  "lineNumber": 417,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 418,
                  "content": "        self.global_config = config.global_config"
                },
                {
                  "lineNumber": 422,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 423,
                  "content": "        impl = AlphaFoldIteration(c, self.global_config)"
                },
                {
                  "lineNumber": 448,
                  "content": "        emb_config = self.config.embeddings_and_evoformer"
                },
                {
                  "lineNumber": 449,
                  "content": "        if emb_config.recycle_pos:"
                },
                {
                  "lineNumber": 450,
                  "content": "            prev[\"prev_pos\"] = jnp.zeros([num_res, residue_constants.atom_type_num, 3])"
                },
                {
                  "lineNumber": 451,
                  "content": "        if emb_config.recycle_features:"
                },
                {
                  "lineNumber": 452,
                  "content": "            prev[\"prev_msa_first_row\"] = jnp.zeros([num_res, emb_config.msa_channel])"
                },
                {
                  "lineNumber": 453,
                  "content": "            prev[\"prev_pair\"] = jnp.zeros([num_res, num_res, emb_config.pair_channel])"
                },
                {
                  "lineNumber": 455,
                  "content": "        if self.config.num_recycle:"
                },
                {
                  "lineNumber": 462,
                  "content": "                # recyclings than the model is configured to run."
                },
                {
                  "lineNumber": 484,
                  "content": "            def recycle_cond(x):"
                },
                {
                  "lineNumber": 486,
                  "content": "                ca_idx = residue_constants.atom_order[\"CA\"]"
                },
                {
                  "lineNumber": 508,
                  "content": "                    recycle_cond, recycle_body, (0, prev, prev, safe_key)"
                },
                {
                  "lineNumber": 530,
                  "content": "    def __init__(self, config, global_config, name=\"evoformer\"):"
                },
                {
                  "lineNumber": 532,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 533,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 555,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 556,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 606,
                  "content": "        rel_feat = jnp.concatenate(rel_feats, axis=-1)"
                },
                {
                  "lineNumber": 615,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 616,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 628,
                  "content": "        with utils.bfloat16_context():"
                },
                {
                  "lineNumber": 666,
                  "content": "                    prev_pseudo_beta, **self.config.prev_pos"
                },
                {
                  "lineNumber": 765,
                  "content": "                    batch=batch, num_channel=c.msa_channel, global_config=gc"
                },
                {
                  "lineNumber": 768,
                  "content": "                evoformer_input[\"msa\"] = jnp.concatenate("
                },
                {
                  "lineNumber": 771,
                  "content": "                evoformer_masks[\"msa\"] = jnp.concatenate("
                },
                {
                  "lineNumber": 832,
                  "content": "    def __init__(self, config, global_config, name=\"template_embedding\"):"
                },
                {
                  "lineNumber": 834,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 835,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 852,
                  "content": "          template_batch: A dictionary containing:"
                },
                {
                  "lineNumber": 868,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 876,
                  "content": "        template_embedder = SingleTemplateEmbedding(self.config, self.global_config)"
                },
                {
                  "lineNumber": 928,
                  "content": "    def __init__(self, config, global_config, name=\"single_template_embedding\"):"
                },
                {
                  "lineNumber": 930,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 931,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 964,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 965,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 968,
                  "content": "        num_channels = self.config.num_channels"
                },
                {
                  "lineNumber": 970,
                  "content": "        def construct_input("
                },
                {
                  "lineNumber": 985,
                  "content": "                template_positions, **self.config.dgram_features"
                },
                {
                  "lineNumber": 990,
                  "content": "            to_concat = [(template_dgram, 1), (pseudo_beta_mask_2d, 0)]"
                },
                {
                  "lineNumber": 993,
                  "content": "            to_concat.append((aatype[None, :, :], 1))"
                },
                {
                  "lineNumber": 994,
                  "content": "            to_concat.append((aatype[:, None, :], 1))"
                },
                {
                  "lineNumber": 1023,
                  "content": "            to_concat.extend([(x, 0) for x in unit_vector])"
                },
                {
                  "lineNumber": 1024,
                  "content": "            to_concat.append((backbone_mask_2d, 0))"
                },
                {
                  "lineNumber": 1033,
                  "content": "            # contains the position relative feature, so this is how the network knows"
                },
                {
                  "lineNumber": 1035,
                  "content": "            to_concat.append((query_embedding, 1))"
                },
                {
                  "lineNumber": 1039,
                  "content": "            for i, (x, n_input_dims) in enumerate(to_concat):"
                },
                {
                  "lineNumber": 1049,
                  "content": "        act = construct_input("
                },
                {
                  "lineNumber": 1092,
                  "content": "    def __init__(self, config, global_config, name=\"template_embedding_iteration\"):"
                },
                {
                  "lineNumber": 1094,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1095,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1109,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1110,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 1116,
                  "content": "            modules.dropout_wrapper, is_training=is_training, global_config=gc"
                },
                {
                  "lineNumber": 1173,
                  "content": "def template_embedding_1d(batch, num_channel, global_config):"
                },
                {
                  "lineNumber": 1177,
                  "content": "      batch: A batch containing:"
                },
                {
                  "lineNumber": 1184,
                  "content": "      global_config: The global_config."
                },
                {
                  "lineNumber": 1211,
                  "content": "    template_features = jnp.concatenate("
                },
                {
                  "lineNumber": 1223,
                  "content": "    if global_config.bfloat16:"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/r3.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "This Module contains objects for representing Vectors (Vecs), Rotation Matrices"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/quat_affine_test.py",
              "matches": [
                {
                  "lineNumber": 43,
                  "content": "    def test_conversion(self):"
                },
                {
                  "lineNumber": 94,
                  "content": "        q1 = jnp.concatenate([jnp.ones_like(vec_q1)[:, :1], vec_q1], axis=-1)"
                },
                {
                  "lineNumber": 102,
                  "content": "        a21 = a2.pre_compose(jnp.concatenate([vec_q1, t1], axis=-1))"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/tools/utils.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "import contextlib"
                },
                {
                  "lineNumber": 24,
                  "content": "@contextlib.contextmanager"
                },
                {
                  "lineNumber": 34,
                  "content": "@contextlib.contextmanager"
                },
                {
                  "lineNumber": 40,
                  "content": "  logging.info('Finished %s in %.3f seconds', msg, toc - tic)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/tools/kalign.py",
              "matches": [
                {
                  "lineNumber": 58,
                  "content": "            different alignment tree might get constructed."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/tools/jackhmmer.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "from concurrent import futures"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/tools/hmmsearch.py",
              "matches": [
                {
                  "lineNumber": 90,
                  "content": "            msa_sto, model_construction=\"hand\""
                },
                {
                  "lineNumber": 145,
                  "content": "        a3m_string = parsers.convert_stockholm_to_a3m("
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/tools/hmmbuild.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\"\"\"A Python wrapper for hmmbuild - construct HMM profiles from MSA.\"\"\""
                },
                {
                  "lineNumber": 44,
                  "content": "    def build_profile_from_sto(self, sto: str, model_construction=\"fast\") -&gt; str:"
                },
                {
                  "lineNumber": 49,
                  "content": "          model_construction: Whether to use reference annotation in the msa to"
                },
                {
                  "lineNumber": 50,
                  "content": "            determine consensus columns ('hand') or default ('fast')."
                },
                {
                  "lineNumber": 58,
                  "content": "        return self._build_profile(sto, model_construction=model_construction)"
                },
                {
                  "lineNumber": 78,
                  "content": "        return self._build_profile(msa, model_construction=\"fast\")"
                },
                {
                  "lineNumber": 80,
                  "content": "    def _build_profile(self, msa: str, model_construction: str = \"fast\") -&gt; str:"
                },
                {
                  "lineNumber": 85,
                  "content": "          model_construction: Whether to use reference annotation in the msa to"
                },
                {
                  "lineNumber": 86,
                  "content": "            determine consensus columns ('hand') or default ('fast')."
                },
                {
                  "lineNumber": 95,
                  "content": "        if model_construction not in {\"hand\", \"fast\"}:"
                },
                {
                  "lineNumber": 97,
                  "content": "                f\"Invalid model_construction {model_construction} - only\""
                },
                {
                  "lineNumber": 111,
                  "content": "            if model_construction == \"hand\":"
                },
                {
                  "lineNumber": 112,
                  "content": "                cmd.append(f\"--{model_construction}\")"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/templates.py",
              "matches": [
                {
                  "lineNumber": 26,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 44,
                  "content": "    \"\"\"An error indicating that template mmCIF didn't contain the sequence.\"\"\""
                },
                {
                  "lineNumber": 48,
                  "content": "    \"\"\"An error indicating that template mmCIF didn't contain atom positions.\"\"\""
                },
                {
                  "lineNumber": 317,
                  "content": "    In case PDB70 contains a different version of the template sequence, we need"
                },
                {
                  "lineNumber": 323,
                  "content": "    Note that the old_template_sequence comes from the hit, and contains only that"
                },
                {
                  "lineNumber": 446,
                  "content": "    ca_position = residue_constants.atom_order[\"CA\"]"
                },
                {
                  "lineNumber": 481,
                  "content": "    all_positions = np.zeros([num_res, residue_constants.atom_type_num, 3])"
                },
                {
                  "lineNumber": 483,
                  "content": "        [num_res, residue_constants.atom_type_num], dtype=np.int64"
                },
                {
                  "lineNumber": 486,
                  "content": "        pos = np.zeros([residue_constants.atom_type_num, 3], dtype=np.float32)"
                },
                {
                  "lineNumber": 487,
                  "content": "        mask = np.zeros([residue_constants.atom_type_num], dtype=np.float32)"
                },
                {
                  "lineNumber": 501,
                  "content": "                if atom_name in residue_constants.atom_order.keys():"
                },
                {
                  "lineNumber": 502,
                  "content": "                    pos[residue_constants.atom_order[atom_name]] = [x, y, z]"
                },
                {
                  "lineNumber": 503,
                  "content": "                    mask[residue_constants.atom_order[atom_name]] = 1.0"
                },
                {
                  "lineNumber": 506,
                  "content": "                    pos[residue_constants.atom_order[\"SD\"]] = [x, y, z]"
                },
                {
                  "lineNumber": 507,
                  "content": "                    mask[residue_constants.atom_order[\"SD\"]] = 1.0"
                },
                {
                  "lineNumber": 511,
                  "content": "            cd = residue_constants.atom_order[\"CD\"]"
                },
                {
                  "lineNumber": 512,
                  "content": "            nh1 = residue_constants.atom_order[\"NH1\"]"
                },
                {
                  "lineNumber": 513,
                  "content": "            nh2 = residue_constants.atom_order[\"NH2\"]"
                },
                {
                  "lineNumber": 562,
                  "content": "      * A dictionary containing the extra features derived from the template"
                },
                {
                  "lineNumber": 568,
                  "content": "      NoChainsError: If the mmcif object doesn't contain any chains."
                },
                {
                  "lineNumber": 573,
                  "content": "      NoAtomDataInTemplateError: If the mmcif object doesn't contain"
                },
                {
                  "lineNumber": 589,
                  "content": "        # If PDB70 contains a different version of the template, we use the sequence"
                },
                {
                  "lineNumber": 638,
                  "content": "            np.zeros((residue_constants.atom_type_num, 3))"
                },
                {
                  "lineNumber": 640,
                  "content": "        templates_all_atom_masks.append(np.zeros(residue_constants.atom_type_num))"
                },
                {
                  "lineNumber": 663,
                  "content": "    templates_aatype = residue_constants.sequence_to_onehot("
                },
                {
                  "lineNumber": 664,
                  "content": "        output_templates_sequence, residue_constants.HHBLITS_AA_TO_ID"
                },
                {
                  "lineNumber": 688,
                  "content": "    hit_query_sequence and hit_sequence are two aligned sequences containing gap"
                },
                {
                  "lineNumber": 689,
                  "content": "    characters. hit_query_sequence contains only the part of the original query"
                },
                {
                  "lineNumber": 730,
                  "content": "                continue"
                },
                {
                  "lineNumber": 797,
                  "content": "    # remove gaps (which regardless have a missing confidence score)."
                },
                {
                  "lineNumber": 921,
                  "content": "          obsolete_pdbs_path: An optional path to a file containing a mapping from"
                },
                {
                  "lineNumber": 1089,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 1105,
                  "content": "                    (1, num_res, len(residue_constants.restypes_with_x_and_gap)),"
                },
                {
                  "lineNumber": 1109,
                  "content": "                    (1, num_res, residue_constants.atom_type_num), np.float32"
                },
                {
                  "lineNumber": 1112,
                  "content": "                    (1, num_res, residue_constants.atom_type_num, 3), np.float32"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/pipeline_multimer.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "import contextlib"
                },
                {
                  "lineNumber": 28,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 69,
                  "content": "@contextlib.contextmanager"
                },
                {
                  "lineNumber": 77,
                  "content": "def convert_monomer_features("
                },
                {
                  "lineNumber": 81,
                  "content": "    converted = {}"
                },
                {
                  "lineNumber": 82,
                  "content": "    converted[\"auth_chain_id\"] = np.asarray(chain_id, dtype=np.object_)"
                },
                {
                  "lineNumber": 98,
                  "content": "            new_order_list = residue_constants.MAP_HHBLITS_AATYPE_TO_OUR_AATYPE"
                },
                {
                  "lineNumber": 102,
                  "content": "        converted[feature_name] = feature"
                },
                {
                  "lineNumber": 103,
                  "content": "    return converted"
                },
                {
                  "lineNumber": 232,
                  "content": "            # We only construct the pairing features if there are 2 or more unique"
                },
                {
                  "lineNumber": 287,
                  "content": "                continue"
                },
                {
                  "lineNumber": 296,
                  "content": "            chain_features = convert_monomer_features(chain_features, chain_id=chain_id)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/pipeline.py",
              "matches": [
                {
                  "lineNumber": 20,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 41,
                  "content": "    features[\"aatype\"] = residue_constants.sequence_to_onehot("
                },
                {
                  "lineNumber": 43,
                  "content": "        mapping=residue_constants.restype_order_with_x,"
                },
                {
                  "lineNumber": 65,
                  "content": "            raise ValueError(f\"MSA {msa_index} must contain at least one sequence.\")"
                },
                {
                  "lineNumber": 68,
                  "content": "                continue"
                },
                {
                  "lineNumber": 71,
                  "content": "                [residue_constants.HHBLITS_AA_TO_ID[res] for res in sequence]"
                },
                {
                  "lineNumber": 203,
                  "content": "            uniref90_msa_as_a3m = parsers.convert_stockholm_to_a3m(msa_for_templates)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/parsers.py",
              "matches": [
                {
                  "lineNumber": 72,
                  "content": "    fasta_string: The string contents of a FASTA file."
                },
                {
                  "lineNumber": 89,
                  "content": "      continue"
                },
                {
                  "lineNumber": 91,
                  "content": "      continue  # Skip blank lines."
                },
                {
                  "lineNumber": 101,
                  "content": "    stockholm_string: The string contents of a stockholm file. The first"
                },
                {
                  "lineNumber": 107,
                  "content": "        might contain duplicates."
                },
                {
                  "lineNumber": 118,
                  "content": "      continue"
                },
                {
                  "lineNumber": 161,
                  "content": "    a3m_string: The string contents of a a3m file. The first sequence in the"
                },
                {
                  "lineNumber": 167,
                  "content": "        might contain duplicates."
                },
                {
                  "lineNumber": 194,
                  "content": "def _convert_sto_seq_to_a3m("
                },
                {
                  "lineNumber": 203,
                  "content": "def convert_stockholm_to_a3m(stockholm_format: str,"
                },
                {
                  "lineNumber": 219,
                  "content": "          continue"
                },
                {
                  "lineNumber": 231,
                  "content": "        continue"
                },
                {
                  "lineNumber": 233,
                  "content": "        continue"
                },
                {
                  "lineNumber": 249,
                  "content": "          _convert_sto_seq_to_a3m(query_non_gaps, out_sequence))"
                },
                {
                  "lineNumber": 317,
                  "content": "        else:  # Every row contained a hyphen - empty column."
                },
                {
                  "lineNumber": 346,
                  "content": "    # Only consider the alignments - ignore reference annotation, empty lines,"
                },
                {
                  "lineNumber": 362,
                  "content": "      continue"
                },
                {
                  "lineNumber": 422,
                  "content": "        'Could not parse section: %s. Expected this: \\n%s to contain summary.' %"
                },
                {
                  "lineNumber": 492,
                  "content": "  \"\"\"Parses the content of an entire HHR file.\"\"\""
                },
                {
                  "lineNumber": 595,
                  "content": "      continue  # Skip non-protein chains."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/msa_pairing.py",
              "matches": [
                {
                  "lineNumber": 20,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 26,
                  "content": "MSA_GAP_IDX = residue_constants.restypes_with_x_and_gap.index(\"-\")"
                },
                {
                  "lineNumber": 130,
                  "content": "    feats_padded = np.concatenate([feature, padding], axis=0)"
                },
                {
                  "lineNumber": 175,
                  "content": "      this_species_msa_dfs: a list of dataframes containing MSA features for"
                },
                {
                  "lineNumber": 179,
                  "content": "     A list of lists, each containing M indices corresponding to paired MSA rows,"
                },
                {
                  "lineNumber": 226,
                  "content": "            continue"
                },
                {
                  "lineNumber": 238,
                  "content": "            continue"
                },
                {
                  "lineNumber": 250,
                  "content": "            continue"
                },
                {
                  "lineNumber": 270,
                  "content": "      a list of lists, each containing indices of paired MSA rows across chains."
                },
                {
                  "lineNumber": 318,
                  "content": "        np_example[\"cluster_bias_mask\"] = np.concatenate(cluster_bias_masks)"
                },
                {
                  "lineNumber": 335,
                  "content": "        msa_mask_all_seq = np.concatenate(msa_masks_all_seq, axis=1)"
                },
                {
                  "lineNumber": 336,
                  "content": "        np_example[\"bert_mask\"] = np.concatenate("
                },
                {
                  "lineNumber": 361,
                  "content": "                chain[k] = np.pad(v, padding, mode=\"constant\")"
                },
                {
                  "lineNumber": 372,
                  "content": "      pair_msa_sequences: Whether to concatenate MSA features along the"
                },
                {
                  "lineNumber": 384,
                  "content": "                merged_example[feature_name] = np.concatenate(feats, axis=1)"
                },
                {
                  "lineNumber": 390,
                  "content": "            merged_example[feature_name] = np.concatenate(feats, axis=0)"
                },
                {
                  "lineNumber": 392,
                  "content": "            merged_example[feature_name] = np.concatenate(feats, axis=1)"
                },
                {
                  "lineNumber": 410,
                  "content": "      will be merged - MSA features will be concatenated along the num_res"
                },
                {
                  "lineNumber": 429,
                  "content": "def _concatenate_paired_and_unpaired_features("
                },
                {
                  "lineNumber": 438,
                  "content": "            merged_feat = np.concatenate([feat_all_seq, feat], axis=0)"
                },
                {
                  "lineNumber": 462,
                  "content": "    # features will be concatenated."
                },
                {
                  "lineNumber": 467,
                  "content": "        np_example = _concatenate_paired_and_unpaired_features(np_example)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/mmcif_parsing.py",
              "matches": [
                {
                  "lineNumber": 23,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 81,
                  "content": "      seqres_to_structure: Dict; for each chain_id contains a mapping between"
                },
                {
                  "lineNumber": 85,
                  "content": "      raw_string: The raw string used to construct the MmcifObject."
                },
                {
                  "lineNumber": 192,
                  "content": "        # Extract the _mmcif_dict from the parser, which contains useful fields not"
                },
                {
                  "lineNumber": 224,
                  "content": "                continue"
                },
                {
                  "lineNumber": 271,
                  "content": "                code = residue_constants.CCD_NAME_TO_ONE_LETTER.get(monomer.id, \"X\")"
                },
                {
                  "lineNumber": 308,
                  "content": "    \"\"\"Returns a basic header containing method, release date and resolution.\"\"\""
                },
                {
                  "lineNumber": 328,
                  "content": "        \"_em_3d_reconstruction.resolution\","
                },
                {
                  "lineNumber": 343,
                  "content": "    \"\"\"Returns list of atom sites; contains data not present in the structure.\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/data/feature_processing.py",
              "matches": [
                {
                  "lineNumber": 19,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 67,
                  "content": "            np.concatenate("
                },
                {
                  "lineNumber": 161,
                  "content": "        # the MSA size for each chain roughly constant."
                },
                {
                  "lineNumber": 210,
                  "content": "    \"\"\"Correct MSA restype to have the same order as residue_constants.\"\"\""
                },
                {
                  "lineNumber": 211,
                  "content": "    new_order_list = residue_constants.MAP_HHBLITS_AATYPE_TO_OUR_AATYPE"
                },
                {
                  "lineNumber": 258,
                  "content": "        all_atom_mask = residue_constants.STANDARD_ATOM_MASK[chain_features[\"aatype\"]]"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/protein.py",
              "matches": [
                {
                  "lineNumber": 23,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 69,
                  "content": "    # residue_constants.atom_types, i.e. the first three are N, CA, CB."
                },
                {
                  "lineNumber": 80,
                  "content": "    # Residue index as used in PDB. It is not necessarily continuous or 0-indexed."
                },
                {
                  "lineNumber": 105,
                  "content": "    WARNING: All non-standard residue types will be converted into UNK. All"
                },
                {
                  "lineNumber": 114,
                  "content": "      A new &#96;Protein&#96; created from the structure contents."
                },
                {
                  "lineNumber": 137,
                  "content": "            continue"
                },
                {
                  "lineNumber": 141,
                  "content": "                    f\"PDB/mmCIF contains an insertion code at chain {chain.id} and\""
                },
                {
                  "lineNumber": 144,
                  "content": "            res_shortname = residue_constants.restype_3to1.get(res.resname, \"X\")"
                },
                {
                  "lineNumber": 145,
                  "content": "            restype_idx = residue_constants.restype_order.get("
                },
                {
                  "lineNumber": 146,
                  "content": "                res_shortname, residue_constants.restype_num"
                },
                {
                  "lineNumber": 148,
                  "content": "            pos = np.zeros((residue_constants.atom_type_num, 3))"
                },
                {
                  "lineNumber": 149,
                  "content": "            mask = np.zeros((residue_constants.atom_type_num,))"
                },
                {
                  "lineNumber": 150,
                  "content": "            res_b_factors = np.zeros((residue_constants.atom_type_num,))"
                },
                {
                  "lineNumber": 152,
                  "content": "                if atom.name not in residue_constants.atom_types:"
                },
                {
                  "lineNumber": 153,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 154,
                  "content": "                pos[residue_constants.atom_order[atom.name]] = atom.coord"
                },
                {
                  "lineNumber": 155,
                  "content": "                mask[residue_constants.atom_order[atom.name]] = 1.0"
                },
                {
                  "lineNumber": 156,
                  "content": "                res_b_factors[residue_constants.atom_order[atom.name]] = atom.bfactor"
                },
                {
                  "lineNumber": 159,
                  "content": "                continue"
                },
                {
                  "lineNumber": 183,
                  "content": "    \"\"\"Takes a PDB string and constructs a &#96;Protein&#96; object."
                },
                {
                  "lineNumber": 185,
                  "content": "    WARNING: All non-standard residue types will be converted into UNK. All"
                },
                {
                  "lineNumber": 189,
                  "content": "      pdb_str: The contents of the pdb file"
                },
                {
                  "lineNumber": 194,
                  "content": "      A new &#96;Protein&#96; parsed from the pdb contents."
                },
                {
                  "lineNumber": 203,
                  "content": "    \"\"\"Takes a mmCIF string and constructs a &#96;Protein&#96; object."
                },
                {
                  "lineNumber": 205,
                  "content": "    WARNING: All non-standard residue types will be converted into UNK. All"
                },
                {
                  "lineNumber": 209,
                  "content": "      mmcif_str: The contents of the mmCIF file"
                },
                {
                  "lineNumber": 214,
                  "content": "      A new &#96;Protein&#96; parsed from the mmCIF contents."
                },
                {
                  "lineNumber": 234,
                  "content": "      prot: The protein to convert to PDB."
                },
                {
                  "lineNumber": 239,
                  "content": "    restypes = residue_constants.restypes + [\"X\"]"
                },
                {
                  "lineNumber": 240,
                  "content": "    res_1to3 = lambda r: residue_constants.restype_1to3.get(restypes[r], \"UNK\")"
                },
                {
                  "lineNumber": 241,
                  "content": "    atom_types = residue_constants.atom_types"
                },
                {
                  "lineNumber": 252,
                  "content": "    if np.any(aatype &gt; residue_constants.restype_num):"
                },
                {
                  "lineNumber": 287,
                  "content": "                continue"
                },
                {
                  "lineNumber": 338,
                  "content": "    return residue_constants.STANDARD_ATOM_MASK[prot.aatype]"
                },
                {
                  "lineNumber": 402,
                  "content": "      mmCIF using this method will convert all non-standard residue types to UNK."
                },
                {
                  "lineNumber": 413,
                  "content": "      prot: A protein to convert to mmCIF string."
                },
                {
                  "lineNumber": 421,
                  "content": "      ValueError: If aminoacid types array contains entries with too many protein"
                },
                {
                  "lineNumber": 451,
                  "content": "        mmcif_dict[\"_entity_poly.type\"].append(residue_constants.PROTEIN_CHAIN)"
                },
                {
                  "lineNumber": 455,
                  "content": "        mmcif_dict[\"_entity.type\"].append(residue_constants.POLYMER_CHAIN)"
                },
                {
                  "lineNumber": 464,
                  "content": "            mmcif_dict[\"_entity_poly_seq.mon_id\"].append(residue_constants.resnames[aa])"
                },
                {
                  "lineNumber": 476,
                  "content": "        res_name_3 = residue_constants.resnames[aatype[i]]"
                },
                {
                  "lineNumber": 477,
                  "content": "        if aatype[i] &lt;= len(residue_constants.restypes):"
                },
                {
                  "lineNumber": 478,
                  "content": "            atom_names = residue_constants.atom_types"
                },
                {
                  "lineNumber": 481,
                  "content": "                \"Amino acid types array contains entries with too many protein types.\""
                },
                {
                  "lineNumber": 487,
                  "content": "                continue"
                },
                {
                  "lineNumber": 488,
                  "content": "            type_symbol = residue_constants.atom_id_to_type(atom_name)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/mmcif_metadata.py",
              "matches": [
                {
                  "lineNumber": 78,
                  "content": "  # ModelCIF conformation dictionary."
                },
                {
                  "lineNumber": 79,
                  "content": "  cif['_audit_conform.dict_name'] = ['mmcif_ma.dic']"
                },
                {
                  "lineNumber": 80,
                  "content": "  cif['_audit_conform.dict_version'] = ['1.3.9']"
                },
                {
                  "lineNumber": 81,
                  "content": "  cif['_audit_conform.dict_location'] = ["
                },
                {
                  "lineNumber": 82,
                  "content": "      'https://raw.githubusercontent.com/ihmwg/ModelCIF/master/dist/'"
                },
                {
                  "lineNumber": 136,
                  "content": "  cif['_ma_data.content_type'] = ['model coordinates']"
                },
                {
                  "lineNumber": 184,
                  "content": "  # Method description to conform with ModelCIF."
                },
                {
                  "lineNumber": 194,
                  "content": "  # Details of the metrics use to assess model confidence."
                },
                {
                  "lineNumber": 202,
                  "content": "  # Global model confidence metric value."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/confidence_test.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\"\"\"Test confidence metrics.\"\"\""
                },
                {
                  "lineNumber": 19,
                  "content": "from mber.models.alphafold.common import confidence"
                },
                {
                  "lineNumber": 27,
                  "content": "        pae_json = confidence.pae_json(pae=pae, max_pae=31.75)"
                },
                {
                  "lineNumber": 34,
                  "content": "    def test_confidence_json(self):"
                },
                {
                  "lineNumber": 37,
                  "content": "        confidence_json = confidence.confidence_json(plddt=plddt)"
                },
                {
                  "lineNumber": 39,
                  "content": "        print(confidence_json)"
                },
                {
                  "lineNumber": 42,
                  "content": "            confidence_json,"
                },
                {
                  "lineNumber": 45,
                  "content": "                '\"confidenceScore\":[42.0,42.42],'"
                },
                {
                  "lineNumber": 46,
                  "content": "                '\"confidenceCategory\":[\"D\",\"D\"]}'"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/__init__.py",
              "matches": [
                {
                  "lineNumber": 14,
                  "content": "\"\"\"Common data types and constants used within Alphafold.\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/confidence.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\"\"\"Functions for processing confidence metrics.\"\"\""
                },
                {
                  "lineNumber": 41,
                  "content": "def _confidence_category(score: float) -&gt; str:"
                },
                {
                  "lineNumber": 55,
                  "content": "def confidence_json(plddt: np.ndarray) -&gt; str:"
                },
                {
                  "lineNumber": 56,
                  "content": "  \"\"\"Returns JSON with confidence score and category for every residue."
                },
                {
                  "lineNumber": 59,
                  "content": "    plddt: Per-residue confidence metric data."
                },
                {
                  "lineNumber": 70,
                  "content": "  confidence = {"
                },
                {
                  "lineNumber": 72,
                  "content": "      'confidenceScore': [round(float(s), 2) for s in plddt],"
                },
                {
                  "lineNumber": 73,
                  "content": "      'confidenceCategory': [_confidence_category(s) for s in plddt],"
                },
                {
                  "lineNumber": 75,
                  "content": "  return json.dumps(confidence, indent=None, separators=(',', ':'))"
                },
                {
                  "lineNumber": 92,
                  "content": "  bin_centers = np.concatenate([bin_centers, [bin_centers[-1] + step]],"
                },
                {
                  "lineNumber": 98,
                  "content": "    alignment_confidence_breaks: np.ndarray,"
                },
                {
                  "lineNumber": 103,
                  "content": "    alignment_confidence_breaks: [num_bins - 1] the error bin edges."
                },
                {
                  "lineNumber": 112,
                  "content": "  bin_centers = _calculate_bin_centers(alignment_confidence_breaks)"
                },
                {
                  "lineNumber": 122,
                  "content": "  \"\"\"Computes aligned confidence metrics from logits."
                },
                {
                  "lineNumber": 130,
                  "content": "    aligned_confidence_probs: [num_res, num_res, num_bins] the predicted"
                },
                {
                  "lineNumber": 136,
                  "content": "  aligned_confidence_probs = scipy.special.softmax("
                },
                {
                  "lineNumber": 141,
                  "content": "          alignment_confidence_breaks=breaks,"
                },
                {
                  "lineNumber": 142,
                  "content": "          aligned_distance_error_probs=aligned_confidence_probs))"
                },
                {
                  "lineNumber": 144,
                  "content": "      'aligned_confidence_probs': aligned_confidence_probs,"
                },
                {
                  "lineNumber": 181,
                  "content": "    interface: bool = False) -&gt; np.ndarray:"
                },
                {
                  "lineNumber": 182,
                  "content": "  \"\"\"Computes predicted TM alignment or predicted interface TM alignment score."
                },
                {
                  "lineNumber": 191,
                  "content": "      ipTM calculation, i.e. when interface=True."
                },
                {
                  "lineNumber": 192,
                  "content": "    interface: If True, interface predicted TM score is computed."
                },
                {
                  "lineNumber": 223,
                  "content": "  if interface:"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/residue_constants.py",
              "matches": [
                {
                  "lineNumber": 28,
                  "content": "# Distance from one CA to next CA [trans configuration: omega = 180]."
                },
                {
                  "lineNumber": 31,
                  "content": "# Format: The list for each AA type contains chi1, chi2, chi3, chi4 in"
                },
                {
                  "lineNumber": 337,
                  "content": "# A list of atoms (excluding hydrogen) for each AA type. PDB naming convention."
                },
                {
                  "lineNumber": 367,
                  "content": "# in LEU, VAL and ARG can be resolved by using the 3d constellations of"
                },
                {
                  "lineNumber": 482,
                  "content": "# (second element)."
                },
                {
                  "lineNumber": 557,
                  "content": "      mapped to the unknown amino acid 'X'. If the mapping doesn't contain"
                },
                {
                  "lineNumber": 566,
                  "content": "    ValueError: If the mapping doesn't contain values from 0 to"
                },
                {
                  "lineNumber": 621,
                  "content": "    atom_id: Atom ID to be converted."
                },
                {
                  "lineNumber": 644,
                  "content": "# 1-to-1 mapping of 3 letter names to one letter names. The latter contains"
                },
                {
                  "lineNumber": 656,
                  "content": "# The mapping here uses hhblits convention, so that B is mapped to D, J and O"
                },
                {
                  "lineNumber": 741,
                  "content": "# A one hot representation for the first and second atoms defining the axis"
                },
                {
                  "lineNumber": 797,
                  "content": "  m = np.concatenate([m, [[0., 0., 0., 1.]]], axis=0)"
                },
                {
                  "lineNumber": 814,
                  "content": "def _make_rigid_group_constants():"
                },
                {
                  "lineNumber": 882,
                  "content": "_make_rigid_group_constants()"
                },
                {
                  "lineNumber": 899,
                  "content": "        continue"
                },
                {
                  "lineNumber": 903,
                  "content": "          continue"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/lddt.py",
              "matches": [
                {
                  "lineNumber": 48,
                  "content": "      residues have more contacts than others."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/residue_constants_test.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\"\"\"Test that residue_constants generates correct values.\"\"\""
                },
                {
                  "lineNumber": 19,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 34,
                  "content": "        chi_angles_atoms = residue_constants.chi_angles_atoms[residue_name]"
                },
                {
                  "lineNumber": 40,
                  "content": "        for k, chi_groups in residue_constants.chi_groups_for_atom.items():"
                },
                {
                  "lineNumber": 45,
                  "content": "                    residue_constants.chi_angles_atoms[res_name][chi_group_i][atom_i],"
                },
                {
                  "lineNumber": 71,
                  "content": "        residue_atoms = residue_constants.residue_atoms[atom_name]"
                },
                {
                  "lineNumber": 77,
                  "content": "                residue_constants.STANDARD_ATOM_MASK.shape,"
                },
                {
                  "lineNumber": 85,
                  "content": "            str_to_row = lambda s: [c == \"1\" for c in s]  # More clear/concise."
                },
                {
                  "lineNumber": 87,
                  "content": "                residue_constants.STANDARD_ATOM_MASK,"
                },
                {
                  "lineNumber": 118,
                  "content": "            for row, restype in enumerate(residue_constants.restypes):  # A, R, ..."
                },
                {
                  "lineNumber": 119,
                  "content": "                long_restype = residue_constants.restype_1to3[restype]  # ALA, ARG, ..."
                },
                {
                  "lineNumber": 120,
                  "content": "                atoms_names = residue_constants.residue_atoms["
                },
                {
                  "lineNumber": 125,
                  "content": "                    residue_constants.STANDARD_ATOM_MASK[row, :].sum(),"
                },
                {
                  "lineNumber": 130,
                  "content": "        self.assertEqual(residue_constants.atom_type_num, 37)"
                },
                {
                  "lineNumber": 132,
                  "content": "        self.assertEqual(residue_constants.atom_types[0], \"N\")"
                },
                {
                  "lineNumber": 133,
                  "content": "        self.assertEqual(residue_constants.atom_types[1], \"CA\")"
                },
                {
                  "lineNumber": 134,
                  "content": "        self.assertEqual(residue_constants.atom_types[2], \"C\")"
                },
                {
                  "lineNumber": 135,
                  "content": "        self.assertEqual(residue_constants.atom_types[3], \"CB\")"
                },
                {
                  "lineNumber": 136,
                  "content": "        self.assertEqual(residue_constants.atom_types[4], \"O\")"
                },
                {
                  "lineNumber": 138,
                  "content": "        self.assertEqual(residue_constants.atom_order[\"N\"], 0)"
                },
                {
                  "lineNumber": 139,
                  "content": "        self.assertEqual(residue_constants.atom_order[\"CA\"], 1)"
                },
                {
                  "lineNumber": 140,
                  "content": "        self.assertEqual(residue_constants.atom_order[\"C\"], 2)"
                },
                {
                  "lineNumber": 141,
                  "content": "        self.assertEqual(residue_constants.atom_order[\"CB\"], 3)"
                },
                {
                  "lineNumber": 142,
                  "content": "        self.assertEqual(residue_constants.atom_order[\"O\"], 4)"
                },
                {
                  "lineNumber": 143,
                  "content": "        self.assertEqual(residue_constants.atom_type_num, 37)"
                },
                {
                  "lineNumber": 147,
                  "content": "            residue_constants.restype_1to3[r] for r in residue_constants.restypes"
                },
                {
                  "lineNumber": 150,
                  "content": "            three_letter_restypes, sorted(residue_constants.restype_1to3.values())"
                },
                {
                  "lineNumber": 153,
                  "content": "        self.assertEqual(residue_constants.restype_num, 20)"
                },
                {
                  "lineNumber": 156,
                  "content": "        one_hot = residue_constants.sequence_to_onehot("
                },
                {
                  "lineNumber": 157,
                  "content": "            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ-\", residue_constants.HHBLITS_AA_TO_ID"
                },
                {
                  "lineNumber": 193,
                  "content": "        one_hot = residue_constants.sequence_to_onehot("
                },
                {
                  "lineNumber": 194,
                  "content": "            \"ARNDCQEGHILKMFPSTWYV\", residue_constants.restype_order"
                },
                {
                  "lineNumber": 232,
                  "content": "        aa_types = residue_constants.sequence_to_onehot("
                },
                {
                  "lineNumber": 234,
                  "content": "            mapping=residue_constants.restype_order_with_x,"
                },
                {
                  "lineNumber": 247,
                  "content": "            residue_constants.sequence_to_onehot("
                },
                {
                  "lineNumber": 249,
                  "content": "                mapping=residue_constants.restype_order_with_x,"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/common/protein_test.py",
              "matches": [
                {
                  "lineNumber": 22,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 34,
                  "content": "        num_atoms = residue_constants.atom_type_num"
                },
                {
                  "lineNumber": 75,
                  "content": "        self.assertLessEqual(prot.aatype.max(), residue_constants.restype_num)"
                },
                {
                  "lineNumber": 84,
                  "content": "        pdb_string_reconstr = protein.to_pdb(prot)"
                },
                {
                  "lineNumber": 86,
                  "content": "        for line in pdb_string_reconstr.splitlines():"
                },
                {
                  "lineNumber": 89,
                  "content": "        prot_reconstr = protein.from_pdb_string(pdb_string_reconstr)"
                },
                {
                  "lineNumber": 91,
                  "content": "        np.testing.assert_array_equal(prot_reconstr.aatype, prot.aatype)"
                },
                {
                  "lineNumber": 93,
                  "content": "            prot_reconstr.atom_positions, prot.atom_positions"
                },
                {
                  "lineNumber": 95,
                  "content": "        np.testing.assert_array_almost_equal(prot_reconstr.atom_mask, prot.atom_mask)"
                },
                {
                  "lineNumber": 96,
                  "content": "        np.testing.assert_array_equal(prot_reconstr.residue_index, prot.residue_index)"
                },
                {
                  "lineNumber": 97,
                  "content": "        np.testing.assert_array_equal(prot_reconstr.chain_index, prot.chain_index)"
                },
                {
                  "lineNumber": 98,
                  "content": "        np.testing.assert_array_almost_equal(prot_reconstr.b_factors, prot.b_factors)"
                },
                {
                  "lineNumber": 117,
                  "content": "        prot_reconstr = protein.from_mmcif_string(mmcif_string)"
                },
                {
                  "lineNumber": 119,
                  "content": "        np.testing.assert_array_equal(prot_reconstr.aatype, prot.aatype)"
                },
                {
                  "lineNumber": 121,
                  "content": "            prot_reconstr.atom_positions, prot.atom_positions"
                },
                {
                  "lineNumber": 123,
                  "content": "        np.testing.assert_array_almost_equal(prot_reconstr.atom_mask, prot.atom_mask)"
                },
                {
                  "lineNumber": 124,
                  "content": "        np.testing.assert_array_equal(prot_reconstr.residue_index, prot.residue_index)"
                },
                {
                  "lineNumber": 125,
                  "content": "        np.testing.assert_array_equal(prot_reconstr.chain_index, prot.chain_index)"
                },
                {
                  "lineNumber": 126,
                  "content": "        np.testing.assert_array_almost_equal(prot_reconstr.b_factors, prot.b_factors)"
                },
                {
                  "lineNumber": 144,
                  "content": "        num_atom_type = residue_constants.atom_type_num"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/layer_stack_test.py",
              "matches": [
                {
                  "lineNumber": 301,
                  "content": "    def test_with_container_state(self):"
                },
                {
                  "lineNumber": 306,
                  "content": "        def f_with_container_state(x):"
                },
                {
                  "lineNumber": 319,
                  "content": "                f_with_container_state"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/config.py",
              "matches": [
                {
                  "lineNumber": 14,
                  "content": "\"\"\"Model config.\"\"\""
                },
                {
                  "lineNumber": 26,
                  "content": "def model_config(name: str) -&gt; ml_collections.ConfigDict:"
                },
                {
                  "lineNumber": 374,
                  "content": "            \"global_config\": {"
                },
                {
                  "lineNumber": 598,
                  "content": "            \"global_config\": {"
                },
                {
                  "lineNumber": 644,
                  "content": "                    \"interface_fape\": {"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/layer_stack.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "import contextlib"
                },
                {
                  "lineNumber": 47,
                  "content": "@contextlib.contextmanager"
                },
                {
                  "lineNumber": 48,
                  "content": "def nullcontext():"
                },
                {
                  "lineNumber": 56,
                  "content": "    return nullcontext()"
                },
                {
                  "lineNumber": 84,
                  "content": "      def creator(next_creator, shape, dtype, init, context):"
                },
                {
                  "lineNumber": 85,
                  "content": "        del context"
                },
                {
                  "lineNumber": 91,
                  "content": "          def rng_context_init(slice_idx):"
                },
                {
                  "lineNumber": 96,
                  "content": "          return jax.vmap(rng_context_init)(jnp.arange(count))"
                },
                {
                  "lineNumber": 100,
                  "content": "      def getter(next_getter, value, context):"
                },
                {
                  "lineNumber": 101,
                  "content": "        trailing_dims = len(context.original_shape) + 1"
                },
                {
                  "lineNumber": 131,
                  "content": "        def getter(next_getter, value, context):"
                },
                {
                  "lineNumber": 133,
                  "content": "          trailing_dims = len(context.original_shape) + 1"
                },
                {
                  "lineNumber": 248,
                  "content": "    name: Name of the Haiku context."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/all_atom_multimer.py",
              "matches": [
                {
                  "lineNumber": 18,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 35,
                  "content": "      in the order specified in residue_constants.restypes + unknown residue type"
                },
                {
                  "lineNumber": 40,
                  "content": "    for residue_name in residue_constants.restypes:"
                },
                {
                  "lineNumber": 41,
                  "content": "        residue_name = residue_constants.restype_1to3[residue_name]"
                },
                {
                  "lineNumber": 42,
                  "content": "        residue_chi_angles = residue_constants.chi_angles_atoms[residue_name]"
                },
                {
                  "lineNumber": 46,
                  "content": "                [residue_constants.atom_order[atom] for atom in chi_angle]"
                },
                {
                  "lineNumber": 62,
                  "content": "        residue_constants.restype_1to3[res] for res in residue_constants.restypes"
                },
                {
                  "lineNumber": 67,
                  "content": "    for resname, swap in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 70,
                  "content": "            source_index = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 73,
                  "content": "            target_index = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 90,
                  "content": "    for restype, restype_letter in enumerate(residue_constants.restypes):"
                },
                {
                  "lineNumber": 91,
                  "content": "        restype_name = residue_constants.restype_1to3[restype_letter]"
                },
                {
                  "lineNumber": 92,
                  "content": "        atom_names = residue_constants.residue_atoms[restype_name]"
                },
                {
                  "lineNumber": 94,
                  "content": "            atom_type = residue_constants.atom_order[atom_name]"
                },
                {
                  "lineNumber": 103,
                  "content": "    for rt in residue_constants.restypes:"
                },
                {
                  "lineNumber": 104,
                  "content": "        atom_names = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 105,
                  "content": "            residue_constants.restype_1to3[rt]"
                },
                {
                  "lineNumber": 117,
                  "content": "    for rt in residue_constants.restypes:"
                },
                {
                  "lineNumber": 118,
                  "content": "        atom_names = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 119,
                  "content": "            residue_constants.restype_1to3[rt]"
                },
                {
                  "lineNumber": 125,
                  "content": "                for name in residue_constants.atom_types"
                },
                {
                  "lineNumber": 137,
                  "content": "    for rt in residue_constants.restypes:"
                },
                {
                  "lineNumber": 138,
                  "content": "        atom_names = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 139,
                  "content": "            residue_constants.restype_1to3[rt]"
                },
                {
                  "lineNumber": 142,
                  "content": "            [(residue_constants.atom_order[name] if name else 0) for name in atom_names]"
                },
                {
                  "lineNumber": 154,
                  "content": "    for resname, swap in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 156,
                  "content": "            restype = residue_constants.restype_order["
                },
                {
                  "lineNumber": 157,
                  "content": "                residue_constants.restype_3to1[resname]"
                },
                {
                  "lineNumber": 159,
                  "content": "            atom_idx1 = residue_constants.restype_name_to_atom14_names[resname].index("
                },
                {
                  "lineNumber": 162,
                  "content": "            atom_idx2 = residue_constants.restype_name_to_atom14_names[resname].index("
                },
                {
                  "lineNumber": 184,
                  "content": "    for restype, restype_letter in enumerate(residue_constants.restypes):"
                },
                {
                  "lineNumber": 185,
                  "content": "        resname = residue_constants.restype_1to3[restype_letter]"
                },
                {
                  "lineNumber": 187,
                  "content": "            if residue_constants.chi_angles_mask[restype][chi_idx]:"
                },
                {
                  "lineNumber": 188,
                  "content": "                atom_names = residue_constants.chi_angles_atoms[resname][chi_idx]"
                },
                {
                  "lineNumber": 192,
                  "content": "    lookuptable = residue_constants.atom_order.copy()"
                },
                {
                  "lineNumber": 213,
                  "content": "RESTYPE_RIGIDGROUP_MASK[:20, 4:] = residue_constants.chi_angles_mask"
                },
                {
                  "lineNumber": 345,
                  "content": "    # Adapt backbone frame to old convention (mirror x-axis and z-axis)."
                },
                {
                  "lineNumber": 356,
                  "content": "    for resname, _ in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 357,
                  "content": "        restype = residue_constants.restype_order["
                },
                {
                  "lineNumber": 358,
                  "content": "            residue_constants.restype_3to1[resname]"
                },
                {
                  "lineNumber": 360,
                  "content": "        chi_idx = int(sum(residue_constants.chi_angles_mask[restype]) - 1)"
                },
                {
                  "lineNumber": 420,
                  "content": "        residue_constants.restype_rigid_group_default_frame, aatype"
                },
                {
                  "lineNumber": 431,
                  "content": "    sin_angles = jnp.concatenate([jnp.zeros([num_residues, 1]), sin_angles], axis=-1)"
                },
                {
                  "lineNumber": 432,
                  "content": "    cos_angles = jnp.concatenate([jnp.ones([num_residues, 1]), cos_angles], axis=-1)"
                },
                {
                  "lineNumber": 461,
                  "content": "        lambda *x: jnp.concatenate(x, axis=-1),"
                },
                {
                  "lineNumber": 482,
                  "content": "        residue_constants.restype_atom14_to_rigid_group, aatype"
                },
                {
                  "lineNumber": 495,
                  "content": "            residue_constants.restype_atom14_rigid_group_positions, aatype"
                },
                {
                  "lineNumber": 504,
                  "content": "    mask = utils.batched_gather(residue_constants.restype_atom14_mask, aatype)"
                },
                {
                  "lineNumber": 525,
                  "content": "    violations = (ca_ca_distance - residue_constants.ca_ca) &gt; max_angstrom_tolerance"
                },
                {
                  "lineNumber": 561,
                  "content": "    next_is_proline = (aatype[1:] == residue_constants.restype_order[\"P\"]).astype("
                },
                {
                  "lineNumber": 564,
                  "content": "    gt_length = (1.0 - next_is_proline) * residue_constants.between_res_bond_length_c_n["
                },
                {
                  "lineNumber": 566,
                  "content": "    ] + next_is_proline * residue_constants.between_res_bond_length_c_n[1]"
                },
                {
                  "lineNumber": 569,
                  "content": "    ) * residue_constants.between_res_bond_length_stddev_c_n["
                },
                {
                  "lineNumber": 571,
                  "content": "    ] + next_is_proline * residue_constants.between_res_bond_length_stddev_c_n["
                },
                {
                  "lineNumber": 590,
                  "content": "    gt_angle = residue_constants.between_res_cos_angles_ca_c_n[0]"
                },
                {
                  "lineNumber": 591,
                  "content": "    gt_stddev = residue_constants.between_res_bond_length_stddev_c_n[0]"
                },
                {
                  "lineNumber": 603,
                  "content": "    gt_angle = residue_constants.between_res_cos_angles_c_n_ca[0]"
                },
                {
                  "lineNumber": 604,
                  "content": "    gt_stddev = residue_constants.between_res_cos_angles_c_n_ca[1]"
                },
                {
                  "lineNumber": 687,
                  "content": "    cys_sg_idx = residue_constants.restype_name_to_atom14_names[\"CYS\"].index(\"SG\")"
                },
                {
                  "lineNumber": 924,
                  "content": "      in the order specified in residue_constants.restypes + unknown residue type"
                },
                {
                  "lineNumber": 929,
                  "content": "    for residue_name in residue_constants.restypes:"
                },
                {
                  "lineNumber": 930,
                  "content": "        residue_name = residue_constants.restype_1to3[residue_name]"
                },
                {
                  "lineNumber": 931,
                  "content": "        residue_chi_angles = residue_constants.chi_angles_atoms[residue_name]"
                },
                {
                  "lineNumber": 935,
                  "content": "                [residue_constants.atom_order[atom] for atom in chi_angle]"
                },
                {
                  "lineNumber": 953,
                  "content": "        [num_res, residue_constants.atom_type_num], with positions of"
                },
                {
                  "lineNumber": 956,
                  "content": "        [num_res, residue_constants.atom_type_num] that masks which atom"
                },
                {
                  "lineNumber": 974,
                  "content": "    assert positions.shape[-1] == residue_constants.atom_type_num"
                },
                {
                  "lineNumber": 975,
                  "content": "    assert mask.shape[-1] == residue_constants.atom_type_num"
                },
                {
                  "lineNumber": 993,
                  "content": "    chi_angles_mask = list(residue_constants.chi_angles_mask)"
                },
                {
                  "lineNumber": 1014,
                  "content": "    \"\"\"Returns rotation and translation matrices to convert from reference."
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/geometry/struct_of_array.py",
              "matches": [
                {
                  "lineNumber": 86,
                  "content": "  # These slightly weird constructions about checking whether the leaves are"
                },
                {
                  "lineNumber": 88,
                  "content": "  # construct pytree's with object() as leaves, this would break the checking"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/geometry/rotation_matrix.py",
              "matches": [
                {
                  "lineNumber": 93,
                  "content": "        Rot3Array is constructed such that in the corresponding frame 'e0' lies on"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/all_atom.py",
              "matches": [
                {
                  "lineNumber": 29,
                  "content": "The order of slots can be found in 'residue_constants.residue_atoms'."
                },
                {
                  "lineNumber": 33,
                  "content": "the network to facilitate easier conversion to existing protein datastructures."
                },
                {
                  "lineNumber": 37,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 55,
                  "content": "      in the order specified in residue_constants.restypes + unknown residue type"
                },
                {
                  "lineNumber": 60,
                  "content": "    for residue_name in residue_constants.restypes:"
                },
                {
                  "lineNumber": 61,
                  "content": "        residue_name = residue_constants.restype_1to3[residue_name]"
                },
                {
                  "lineNumber": 62,
                  "content": "        residue_chi_angles = residue_constants.chi_angles_atoms[residue_name]"
                },
                {
                  "lineNumber": 66,
                  "content": "                [residue_constants.atom_order[atom] for atom in chi_angle]"
                },
                {
                  "lineNumber": 131,
                  "content": "      Dictionary containing:"
                },
                {
                  "lineNumber": 169,
                  "content": "    for restype, restype_letter in enumerate(residue_constants.restypes):"
                },
                {
                  "lineNumber": 170,
                  "content": "        resname = residue_constants.restype_1to3[restype_letter]"
                },
                {
                  "lineNumber": 172,
                  "content": "            if residue_constants.chi_angles_mask[restype][chi_idx]:"
                },
                {
                  "lineNumber": 173,
                  "content": "                atom_names = residue_constants.chi_angles_atoms[resname][chi_idx]"
                },
                {
                  "lineNumber": 182,
                  "content": "    restype_rigidgroup_mask[:20, 4:] = residue_constants.chi_angles_mask"
                },
                {
                  "lineNumber": 185,
                  "content": "    lookuptable = residue_constants.atom_order.copy()"
                },
                {
                  "lineNumber": 221,
                  "content": "    # Adapt backbone frame to old convention (mirror x-axis and z-axis)."
                },
                {
                  "lineNumber": 232,
                  "content": "    for resname, _ in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 233,
                  "content": "        restype = residue_constants.restype_order["
                },
                {
                  "lineNumber": 234,
                  "content": "            residue_constants.restype_3to1[resname]"
                },
                {
                  "lineNumber": 236,
                  "content": "        chi_idx = int(sum(residue_constants.chi_angles_mask[restype]) - 1)"
                },
                {
                  "lineNumber": 303,
                  "content": "      Dict containing:"
                },
                {
                  "lineNumber": 319,
                  "content": "    prev_all_atom_pos = jnp.concatenate([pad, all_atom_pos[:, :-1, :, :]], axis=1)"
                },
                {
                  "lineNumber": 322,
                  "content": "    prev_all_atom_mask = jnp.concatenate([pad, all_atom_mask[:, :-1, :]], axis=1)"
                },
                {
                  "lineNumber": 326,
                  "content": "    pre_omega_atom_pos = jnp.concatenate("
                },
                {
                  "lineNumber": 333,
                  "content": "    phi_atom_pos = jnp.concatenate("
                },
                {
                  "lineNumber": 340,
                  "content": "    psi_atom_pos = jnp.concatenate("
                },
                {
                  "lineNumber": 376,
                  "content": "    chi_angles_mask = list(residue_constants.chi_angles_mask)"
                },
                {
                  "lineNumber": 398,
                  "content": "    torsions_atom_pos = jnp.concatenate("
                },
                {
                  "lineNumber": 410,
                  "content": "    torsion_angles_mask = jnp.concatenate("
                },
                {
                  "lineNumber": 422,
                  "content": "    # Second atom: point on negative x-axis"
                },
                {
                  "lineNumber": 455,
                  "content": "        jnp.asarray(residue_constants.chi_pi_periodic), aatype"
                },
                {
                  "lineNumber": 457,
                  "content": "    mirror_torsion_angles = jnp.concatenate("
                },
                {
                  "lineNumber": 515,
                  "content": "        residue_constants.restype_rigid_group_default_frame, aatype"
                },
                {
                  "lineNumber": 526,
                  "content": "    sin_angles = jnp.concatenate([jnp.zeros([num_residues, 1]), sin_angles], axis=-1)"
                },
                {
                  "lineNumber": 527,
                  "content": "    cos_angles = jnp.concatenate([jnp.ones([num_residues, 1]), cos_angles], axis=-1)"
                },
                {
                  "lineNumber": 559,
                  "content": "    def _concat_frames(xall, x5, x6, x7):"
                },
                {
                  "lineNumber": 560,
                  "content": "        return jnp.concatenate("
                },
                {
                  "lineNumber": 565,
                  "content": "        _concat_frames,"
                },
                {
                  "lineNumber": 597,
                  "content": "        residue_constants.restype_atom14_to_rigid_group, aatype"
                },
                {
                  "lineNumber": 610,
                  "content": "            residue_constants.restype_atom14_rigid_group_positions, aatype"
                },
                {
                  "lineNumber": 619,
                  "content": "    mask = utils.batched_gather(residue_constants.restype_atom14_mask, aatype)"
                },
                {
                  "lineNumber": 633,
                  "content": "    Measures the fraction of CA-CA pairs between consecutive amino acids that are"
                },
                {
                  "lineNumber": 643,
                  "content": "      Fraction of consecutive CA-CA pairs with violation."
                },
                {
                  "lineNumber": 655,
                  "content": "    violations = (ca_ca_distance - residue_constants.ca_ca) &gt; max_angstrom_tolerance"
                },
                {
                  "lineNumber": 671,
                  "content": "    bond between consecutive amino acids. This loss corresponds to"
                },
                {
                  "lineNumber": 686,
                  "content": "      Dict containing:"
                },
                {
                  "lineNumber": 720,
                  "content": "    next_is_proline = (aatype[1:] == residue_constants.resname_to_idx[\"PRO\"]).astype("
                },
                {
                  "lineNumber": 723,
                  "content": "    gt_length = (1.0 - next_is_proline) * residue_constants.between_res_bond_length_c_n["
                },
                {
                  "lineNumber": 725,
                  "content": "    ] + next_is_proline * residue_constants.between_res_bond_length_c_n[1]"
                },
                {
                  "lineNumber": 728,
                  "content": "    ) * residue_constants.between_res_bond_length_stddev_c_n["
                },
                {
                  "lineNumber": 730,
                  "content": "    ] + next_is_proline * residue_constants.between_res_bond_length_stddev_c_n["
                },
                {
                  "lineNumber": 756,
                  "content": "    gt_angle = residue_constants.between_res_cos_angles_ca_c_n[0]"
                },
                {
                  "lineNumber": 757,
                  "content": "    gt_stddev = residue_constants.between_res_bond_length_stddev_c_n[0]"
                },
                {
                  "lineNumber": 769,
                  "content": "    gt_angle = residue_constants.between_res_cos_angles_c_n_ca[0]"
                },
                {
                  "lineNumber": 770,
                  "content": "    gt_stddev = residue_constants.between_res_cos_angles_c_n_ca[1]"
                },
                {
                  "lineNumber": 835,
                  "content": "      Dict containing:"
                },
                {
                  "lineNumber": 884,
                  "content": "    cys_sg_idx = residue_constants.restype_name_to_atom14_names[\"CYS\"].index(\"SG\")"
                },
                {
                  "lineNumber": 954,
                  "content": "      Dict containing:"
                },
                {
                  "lineNumber": 1191,
                  "content": "        residue_constants.restype_1to3[res] for res in residue_constants.restypes"
                },
                {
                  "lineNumber": 1196,
                  "content": "    for resname, swap in residue_constants.residue_atom_renaming_swaps.items():"
                },
                {
                  "lineNumber": 1199,
                  "content": "            source_index = residue_constants.restype_name_to_atom14_names["
                },
                {
                  "lineNumber": 1202,
                  "content": "            target_index = residue_constants.restype_name_to_atom14_names["
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/geometry/rigid_matrix_vector.py",
              "matches": [
                {
                  "lineNumber": 77,
                  "content": "        return jnp.concatenate([rot_array, vec_array[..., None]], axis=-1)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/features.py",
              "matches": [
                {
                  "lineNumber": 29,
                  "content": "def make_data_config("
                },
                {
                  "lineNumber": 30,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 33,
                  "content": "    \"\"\"Makes a data config for the input pipeline.\"\"\""
                },
                {
                  "lineNumber": 34,
                  "content": "    cfg = copy.deepcopy(config.data)"
                },
                {
                  "lineNumber": 48,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 53,
                  "content": "    cfg, feature_names = make_data_config(config, num_res=num_res)"
                },
                {
                  "lineNumber": 71,
                  "content": "        processed_batch = input_pipeline.process_tensors_from_config(tensor_dict, cfg)"
                },
                {
                  "lineNumber": 82,
                  "content": "    np_example: FeatureDict, config: ml_collections.ConfigDict, random_seed: int = 0"
                },
                {
                  "lineNumber": 87,
                  "content": "    cfg, feature_names = make_data_config(config, num_res=num_res)"
                },
                {
                  "lineNumber": 101,
                  "content": "        processed_batch = input_pipeline.process_tensors_from_config(tensor_dict, cfg)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/folding.py",
              "matches": [
                {
                  "lineNumber": 19,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 51,
                  "content": "        self, config, global_config, dist_epsilon=1e-8, name=\"invariant_point_attention\""
                },
                {
                  "lineNumber": 56,
                  "content": "          config: Structure Module Config"
                },
                {
                  "lineNumber": 57,
                  "content": "          global_config: Global Config of Model."
                },
                {
                  "lineNumber": 64,
                  "content": "        self._zero_initialize_last = global_config.zero_init"
                },
                {
                  "lineNumber": 66,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 68,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 78,
                  "content": "        are converted into the global frame in order to compute attention via"
                },
                {
                  "lineNumber": 82,
                  "content": "        used as attention values, which are converted into the query residues'"
                },
                {
                  "lineNumber": 100,
                  "content": "        num_head = self.config.num_head"
                },
                {
                  "lineNumber": 101,
                  "content": "        num_scalar_qk = self.config.num_scalar_qk"
                },
                {
                  "lineNumber": 102,
                  "content": "        num_point_qk = self.config.num_point_qk"
                },
                {
                  "lineNumber": 103,
                  "content": "        num_scalar_v = self.config.num_scalar_v"
                },
                {
                  "lineNumber": 104,
                  "content": "        num_point_v = self.config.num_point_v"
                },
                {
                  "lineNumber": 105,
                  "content": "        num_output = self.config.num_channel"
                },
                {
                  "lineNumber": 131,
                  "content": "        # First construct query points in local frame."
                },
                {
                  "lineNumber": 177,
                  "content": "        # Each scalar pair (q, k) contributes Var q*k = 1"
                },
                {
                  "lineNumber": 179,
                  "content": "        # Each point pair (q, k) contributes Var [0.5 ||q||^2 - &lt;q, k&gt;] = 9 / 2"
                },
                {
                  "lineNumber": 275,
                  "content": "        # Contraction happens over the second residue dimension, similarly to how"
                },
                {
                  "lineNumber": 285,
                  "content": "        final_act = jnp.concatenate(output_features, axis=-1)"
                },
                {
                  "lineNumber": 303,
                  "content": "    def __init__(self, config, global_config, name=\"fold_iteration\"):"
                },
                {
                  "lineNumber": 305,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 306,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 319,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 329,
                  "content": "                is_deterministic=self.global_config.deterministic,"
                },
                {
                  "lineNumber": 336,
                  "content": "        attention_module = InvariantPointAttention(self.config, self.global_config)"
                },
                {
                  "lineNumber": 352,
                  "content": "        final_init = \"zeros\" if self.global_config.zero_init else \"linear\""
                },
                {
                  "lineNumber": 384,
                  "content": "        sc = MultiRigidSidechain(c.sidechain, self.global_config)("
                },
                {
                  "lineNumber": 397,
                  "content": "    representations, batch, config, global_config, is_training, safe_key"
                },
                {
                  "lineNumber": 409,
                  "content": "      config: Config for the structure module."
                },
                {
                  "lineNumber": 410,
                  "content": "      global_config: Global config."
                },
                {
                  "lineNumber": 415,
                  "content": "      A dictionary containing residue affines and sidechain positions."
                },
                {
                  "lineNumber": 417,
                  "content": "    c = config"
                },
                {
                  "lineNumber": 429,
                  "content": "    fold_iteration = FoldIteration(c, global_config, name=\"fold_iteration\")"
                },
                {
                  "lineNumber": 471,
                  "content": "        self, config, global_config, compute_loss=True, name=\"structure_module\""
                },
                {
                  "lineNumber": 474,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 475,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 479,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 488,
                  "content": "            config=self.config,"
                },
                {
                  "lineNumber": 489,
                  "content": "            global_config=self.global_config,"
                },
                {
                  "lineNumber": 527,
                  "content": "        if self.config.compute_in_graph_metrics:"
                },
                {
                  "lineNumber": 532,
                  "content": "                batch, atom14_pred_positions, self.config"
                },
                {
                  "lineNumber": 543,
                  "content": "        backbone_loss(ret, batch, value, self.config)"
                },
                {
                  "lineNumber": 549,
                  "content": "        sc_loss = sidechain_loss(batch, value, self.config)"
                },
                {
                  "lineNumber": 551,
                  "content": "        ret[\"loss\"] = (1 - self.config.sidechain.weight_frac) * ret["
                },
                {
                  "lineNumber": 553,
                  "content": "        ] + self.config.sidechain.weight_frac * sc_loss[\"loss\"]"
                },
                {
                  "lineNumber": 556,
                  "content": "        supervised_chi_loss(ret, batch, value, self.config)"
                },
                {
                  "lineNumber": 558,
                  "content": "        if self.config.structural_violation_loss_weight:"
                },
                {
                  "lineNumber": 561,
                  "content": "                    batch, value[\"final_atom14_positions\"], self.config"
                },
                {
                  "lineNumber": 563,
                  "content": "            structural_violation_loss(ret, batch, value, self.config)"
                },
                {
                  "lineNumber": 581,
                  "content": "      batch: Dictionary containing:"
                },
                {
                  "lineNumber": 594,
                  "content": "      Dictionary containing:"
                },
                {
                  "lineNumber": 624,
                  "content": "def backbone_loss(ret, batch, value, config):"
                },
                {
                  "lineNumber": 630,
                  "content": "      ret: Dictionary to write outputs into, needs to contain 'loss'."
                },
                {
                  "lineNumber": 631,
                  "content": "      batch: Batch, needs to contain 'backbone_affine_tensor',"
                },
                {
                  "lineNumber": 633,
                  "content": "      value: Dictionary containing structure module output, needs to contain"
                },
                {
                  "lineNumber": 635,
                  "content": "      config: Configuration of loss, should contain 'fape.clamp_distance' and"
                },
                {
                  "lineNumber": 647,
                  "content": "        l1_clamp_distance=config.fape.clamp_distance,"
                },
                {
                  "lineNumber": 648,
                  "content": "        length_scale=config.fape.loss_unit_distance,"
                },
                {
                  "lineNumber": 667,
                  "content": "            length_scale=config.fape.loss_unit_distance,"
                },
                {
                  "lineNumber": 689,
                  "content": "def sidechain_loss(batch, value, config):"
                },
                {
                  "lineNumber": 725,
                  "content": "        l1_clamp_distance=config.sidechain.atom_clamp_distance,"
                },
                {
                  "lineNumber": 726,
                  "content": "        length_scale=config.sidechain.length_scale,"
                },
                {
                  "lineNumber": 732,
                  "content": "def structural_violation_loss(ret, batch, value, config):"
                },
                {
                  "lineNumber": 734,
                  "content": "    assert config.sidechain.weight_frac"
                },
                {
                  "lineNumber": 739,
                  "content": "    ret[\"loss\"] += config.structural_violation_loss_weight * ("
                },
                {
                  "lineNumber": 754,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 759,
                  "content": "    connection_violations = all_atom.between_residue_bond_loss("
                },
                {
                  "lineNumber": 764,
                  "content": "        tolerance_factor_soft=config.violation_tolerance_factor,"
                },
                {
                  "lineNumber": 765,
                  "content": "        tolerance_factor_hard=config.violation_tolerance_factor,"
                },
                {
                  "lineNumber": 773,
                  "content": "            residue_constants.van_der_waals_radius[name[0]]"
                },
                {
                  "lineNumber": 774,
                  "content": "            for name in residue_constants.atom_types"
                },
                {
                  "lineNumber": 787,
                  "content": "        overlap_tolerance_soft=config.clash_overlap_tolerance,"
                },
                {
                  "lineNumber": 788,
                  "content": "        overlap_tolerance_hard=config.clash_overlap_tolerance,"
                },
                {
                  "lineNumber": 793,
                  "content": "    restype_atom14_bounds = residue_constants.make_atom14_dists_bounds("
                },
                {
                  "lineNumber": 794,
                  "content": "        overlap_tolerance=config.clash_overlap_tolerance,"
                },
                {
                  "lineNumber": 795,
                  "content": "        bond_length_tolerance_factor=config.violation_tolerance_factor,"
                },
                {
                  "lineNumber": 815,
                  "content": "                connection_violations[\"per_residue_violation_mask\"],"
                },
                {
                  "lineNumber": 825,
                  "content": "            \"bonds_c_n_loss_mean\": connection_violations[\"c_n_loss_mean\"],  # ()"
                },
                {
                  "lineNumber": 826,
                  "content": "            \"angles_ca_c_n_loss_mean\": connection_violations[\"ca_c_n_loss_mean\"],  # ()"
                },
                {
                  "lineNumber": 827,
                  "content": "            \"angles_c_n_ca_loss_mean\": connection_violations[\"c_n_ca_loss_mean\"],  # ()"
                },
                {
                  "lineNumber": 828,
                  "content": "            \"connections_per_residue_loss_sum\": connection_violations["
                },
                {
                  "lineNumber": 831,
                  "content": "            \"connections_per_residue_violation_mask\": connection_violations["
                },
                {
                  "lineNumber": 870,
                  "content": "        value=violations[\"between_residues\"][\"connections_per_residue_violation_mask\"],"
                },
                {
                  "lineNumber": 888,
                  "content": "def supervised_chi_loss(ret, batch, value, config):"
                },
                {
                  "lineNumber": 894,
                  "content": "      ret: Dictionary to write outputs into, needs to contain 'loss'."
                },
                {
                  "lineNumber": 895,
                  "content": "      batch: Batch, needs to contain 'seq_mask', 'chi_mask', 'chi_angles'."
                },
                {
                  "lineNumber": 896,
                  "content": "      value: Dictionary containing structure module output, needs to contain"
                },
                {
                  "lineNumber": 900,
                  "content": "      config: Configuration of loss, should contain 'chi_weight' and"
                },
                {
                  "lineNumber": 915,
                  "content": "        batch[\"aatype\"], residue_constants.restype_num + 1, dtype=jnp.float32"
                },
                {
                  "lineNumber": 920,
                  "content": "        jnp.asarray(residue_constants.chi_pi_periodic),"
                },
                {
                  "lineNumber": 940,
                  "content": "    ret[\"loss\"] += config.chi_weight * sq_chi_loss"
                },
                {
                  "lineNumber": 951,
                  "content": "    ret[\"loss\"] += config.angle_norm_weight * angle_norm_loss"
                },
                {
                  "lineNumber": 971,
                  "content": "    def __init__(self, config, global_config, name=\"rigid_sidechain\"):"
                },
                {
                  "lineNumber": 973,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 974,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 985,
                  "content": "          Dict containing atom positions and frames (in angstroms)."
                },
                {
                  "lineNumber": 989,
                  "content": "                self.config.num_channel, name=\"input_projection\""
                },
                {
                  "lineNumber": 993,
                  "content": "        # Sum the activation list (equivalent to concat then Linear)."
                },
                {
                  "lineNumber": 996,
                  "content": "        final_init = \"zeros\" if self.global_config.zero_init else \"linear\""
                },
                {
                  "lineNumber": 999,
                  "content": "        for _ in range(self.config.num_residual_block):"
                },
                {
                  "lineNumber": 1002,
                  "content": "                self.config.num_channel, initializer=\"relu\", name=\"resblock1\""
                },
                {
                  "lineNumber": 1005,
                  "content": "                self.config.num_channel, initializer=final_init, name=\"resblock2\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/modules.py",
              "matches": [
                {
                  "lineNumber": 20,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 71,
                  "content": "    global_config,"
                },
                {
                  "lineNumber": 80,
                  "content": "    gc = global_config"
                },
                {
                  "lineNumber": 82,
                  "content": "    dropout_rate = 0.0 if gc.deterministic else module.config.dropout_rate"
                },
                {
                  "lineNumber": 87,
                  "content": "    if module.config.shared_dropout:"
                },
                {
                  "lineNumber": 88,
                  "content": "        if module.config.orientation == \"per_row\":"
                },
                {
                  "lineNumber": 109,
                  "content": "    \"\"\"Expand extra_msa into 1hot and concat with other extra msa features."
                },
                {
                  "lineNumber": 132,
                  "content": "    return jnp.concatenate(msa_feat, axis=-1)"
                },
                {
                  "lineNumber": 140,
                  "content": "    that have been requested by the configuration file. Each head also returns a"
                },
                {
                  "lineNumber": 146,
                  "content": "    def __init__(self, config, global_config, name=\"alphafold_iteration\"):"
                },
                {
                  "lineNumber": 148,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 149,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 173,
                  "content": "            self.config.embeddings_and_evoformer, self.global_config"
                },
                {
                  "lineNumber": 216,
                  "content": "        for head_name, head_config in sorted(self.config.heads.items()):"
                },
                {
                  "lineNumber": 217,
                  "content": "            if not head_config.weight:"
                },
                {
                  "lineNumber": 218,
                  "content": "                continue  # Do not instantiate zero-weight heads."
                },
                {
                  "lineNumber": 231,
                  "content": "                head_config,"
                },
                {
                  "lineNumber": 232,
                  "content": "                head_factory(head_config, self.global_config),"
                },
                {
                  "lineNumber": 239,
                  "content": "        def loss(module, head_config, ret, name, filter_ret=True):"
                },
                {
                  "lineNumber": 246,
                  "content": "            loss = head_config.weight * ret[name][\"loss\"]"
                },
                {
                  "lineNumber": 249,
                  "content": "        for name, (head_config, module) in heads.items():"
                },
                {
                  "lineNumber": 253,
                  "content": "                continue"
                },
                {
                  "lineNumber": 261,
                  "content": "                total_loss += loss(module, head_config, ret, name)"
                },
                {
                  "lineNumber": 263,
                  "content": "        if self.config.heads.get(\"predicted_lddt.weight\", 0.0):"
                },
                {
                  "lineNumber": 267,
                  "content": "            head_config, module = heads[name]"
                },
                {
                  "lineNumber": 270,
                  "content": "                total_loss += loss(module, head_config, ret, name, filter_ret=False)"
                },
                {
                  "lineNumber": 272,
                  "content": "        if \"predicted_aligned_error\" in self.config.heads and self.config.heads.get("
                },
                {
                  "lineNumber": 278,
                  "content": "            head_config, module = heads[name]"
                },
                {
                  "lineNumber": 281,
                  "content": "                total_loss += loss(module, head_config, ret, name, filter_ret=False)"
                },
                {
                  "lineNumber": 295,
                  "content": "    def __init__(self, config, name=\"alphafold\"):"
                },
                {
                  "lineNumber": 297,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 298,
                  "content": "        self.global_config = config.global_config"
                },
                {
                  "lineNumber": 325,
                  "content": "          The output of AlphaFoldIteration is a nested dictionary containing"
                },
                {
                  "lineNumber": 329,
                  "content": "        impl = AlphaFoldIteration(self.config, self.global_config)"
                },
                {
                  "lineNumber": 341,
                  "content": "            if self.config.resample_msa_in_recycling:"
                },
                {
                  "lineNumber": 342,
                  "content": "                num_ensemble = batch_size // (self.config.num_recycle + 1)"
                },
                {
                  "lineNumber": 365,
                  "content": "        emb_config = self.config.embeddings_and_evoformer"
                },
                {
                  "lineNumber": 366,
                  "content": "        if emb_config.recycle_pos:"
                },
                {
                  "lineNumber": 368,
                  "content": "                [num_residues, residue_constants.atom_type_num, 3]"
                },
                {
                  "lineNumber": 370,
                  "content": "        if emb_config.recycle_features:"
                },
                {
                  "lineNumber": 372,
                  "content": "                [num_residues, emb_config.msa_channel]"
                },
                {
                  "lineNumber": 375,
                  "content": "                [num_residues, num_residues, emb_config.pair_channel]"
                },
                {
                  "lineNumber": 378,
                  "content": "        if self.config.num_recycle:"
                },
                {
                  "lineNumber": 386,
                  "content": "                # recyclings than the model is configured to run."
                },
                {
                  "lineNumber": 387,
                  "content": "                num_iter = jnp.minimum(num_iter, self.config.num_recycle)"
                },
                {
                  "lineNumber": 390,
                  "content": "                num_iter = self.config.num_recycle"
                },
                {
                  "lineNumber": 422,
                  "content": "    def __init__(self, config, global_config, name=\"template_pair_stack\"):"
                },
                {
                  "lineNumber": 424,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 425,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 443,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 444,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 454,
                  "content": "                dropout_wrapper, is_training=is_training, global_config=gc"
                },
                {
                  "lineNumber": 524,
                  "content": "    def __init__(self, config, global_config, name=\"transition_block\"):"
                },
                {
                  "lineNumber": 526,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 527,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 542,
                  "content": "        num_intermediate = int(nc * self.config.num_intermediate_factor)"
                },
                {
                  "lineNumber": 557,
                  "content": "                    initializer=utils.final_init(self.global_config),"
                },
                {
                  "lineNumber": 565,
                  "content": "            self.global_config.subbatch_size,"
                },
                {
                  "lineNumber": 583,
                  "content": "    def __init__(self, config, global_config, output_dim, name=\"attention\"):"
                },
                {
                  "lineNumber": 586,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 587,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 603,
                  "content": "        # Sensible default for when the config keys are missing"
                },
                {
                  "lineNumber": 604,
                  "content": "        key_dim = self.config.get(\"key_dim\", int(q_data.shape[-1]))"
                },
                {
                  "lineNumber": 605,
                  "content": "        value_dim = self.config.get(\"value_dim\", int(m_data.shape[-1]))"
                },
                {
                  "lineNumber": 606,
                  "content": "        num_head = self.config.num_head"
                },
                {
                  "lineNumber": 641,
                  "content": "        if self.global_config.zero_init:"
                },
                {
                  "lineNumber": 646,
                  "content": "        if self.config.gating:"
                },
                {
                  "lineNumber": 692,
                  "content": "    def __init__(self, config, global_config, output_dim, name=\"attention\"):"
                },
                {
                  "lineNumber": 695,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 696,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 714,
                  "content": "        # Sensible default for when the config keys are missing"
                },
                {
                  "lineNumber": 715,
                  "content": "        key_dim = self.config.get(\"key_dim\", int(q_data.shape[-1]))"
                },
                {
                  "lineNumber": 716,
                  "content": "        value_dim = self.config.get(\"value_dim\", int(m_data.shape[-1]))"
                },
                {
                  "lineNumber": 717,
                  "content": "        num_head = self.config.num_head"
                },
                {
                  "lineNumber": 754,
                  "content": "        if self.global_config.zero_init:"
                },
                {
                  "lineNumber": 772,
                  "content": "        if self.config.gating:"
                },
                {
                  "lineNumber": 802,
                  "content": "    def __init__(self, config, global_config, name=\"msa_row_attention_with_pair_bias\"):"
                },
                {
                  "lineNumber": 804,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 805,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 819,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 845,
                  "content": "        attn_mod = Attention(c, self.global_config, msa_act.shape[-1])"
                },
                {
                  "lineNumber": 848,
                  "content": "            self.global_config.subbatch_size,"
                },
                {
                  "lineNumber": 863,
                  "content": "    def __init__(self, config, global_config, name=\"msa_column_attention\"):"
                },
                {
                  "lineNumber": 865,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 866,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 879,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 895,
                  "content": "        attn_mod = Attention(c, self.global_config, msa_act.shape[-1])"
                },
                {
                  "lineNumber": 898,
                  "content": "            self.global_config.subbatch_size,"
                },
                {
                  "lineNumber": 915,
                  "content": "    def __init__(self, config, global_config, name=\"msa_column_global_attention\"):"
                },
                {
                  "lineNumber": 917,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 918,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 931,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 945,
                  "content": "            c, self.global_config, msa_act.shape[-1], name=\"attention\""
                },
                {
                  "lineNumber": 951,
                  "content": "            self.global_config.subbatch_size,"
                },
                {
                  "lineNumber": 969,
                  "content": "    def __init__(self, config, global_config, name=\"triangle_attention\"):"
                },
                {
                  "lineNumber": 971,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 972,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 985,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1011,
                  "content": "        attn_mod = Attention(c, self.global_config, pair_act.shape[-1])"
                },
                {
                  "lineNumber": 1014,
                  "content": "            self.global_config.subbatch_size,"
                },
                {
                  "lineNumber": 1029,
                  "content": "    The MaskedMsaHead employs a BERT-style objective to reconstruct a masked"
                },
                {
                  "lineNumber": 1035,
                  "content": "    def __init__(self, config, global_config, name=\"masked_msa_head\"):"
                },
                {
                  "lineNumber": 1037,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1038,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1040,
                  "content": "        if global_config.multimer_mode:"
                },
                {
                  "lineNumber": 1041,
                  "content": "            self.num_output = len(residue_constants.restypes_with_x_and_gap)"
                },
                {
                  "lineNumber": 1043,
                  "content": "            self.num_output = config.num_output"
                },
                {
                  "lineNumber": 1049,
                  "content": "          representations: Dictionary of representations, must contain:"
                },
                {
                  "lineNumber": 1055,
                  "content": "          Dictionary containing:"
                },
                {
                  "lineNumber": 1062,
                  "content": "            initializer=utils.final_init(self.global_config),"
                },
                {
                  "lineNumber": 1079,
                  "content": "    \"\"\"Head to predict the per-residue LDDT to be used as a confidence measure."
                },
                {
                  "lineNumber": 1081,
                  "content": "    Jumper et al. (2021) Suppl. Sec. 1.9.6 \"Model confidence prediction (pLDDT)\""
                },
                {
                  "lineNumber": 1085,
                  "content": "    def __init__(self, config, global_config, name=\"predicted_lddt_head\"):"
                },
                {
                  "lineNumber": 1087,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1088,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1094,
                  "content": "          representations: Dictionary of representations, must contain:"
                },
                {
                  "lineNumber": 1101,
                  "content": "          Dictionary containing :"
                },
                {
                  "lineNumber": 1112,
                  "content": "            self.config.num_channels, initializer=\"relu\", name=\"act_0\""
                },
                {
                  "lineNumber": 1117,
                  "content": "            self.config.num_channels, initializer=\"relu\", name=\"act_1\""
                },
                {
                  "lineNumber": 1122,
                  "content": "            self.config.num_bins,"
                },
                {
                  "lineNumber": 1123,
                  "content": "            initializer=utils.final_init(self.global_config),"
                },
                {
                  "lineNumber": 1150,
                  "content": "        num_bins = self.config.num_bins"
                },
                {
                  "lineNumber": 1162,
                  "content": "        mask_ca = all_atom_mask[:, residue_constants.atom_order[\"CA\"]]"
                },
                {
                  "lineNumber": 1166,
                  "content": "        if self.config.filter_by_resolution:"
                },
                {
                  "lineNumber": 1169,
                  "content": "                (batch[\"resolution\"] &gt;= self.config.min_resolution)"
                },
                {
                  "lineNumber": 1170,
                  "content": "                &amp; (batch[\"resolution\"] &lt;= self.config.max_resolution)"
                },
                {
                  "lineNumber": 1184,
                  "content": "    def __init__(self, config, global_config, name=\"predicted_aligned_error_head\"):"
                },
                {
                  "lineNumber": 1186,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1187,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1193,
                  "content": "          representations: Dictionary of representations, must contain:"
                },
                {
                  "lineNumber": 1199,
                  "content": "          Dictionary containing:"
                },
                {
                  "lineNumber": 1201,
                  "content": "            * bin_breaks: array containing bin breaks, shape [N_bins - 1]."
                },
                {
                  "lineNumber": 1208,
                  "content": "            self.config.num_bins,"
                },
                {
                  "lineNumber": 1209,
                  "content": "            initializer=utils.final_init(self.global_config),"
                },
                {
                  "lineNumber": 1213,
                  "content": "        breaks = jnp.linspace(0.0, self.config.max_error_bin, self.config.num_bins - 1)"
                },
                {
                  "lineNumber": 1229,
                  "content": "        num_bins = self.config.num_bins"
                },
                {
                  "lineNumber": 1248,
                  "content": "        # First num_res are alignment frames, second num_res are the residues."
                },
                {
                  "lineNumber": 1264,
                  "content": "        if self.config.filter_by_resolution:"
                },
                {
                  "lineNumber": 1267,
                  "content": "                (batch[\"resolution\"] &gt;= self.config.min_resolution)"
                },
                {
                  "lineNumber": 1268,
                  "content": "                &amp; (batch[\"resolution\"] &lt;= self.config.max_resolution)"
                },
                {
                  "lineNumber": 1282,
                  "content": "    def __init__(self, config, global_config, name=\"experimentally_resolved_head\"):"
                },
                {
                  "lineNumber": 1284,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1285,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1291,
                  "content": "          representations: Dictionary of representations, must contain:"
                },
                {
                  "lineNumber": 1297,
                  "content": "          Dictionary containing:"
                },
                {
                  "lineNumber": 1300,
                  "content": "                can be converted to probability by applying sigmoid."
                },
                {
                  "lineNumber": 1304,
                  "content": "            initializer=utils.final_init(self.global_config),"
                },
                {
                  "lineNumber": 1322,
                  "content": "        if self.config.filter_by_resolution:"
                },
                {
                  "lineNumber": 1325,
                  "content": "                (batch[\"resolution\"] &gt;= self.config.min_resolution)"
                },
                {
                  "lineNumber": 1326,
                  "content": "                &amp; (batch[\"resolution\"] &lt;= self.config.max_resolution)"
                },
                {
                  "lineNumber": 1354,
                  "content": "    def __init__(self, config, global_config, name=\"triangle_multiplication\"):"
                },
                {
                  "lineNumber": 1356,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1357,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1372,
                  "content": "        if self.config.fuse_projection_weights:"
                },
                {
                  "lineNumber": 1380,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1381,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 1455,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1456,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 1504,
                  "content": "    def __init__(self, config, global_config, name=\"distogram_head\"):"
                },
                {
                  "lineNumber": 1506,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1507,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1513,
                  "content": "          representations: Dictionary of representations, must contain:"
                },
                {
                  "lineNumber": 1519,
                  "content": "          Dictionary containing:"
                },
                {
                  "lineNumber": 1521,
                  "content": "            * bin_breaks: array containing bin breaks, shape [N_bins - 1,]."
                },
                {
                  "lineNumber": 1524,
                  "content": "            self.config.num_bins,"
                },
                {
                  "lineNumber": 1525,
                  "content": "            initializer=utils.final_init(self.global_config),"
                },
                {
                  "lineNumber": 1531,
                  "content": "            self.config.first_break, self.config.last_break, self.config.num_bins - 1"
                },
                {
                  "lineNumber": 1538,
                  "content": "            value[\"logits\"], value[\"bin_edges\"], batch, self.config.num_bins"
                },
                {
                  "lineNumber": 1583,
                  "content": "        self, config, global_config, num_output_channel, name=\"outer_product_mean\""
                },
                {
                  "lineNumber": 1586,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1587,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1601,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 1602,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1681,
                  "content": "    upper_breaks = jnp.concatenate("
                },
                {
                  "lineNumber": 1701,
                  "content": "    is_gly = jnp.equal(aatype, residue_constants.restype_order[\"G\"])"
                },
                {
                  "lineNumber": 1702,
                  "content": "    ca_idx = residue_constants.atom_order[\"CA\"]"
                },
                {
                  "lineNumber": 1703,
                  "content": "    cb_idx = residue_constants.atom_order[\"CB\"]"
                },
                {
                  "lineNumber": 1726,
                  "content": "    def __init__(self, config, global_config, is_extra_msa, name=\"evoformer_iteration\"):"
                },
                {
                  "lineNumber": 1728,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1729,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1736,
                  "content": "          activations: Dictionary containing activations:"
                },
                {
                  "lineNumber": 1748,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1749,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 1759,
                  "content": "            dropout_wrapper, is_training=is_training, global_config=gc"
                },
                {
                  "lineNumber": 1766,
                  "content": "            config=c.outer_product_mean,"
                },
                {
                  "lineNumber": 1767,
                  "content": "            global_config=self.global_config,"
                },
                {
                  "lineNumber": 1879,
                  "content": "    def __init__(self, config, global_config, name=\"evoformer\"):"
                },
                {
                  "lineNumber": 1881,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1882,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1886,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 1887,
                  "content": "        gc = self.global_config"
                },
                {
                  "lineNumber": 1919,
                  "content": "            dgram = dgram_from_positions(prev_pseudo_beta, **self.config.prev_pos)"
                },
                {
                  "lineNumber": 2026,
                  "content": "                # Ensure consistent behaviour during testing:"
                },
                {
                  "lineNumber": 2030,
                  "content": "            template_features = jnp.concatenate("
                },
                {
                  "lineNumber": 2053,
                  "content": "            evoformer_input[\"msa\"] = jnp.concatenate("
                },
                {
                  "lineNumber": 2061,
                  "content": "            evoformer_masks[\"msa\"] = jnp.concatenate("
                },
                {
                  "lineNumber": 2113,
                  "content": "    def __init__(self, config, global_config, name=\"single_template_embedding\"):"
                },
                {
                  "lineNumber": 2115,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 2116,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 2136,
                  "content": "            self.config.template_pair_stack.triangle_attention_ending_node.value_dim"
                },
                {
                  "lineNumber": 2143,
                  "content": "            batch[\"template_pseudo_beta\"], **self.config.dgram_features"
                },
                {
                  "lineNumber": 2147,
                  "content": "        to_concat = [template_dgram, template_mask_2d[:, :, None]]"
                },
                {
                  "lineNumber": 2151,
                  "content": "        to_concat.append(jnp.tile(aatype[None, :, :], [num_res, 1, 1]))"
                },
                {
                  "lineNumber": 2152,
                  "content": "        to_concat.append(jnp.tile(aatype[:, None, :], [1, num_res, 1]))"
                },
                {
                  "lineNumber": 2154,
                  "content": "        n, ca, c = [residue_constants.atom_order[a] for a in (\"N\", \"CA\", \"C\")]"
                },
                {
                  "lineNumber": 2173,
                  "content": "        # (the template mask defined above only considers pseudo CB)."
                },
                {
                  "lineNumber": 2187,
                  "content": "        if not self.config.use_template_unit_vector:"
                },
                {
                  "lineNumber": 2189,
                  "content": "        to_concat.extend(unit_vector)"
                },
                {
                  "lineNumber": 2191,
                  "content": "        to_concat.append(template_mask_2d[..., None])"
                },
                {
                  "lineNumber": 2193,
                  "content": "        act = jnp.concatenate(to_concat, axis=-1)"
                },
                {
                  "lineNumber": 2205,
                  "content": "        act = TemplatePairStack(self.config.template_pair_stack, self.global_config)("
                },
                {
                  "lineNumber": 2220,
                  "content": "    def __init__(self, config, global_config, name=\"template_embedding\"):"
                },
                {
                  "lineNumber": 2222,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 2223,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 2241,
                  "content": "            self.config.template_pair_stack.triangle_attention_ending_node.value_dim"
                },
                {
                  "lineNumber": 2251,
                  "content": "        # Make sure the weights are shared across templates by constructing the"
                },
                {
                  "lineNumber": 2254,
                  "content": "        template_embedder = SingleTemplateEmbedding(self.config, self.global_config)"
                },
                {
                  "lineNumber": 2278,
                  "content": "            self.config.attention, self.global_config, query_num_channels"
                },
                {
                  "lineNumber": 2285,
                  "content": "            self.config.subbatch_size,"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/mapping.py",
              "matches": [
                {
                  "lineNumber": 206,
                  "content": "  \"\"\"Run through subbatches (like batch apply but with split and concat).\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/model.py",
              "matches": [
                {
                  "lineNumber": 15,
                  "content": "\"\"\"Code for constructing the model.\"\"\""
                },
                {
                  "lineNumber": 19,
                  "content": "from mber.models.alphafold.common import confidence"
                },
                {
                  "lineNumber": 31,
                  "content": "def get_confidence_metrics("
                },
                {
                  "lineNumber": 34,
                  "content": "    \"\"\"Post processes prediction_result to get confidence metrics.\"\"\""
                },
                {
                  "lineNumber": 35,
                  "content": "    confidence_metrics = {}"
                },
                {
                  "lineNumber": 36,
                  "content": "    confidence_metrics[\"plddt\"] = confidence.compute_plddt("
                },
                {
                  "lineNumber": 40,
                  "content": "        confidence_metrics.update("
                },
                {
                  "lineNumber": 41,
                  "content": "            confidence.compute_predicted_aligned_error("
                },
                {
                  "lineNumber": 46,
                  "content": "        confidence_metrics[\"ptm\"] = confidence.predicted_tm_score("
                },
                {
                  "lineNumber": 53,
                  "content": "            confidence_metrics[\"iptm\"] = confidence.predicted_tm_score("
                },
                {
                  "lineNumber": 57,
                  "content": "                interface=True,"
                },
                {
                  "lineNumber": 59,
                  "content": "            confidence_metrics[\"ranking_confidence\"] = ("
                },
                {
                  "lineNumber": 60,
                  "content": "                0.8 * confidence_metrics[\"iptm\"] + 0.2 * confidence_metrics[\"ptm\"]"
                },
                {
                  "lineNumber": 65,
                  "content": "        confidence_metrics[\"ranking_confidence\"] = np.mean(confidence_metrics[\"plddt\"])"
                },
                {
                  "lineNumber": 67,
                  "content": "    return confidence_metrics"
                },
                {
                  "lineNumber": 75,
                  "content": "        config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 78,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 80,
                  "content": "        self.multimer_mode = config.model.global_config.multimer_mode"
                },
                {
                  "lineNumber": 85,
                  "content": "                model = modules_multimer.AlphaFold(self.config.model)"
                },
                {
                  "lineNumber": 91,
                  "content": "                model = modules.AlphaFold(self.config.model)"
                },
                {
                  "lineNumber": 142,
                  "content": "                np_example=raw_features, config=self.config, random_seed=random_seed"
                },
                {
                  "lineNumber": 146,
                  "content": "                tf_example=raw_features, config=self.config, random_seed=random_seed"
                },
                {
                  "lineNumber": 170,
                  "content": "            multimer model this controls the MSA sampling."
                },
                {
                  "lineNumber": 183,
                  "content": "        # already happening when computing get_confidence_metrics, and this ensures"
                },
                {
                  "lineNumber": 186,
                  "content": "        result.update(get_confidence_metrics(result, multimer_mode=self.multimer_mode))"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/model/folding_multimer.py",
              "matches": [
                {
                  "lineNumber": 21,
                  "content": "from mber.models.alphafold.common import residue_constants"
                },
                {
                  "lineNumber": 52,
                  "content": "    a = residue_constants.atom_order[\"N\"]"
                },
                {
                  "lineNumber": 53,
                  "content": "    b = residue_constants.atom_order[\"CA\"]"
                },
                {
                  "lineNumber": 54,
                  "content": "    c = residue_constants.atom_order[\"C\"]"
                },
                {
                  "lineNumber": 70,
                  "content": "        global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 85,
                  "content": "          global_config: Global Config, used to set certain properties of underlying"
                },
                {
                  "lineNumber": 94,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 106,
                  "content": "        the channel dimension, rigid_shape controls the trailing dimensions."
                },
                {
                  "lineNumber": 147,
                  "content": "        global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 156,
                  "content": "          global_config: Global Config, passed through to underlying Linear"
                },
                {
                  "lineNumber": 167,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 202,
                  "content": "        config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 203,
                  "content": "        global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 210,
                  "content": "          config: iterative Fold Head Config"
                },
                {
                  "lineNumber": 211,
                  "content": "          global_config: Global Config of Model."
                },
                {
                  "lineNumber": 218,
                  "content": "        self._zero_initialize_last = global_config.zero_init"
                },
                {
                  "lineNumber": 220,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 222,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 238,
                  "content": "        are converted into the global frame to get attention via euclidean distance."
                },
                {
                  "lineNumber": 241,
                  "content": "        used as attention values, which are converted into the query residues local"
                },
                {
                  "lineNumber": 258,
                  "content": "        num_head = self.config.num_head"
                },
                {
                  "lineNumber": 262,
                  "content": "        num_point_qk = self.config.num_point_qk"
                },
                {
                  "lineNumber": 263,
                  "content": "        # Each point pair (q, k) contributes Var [0.5 ||q||^2 - &lt;q, k&gt;] = 9 / 2"
                },
                {
                  "lineNumber": 280,
                  "content": "            [num_head, num_point_qk], self.global_config, name=\"q_point_projection\""
                },
                {
                  "lineNumber": 284,
                  "content": "            [num_head, num_point_qk], self.global_config, name=\"k_point_projection\""
                },
                {
                  "lineNumber": 293,
                  "content": "        num_scalar_qk = self.config.num_scalar_qk"
                },
                {
                  "lineNumber": 296,
                  "content": "        # Each scalar pair (q, k) contributes Var q*k = 1"
                },
                {
                  "lineNumber": 318,
                  "content": "        num_scalar_v = self.config.num_scalar_v"
                },
                {
                  "lineNumber": 327,
                  "content": "        num_point_v = self.config.num_point_v"
                },
                {
                  "lineNumber": 329,
                  "content": "            [num_head, num_point_v], self.global_config, name=\"v_point_projection\""
                },
                {
                  "lineNumber": 361,
                  "content": "        # Contraction happens over the second residue dimension, similarly to how"
                },
                {
                  "lineNumber": 368,
                  "content": "        final_act = jnp.concatenate(output_features, axis=-1)"
                },
                {
                  "lineNumber": 371,
                  "content": "            self.config.num_channel, initializer=final_init, name=\"output_projection\""
                },
                {
                  "lineNumber": 386,
                  "content": "        config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 387,
                  "content": "        global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 391,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 392,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 406,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 415,
                  "content": "                rate=0.0 if self.global_config.deterministic else c.dropout,"
                },
                {
                  "lineNumber": 422,
                  "content": "        attention_module = InvariantPointAttention(self.config, self.global_config)"
                },
                {
                  "lineNumber": 434,
                  "content": "        final_init = \"zeros\" if self.global_config.zero_init else \"linear\""
                },
                {
                  "lineNumber": 452,
                  "content": "            rigid_update = QuatRigid(self.global_config, init=final_init)(act)"
                },
                {
                  "lineNumber": 455,
                  "content": "        sc = MultiRigidSidechain(c.sidechain, self.global_config)("
                },
                {
                  "lineNumber": 471,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 472,
                  "content": "    global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 484,
                  "content": "      config: config for the iterative fold head."
                },
                {
                  "lineNumber": 485,
                  "content": "      global_config: global config."
                },
                {
                  "lineNumber": 490,
                  "content": "      A dictionary containing residue Rigid's and sidechain positions."
                },
                {
                  "lineNumber": 492,
                  "content": "    c = config"
                },
                {
                  "lineNumber": 504,
                  "content": "    fold_iteration = FoldIteration(c, global_config, name=\"fold_iteration\")"
                },
                {
                  "lineNumber": 545,
                  "content": "        config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 546,
                  "content": "        global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 550,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 551,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 561,
                  "content": "        c = self.config"
                },
                {
                  "lineNumber": 570,
                  "content": "            config=self.config,"
                },
                {
                  "lineNumber": 571,
                  "content": "            global_config=self.global_config,"
                },
                {
                  "lineNumber": 656,
                  "content": "            config=self.config,"
                },
                {
                  "lineNumber": 684,
                  "content": "            config=self.config.intra_chain_fape,"
                },
                {
                  "lineNumber": 687,
                  "content": "        interface_bb_loss, interface_fape = backbone_loss("
                },
                {
                  "lineNumber": 692,
                  "content": "            config=self.config.interface_fape,"
                },
                {
                  "lineNumber": 696,
                  "content": "        bb_loss = intra_chain_bb_loss + interface_bb_loss"
                },
                {
                  "lineNumber": 697,
                  "content": "        ret[\"fape\"] = intra_chain_fape + interface_fape"
                },
                {
                  "lineNumber": 717,
                  "content": "            config=self.config,"
                },
                {
                  "lineNumber": 720,
                  "content": "        ret[\"loss\"] = (1 - self.config.sidechain.weight_frac) * ret["
                },
                {
                  "lineNumber": 722,
                  "content": "        ] + self.config.sidechain.weight_frac * sc_loss[\"loss\"]"
                },
                {
                  "lineNumber": 735,
                  "content": "            config=self.config,"
                },
                {
                  "lineNumber": 739,
                  "content": "        if self.config.structural_violation_loss_weight:"
                },
                {
                  "lineNumber": 742,
                  "content": "                mask=pred_mask, violations=violations, config=self.config"
                },
                {
                  "lineNumber": 784,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 790,
                  "content": "        l1_clamp_distance=config.atom_clamp_distance,"
                },
                {
                  "lineNumber": 791,
                  "content": "        length_scale=config.loss_unit_distance,"
                },
                {
                  "lineNumber": 847,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 871,
                  "content": "        length_scale=config.sidechain.loss_unit_distance,"
                },
                {
                  "lineNumber": 872,
                  "content": "        l1_clamp_distance=config.sidechain.atom_clamp_distance,"
                },
                {
                  "lineNumber": 881,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 888,
                  "content": "    return config.structural_violation_loss_weight * ("
                },
                {
                  "lineNumber": 905,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 911,
                  "content": "    connection_violations = all_atom_multimer.between_residue_bond_loss("
                },
                {
                  "lineNumber": 916,
                  "content": "        tolerance_factor_soft=config.violation_tolerance_factor,"
                },
                {
                  "lineNumber": 917,
                  "content": "        tolerance_factor_hard=config.violation_tolerance_factor,"
                },
                {
                  "lineNumber": 925,
                  "content": "            residue_constants.van_der_waals_radius[name[0]]"
                },
                {
                  "lineNumber": 926,
                  "content": "            for name in residue_constants.atom_types"
                },
                {
                  "lineNumber": 938,
                  "content": "        overlap_tolerance_soft=config.clash_overlap_tolerance,"
                },
                {
                  "lineNumber": 939,
                  "content": "        overlap_tolerance_hard=config.clash_overlap_tolerance,"
                },
                {
                  "lineNumber": 945,
                  "content": "    restype_atom14_bounds = residue_constants.make_atom14_dists_bounds("
                },
                {
                  "lineNumber": 946,
                  "content": "        overlap_tolerance=config.clash_overlap_tolerance,"
                },
                {
                  "lineNumber": 947,
                  "content": "        bond_length_tolerance_factor=config.violation_tolerance_factor,"
                },
                {
                  "lineNumber": 967,
                  "content": "                connection_violations[\"per_residue_violation_mask\"],"
                },
                {
                  "lineNumber": 977,
                  "content": "            \"bonds_c_n_loss_mean\": connection_violations[\"c_n_loss_mean\"],  # ()"
                },
                {
                  "lineNumber": 978,
                  "content": "            \"angles_ca_c_n_loss_mean\": connection_violations[\"ca_c_n_loss_mean\"],  # ()"
                },
                {
                  "lineNumber": 979,
                  "content": "            \"angles_c_n_ca_loss_mean\": connection_violations[\"c_n_ca_loss_mean\"],  # ()"
                },
                {
                  "lineNumber": 980,
                  "content": "            \"connections_per_residue_loss_sum\": connection_violations["
                },
                {
                  "lineNumber": 983,
                  "content": "            \"connections_per_residue_violation_mask\": connection_violations["
                },
                {
                  "lineNumber": 1024,
                  "content": "        mask=seq_mask, value=between_residues[\"connections_per_residue_violation_mask\"]"
                },
                {
                  "lineNumber": 1046,
                  "content": "    config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 1055,
                  "content": "        aatype, residue_constants.restype_num + 1, dtype=jnp.float32"
                },
                {
                  "lineNumber": 1060,
                  "content": "        jnp.asarray(residue_constants.chi_pi_periodic),"
                },
                {
                  "lineNumber": 1084,
                  "content": "    loss = config.chi_weight * sq_chi_loss + config.angle_norm_weight * angle_norm_loss"
                },
                {
                  "lineNumber": 1097,
                  "content": "        jnp.array(residue_constants.chi_pi_periodic, dtype=jnp.float32), aatype"
                },
                {
                  "lineNumber": 1113,
                  "content": "        config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 1114,
                  "content": "        global_config: ml_collections.ConfigDict,"
                },
                {
                  "lineNumber": 1118,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 1119,
                  "content": "        self.global_config = global_config"
                },
                {
                  "lineNumber": 1135,
                  "content": "          dict containing atom positions and frames (in angstrom)"
                },
                {
                  "lineNumber": 1139,
                  "content": "                self.config.num_channel, name=\"input_projection\""
                },
                {
                  "lineNumber": 1143,
                  "content": "        # Sum the activation list (equivalent to concat then Conv1D)"
                },
                {
                  "lineNumber": 1146,
                  "content": "        final_init = \"zeros\" if self.global_config.zero_init else \"linear\""
                },
                {
                  "lineNumber": 1149,
                  "content": "        for _ in range(self.config.num_residual_block):"
                },
                {
                  "lineNumber": 1152,
                  "content": "                self.config.num_channel, initializer=\"relu\", name=\"resblock1\""
                },
                {
                  "lineNumber": 1155,
                  "content": "                self.config.num_channel, initializer=final_init, name=\"resblock2\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/README.md",
              "matches": [
                {
                  "lineNumber": 30,
                  "content": "- &#96;ConfigData&#96; - Container for all configuration objects"
                },
                {
                  "lineNumber": 35,
                  "content": "- &#96;DesignState&#96; - Main design state container combining all data"
                },
                {
                  "lineNumber": 70,
                  "content": "All modules inherit from &#96;BaseModule&#96; which provides common functionality like logging, configuration management, and resource cleanup."
                },
                {
                  "lineNumber": 72,
                  "content": "Each module follows a standard interface:"
                },
                {
                  "lineNumber": 75,
                  "content": "# Standard module interface"
                },
                {
                  "lineNumber": 94,
                  "content": "- Loss function configuration"
                },
                {
                  "lineNumber": 108,
                  "content": "### &#96;mber.core.modules.config&#96;"
                },
                {
                  "lineNumber": 110,
                  "content": "Contains base configuration classes for all modules:"
                },
                {
                  "lineNumber": 112,
                  "content": "- &#96;BaseTemplateConfig&#96; - Template module configuration"
                },
                {
                  "lineNumber": 113,
                  "content": "- &#96;BaseModelConfig&#96; - Model configuration "
                },
                {
                  "lineNumber": 114,
                  "content": "- &#96;BaseLossConfig&#96; - Loss function configuration"
                },
                {
                  "lineNumber": 115,
                  "content": "- &#96;BaseTrajectoryConfig&#96; - Trajectory optimization configuration"
                },
                {
                  "lineNumber": 116,
                  "content": "- &#96;BaseEvaluationConfig&#96; - Evaluation configuration"
                },
                {
                  "lineNumber": 117,
                  "content": "- &#96;BaseEnvironmentConfig&#96; - Computational environment configuration"
                },
                {
                  "lineNumber": 122,
                  "content": "from mber.core.modules.config import BaseTemplateConfig"
                },
                {
                  "lineNumber": 124,
                  "content": "config = BaseTemplateConfig("
                },
                {
                  "lineNumber": 149,
                  "content": "    pdb_content=\"...\",  # PDB file content as string"
                },
                {
                  "lineNumber": 169,
                  "content": "    pdb_content=\"...\",  # PDB file content"
                },
                {
                  "lineNumber": 237,
                  "content": "2. **Configuration**: Define configuration parameters in dataclasses"
                },
                {
                  "lineNumber": 249,
                  "content": "2. **Custom Configs**: Add protocol-specific configuration parameters"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/truncation.py",
              "matches": [
                {
                  "lineNumber": 59,
                  "content": "                 pdb_content: Optional[str] = None,"
                },
                {
                  "lineNumber": 64,
                  "content": "                 include_surrounding_context: Optional[bool] = False):"
                },
                {
                  "lineNumber": 70,
                  "content": "            pdb_content: PDB content as string (alternative to pdb_file)"
                },
                {
                  "lineNumber": 74,
                  "content": "            include_surrounding_context: If False (default), restrict truncation to the specified regions."
                },
                {
                  "lineNumber": 78,
                  "content": "                                       you want more structural context."
                },
                {
                  "lineNumber": 80,
                  "content": "        # Handle either pdb_file or pdb_content"
                },
                {
                  "lineNumber": 81,
                  "content": "        if pdb_content:"
                },
                {
                  "lineNumber": 82,
                  "content": "            # Create a temporary file with the content"
                },
                {
                  "lineNumber": 84,
                  "content": "                f.write(pdb_content)"
                },
                {
                  "lineNumber": 92,
                  "content": "            raise ValueError(\"Either pdb_file or pdb_content must be provided\")"
                },
                {
                  "lineNumber": 106,
                  "content": "        self.include_surrounding_context = include_surrounding_context"
                },
                {
                  "lineNumber": 159,
                  "content": "                raise ValueError(\"PAE file must contain a non-empty list\")"
                },
                {
                  "lineNumber": 188,
                  "content": "        # Process each chain that contains regions of interest"
                },
                {
                  "lineNumber": 225,
                  "content": "                if not self.include_surrounding_context and not residue_in_region:"
                },
                {
                  "lineNumber": 226,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 378,
                  "content": "                continue  # Skip same chain"
                },
                {
                  "lineNumber": 390,
                  "content": "                continue"
                },
                {
                  "lineNumber": 432,
                  "content": "                continue"
                },
                {
                  "lineNumber": 447,
                  "content": "            # This avoids redundant condition checking in the loop"
                },
                {
                  "lineNumber": 495,
                  "content": "        # Use numpy to find discontinuities"
                },
                {
                  "lineNumber": 515,
                  "content": "        \"\"\"Write a new PDB file containing only the truncated residues with chain A.\"\"\""
                },
                {
                  "lineNumber": 529,
                  "content": "            combined_array = struc.concatenate(all_included_atoms)"
                },
                {
                  "lineNumber": 572,
                  "content": "            included_array = struc.concatenate(included_atoms)"
                },
                {
                  "lineNumber": 576,
                  "content": "            excluded_array = struc.concatenate(excluded_atoms)"
                },
                {
                  "lineNumber": 580,
                  "content": "            combined_array = struc.concatenate(all_atoms)"
                },
                {
                  "lineNumber": 634,
                  "content": "            # Read PDB content"
                },
                {
                  "lineNumber": 689,
                  "content": "            continue"
                },
                {
                  "lineNumber": 697,
                  "content": "            continue"
                },
                {
                  "lineNumber": 704,
                  "content": "            continue"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/models/alphafold/LICENSE",
              "matches": [
                {
                  "lineNumber": 10,
                  "content": "      \"License\" shall mean the terms and conditions for use, reproduction,"
                },
                {
                  "lineNumber": 17,
                  "content": "      other entities that control, are controlled by, or are under common"
                },
                {
                  "lineNumber": 18,
                  "content": "      control with that entity. For the purposes of this definition,"
                },
                {
                  "lineNumber": 19,
                  "content": "      \"control\" means (i) the power, direct or indirect, to cause the"
                },
                {
                  "lineNumber": 20,
                  "content": "      direction or management of such entity, whether by contract or"
                },
                {
                  "lineNumber": 29,
                  "content": "      source, and configuration files."
                },
                {
                  "lineNumber": 34,
                  "content": "      and conversions to other media types."
                },
                {
                  "lineNumber": 46,
                  "content": "      separable from, or merely link (or bind by name) to the interfaces of,"
                },
                {
                  "lineNumber": 57,
                  "content": "      communication on electronic mailing lists, source code control systems,"
                },
                {
                  "lineNumber": 60,
                  "content": "      excluding communication that is conspicuously marked or otherwise"
                },
                {
                  "lineNumber": 67,
                  "content": "   2. Grant of Copyright License. Subject to the terms and conditions of"
                },
                {
                  "lineNumber": 74,
                  "content": "   3. Grant of Patent License. Subject to the terms and conditions of"
                },
                {
                  "lineNumber": 85,
                  "content": "      or a Contribution incorporated within the Work constitutes direct"
                },
                {
                  "lineNumber": 86,
                  "content": "      or contributory patent infringement, then any patent licenses"
                },
                {
                  "lineNumber": 93,
                  "content": "      meet the following conditions:"
                },
                {
                  "lineNumber": 109,
                  "content": "          include a readable copy of the attribution notices contained"
                },
                {
                  "lineNumber": 116,
                  "content": "          wherever such third-party notices normally appear. The contents"
                },
                {
                  "lineNumber": 121,
                  "content": "          that such additional attribution notices cannot be construed"
                },
                {
                  "lineNumber": 125,
                  "content": "      may provide additional or different license terms and conditions"
                },
                {
                  "lineNumber": 129,
                  "content": "      the conditions stated in this License."
                },
                {
                  "lineNumber": 133,
                  "content": "      by You to the Licensor shall be under the terms and conditions of"
                },
                {
                  "lineNumber": 134,
                  "content": "      this License, without any additional terms or conditions."
                },
                {
                  "lineNumber": 142,
                  "content": "      origin of the Work and reproducing the content of the NOTICE file."
                },
                {
                  "lineNumber": 148,
                  "content": "      implied, including, without limitation, any warranties or conditions"
                },
                {
                  "lineNumber": 155,
                  "content": "      whether in tort (including negligence), contract, or otherwise,"
                },
                {
                  "lineNumber": 159,
                  "content": "      incidental, or consequential damages of any character arising as a"
                },
                {
                  "lineNumber": 169,
                  "content": "      or other liability obligations and/or rights consistent with this"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/sasa.py",
              "matches": [
                {
                  "lineNumber": 67,
                  "content": "                continue"
                },
                {
                  "lineNumber": 83,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 87,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 146,
                  "content": "                continue"
                },
                {
                  "lineNumber": 170,
                  "content": "                    continue"
                },
                {
                  "lineNumber": 259,
                  "content": "            continue"
                },
                {
                  "lineNumber": 267,
                  "content": "            continue"
                },
                {
                  "lineNumber": 274,
                  "content": "            continue"
                },
                {
                  "lineNumber": 306,
                  "content": "            continue"
                },
                {
                  "lineNumber": 319,
                  "content": "            continue"
                },
                {
                  "lineNumber": 368,
                  "content": "def find_hotspots(pdb_content: str, region_str: Optional[str] = None, "
                },
                {
                  "lineNumber": 379,
                  "content": "        temp_file.write(pdb_content)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/modules/trajectory.py",
              "matches": [
                {
                  "lineNumber": 14,
                  "content": "from mber.core.modules.config import ("
                },
                {
                  "lineNumber": 41,
                  "content": "        model_config: BaseModelConfig,"
                },
                {
                  "lineNumber": 42,
                  "content": "        loss_config: BaseLossConfig,"
                },
                {
                  "lineNumber": 43,
                  "content": "        trajectory_config: BaseTrajectoryConfig,"
                },
                {
                  "lineNumber": 44,
                  "content": "        environment_config: BaseEnvironmentConfig,"
                },
                {
                  "lineNumber": 48,
                  "content": "            config=trajectory_config,"
                },
                {
                  "lineNumber": 49,
                  "content": "            environment_config=environment_config,"
                },
                {
                  "lineNumber": 54,
                  "content": "        # Store configs for specific access"
                },
                {
                  "lineNumber": 55,
                  "content": "        self.model_config = model_config"
                },
                {
                  "lineNumber": 56,
                  "content": "        self.loss_config = loss_config"
                },
                {
                  "lineNumber": 57,
                  "content": "        self.trajectory_config = trajectory_config"
                },
                {
                  "lineNumber": 98,
                  "content": "            continue_signal = self._design_logits(design_state=design_state)"
                },
                {
                  "lineNumber": 100,
                  "content": "        if not continue_signal:"
                },
                {
                  "lineNumber": 112,
                  "content": "                update_esm_bias=self.trajectory_config.update_esm_bias,"
                },
                {
                  "lineNumber": 126,
                  "content": "        self._save_configuration_data(design_state)"
                },
                {
                  "lineNumber": 133,
                  "content": "        optimizer_type = self.trajectory_config.optimizer_type"
                },
                {
                  "lineNumber": 134,
                  "content": "        learning_rate = self.trajectory_config.optimizer_learning_rate"
                },
                {
                  "lineNumber": 136,
                  "content": "        # Log optimizer configuration"
                },
                {
                  "lineNumber": 139,
                  "content": "        # Extract optimizer parameters from trajectory config"
                },
                {
                  "lineNumber": 141,
                  "content": "            \"b1\": self.trajectory_config.optimizer_b1,"
                },
                {
                  "lineNumber": 142,
                  "content": "            \"b2\": self.trajectory_config.optimizer_b2,"
                },
                {
                  "lineNumber": 143,
                  "content": "            \"eps\": self.trajectory_config.optimizer_eps,"
                },
                {
                  "lineNumber": 144,
                  "content": "            \"weight_decay\": self.trajectory_config.optimizer_weight_decay,"
                },
                {
                  "lineNumber": 150,
                  "content": "                \"weight_lr_power\": self.trajectory_config.optimizer_weight_lr_power,"
                },
                {
                  "lineNumber": 151,
                  "content": "                \"warmup_steps\": self.trajectory_config.optimizer_warmup_steps,"
                },
                {
                  "lineNumber": 173,
                  "content": "                data_dir=self.environment_config.af_params_dir,"
                },
                {
                  "lineNumber": 174,
                  "content": "                use_multimer=self.model_config.use_multimer_design,"
                },
                {
                  "lineNumber": 175,
                  "content": "                num_recycles=self.model_config.num_recycles_design,"
                },
                {
                  "lineNumber": 179,
                  "content": "        if self.trajectory_config.update_esm_bias:"
                },
                {
                  "lineNumber": 184,
                  "content": "                self.esm_model = PLM_MODELS[self.trajectory_config.plm_model](device=\"cpu\")"
                },
                {
                  "lineNumber": 187,
                  "content": "        \"\"\"Setup and configure loss functions.\"\"\""
                },
                {
                  "lineNumber": 194,
                  "content": "                \"plddt\": self.loss_config.weights_plddt,"
                },
                {
                  "lineNumber": 195,
                  "content": "                \"con\": self.loss_config.weights_con_intra,"
                },
                {
                  "lineNumber": 196,
                  "content": "                \"i_con\": self.loss_config.weights_con_inter,"
                },
                {
                  "lineNumber": 197,
                  "content": "                \"pae\": self.loss_config.weights_pae_intra,"
                },
                {
                  "lineNumber": 198,
                  "content": "                \"i_pae\": self.loss_config.weights_pae_inter,"
                },
                {
                  "lineNumber": 199,
                  "content": "                \"rg\": self.loss_config.weights_rg,"
                },
                {
                  "lineNumber": 200,
                  "content": "                \"hbond\": self.loss_config.weights_hbond,"
                },
                {
                  "lineNumber": 201,
                  "content": "                \"salt_bridge\": self.loss_config.weights_salt_bridge,"
                },
                {
                  "lineNumber": 202,
                  "content": "                \"seq_ent\": self.loss_config.weights_seq_ent,"
                },
                {
                  "lineNumber": 206,
                  "content": "        # Configure contact parameters"
                },
                {
                  "lineNumber": 207,
                  "content": "        self.af_model.opt[\"con\"].update("
                },
                {
                  "lineNumber": 209,
                  "content": "                \"num\": self.loss_config.intra_contact_number,"
                },
                {
                  "lineNumber": 210,
                  "content": "                \"cutoff\": self.loss_config.intra_contact_distance,"
                },
                {
                  "lineNumber": 216,
                  "content": "        self.af_model.opt[\"i_con\"].update("
                },
                {
                  "lineNumber": 218,
                  "content": "                \"num\": self.loss_config.inter_contact_number,"
                },
                {
                  "lineNumber": 219,
                  "content": "                \"cutoff\": self.loss_config.inter_contact_distance,"
                },
                {
                  "lineNumber": 225,
                  "content": "        add_rg_loss(self.af_model, self.loss_config.weights_rg)"
                },
                {
                  "lineNumber": 226,
                  "content": "        add_i_ptm_loss(self.af_model, self.loss_config.weights_iptm)"
                },
                {
                  "lineNumber": 227,
                  "content": "        add_hbond_loss(self.af_model, self.loss_config.weights_hbond)"
                },
                {
                  "lineNumber": 228,
                  "content": "        add_salt_bridge_loss(self.af_model, self.loss_config.weights_salt_bridge)"
                },
                {
                  "lineNumber": 253,
                  "content": "            # Configure masking options based on trajectory config"
                },
                {
                  "lineNumber": 256,
                  "content": "                if self.trajectory_config.mask_binder_variable_template"
                },
                {
                  "lineNumber": 262,
                  "content": "                if self.trajectory_config.mask_binder_seq"
                },
                {
                  "lineNumber": 268,
                  "content": "                if self.trajectory_config.mask_binder_sidechains"
                },
                {
                  "lineNumber": 272,
                  "content": "            if self.trajectory_config.mask_binder:"
                },
                {
                  "lineNumber": 287,
                  "content": "                rm_aa=self.trajectory_config.rm_aa,"
                },
                {
                  "lineNumber": 288,
                  "content": "                rm_target=self.trajectory_config.mask_target,"
                },
                {
                  "lineNumber": 289,
                  "content": "                rm_target_seq=self.trajectory_config.mask_target_seq,"
                },
                {
                  "lineNumber": 290,
                  "content": "                rm_target_sc=self.trajectory_config.mask_target_sidechains,"
                },
                {
                  "lineNumber": 326,
                  "content": "                models=self.model_config.design_models,"
                },
                {
                  "lineNumber": 332,
                  "content": "                f\"Precompilation failed (but we can continue): {e}\", level=\"warning\""
                },
                {
                  "lineNumber": 353,
                  "content": "                self.trajectory_config.soft_iters"
                },
                {
                  "lineNumber": 354,
                  "content": "                * self.trajectory_config.early_stop_fraction"
                },
                {
                  "lineNumber": 357,
                  "content": "            e_soft=self.trajectory_config.early_stop_fraction,"
                },
                {
                  "lineNumber": 358,
                  "content": "            models=self.model_config.design_models,"
                },
                {
                  "lineNumber": 365,
                  "content": "        if self.trajectory_config.early_stopping:"
                },
                {
                  "lineNumber": 367,
                  "content": "            if best_iptm &lt; self.trajectory_config.early_stop_iptm:"
                },
                {
                  "lineNumber": 377,
                  "content": "                self.trajectory_config.soft_iters"
                },
                {
                  "lineNumber": 378,
                  "content": "                * (1 - self.trajectory_config.early_stop_fraction)"
                },
                {
                  "lineNumber": 380,
                  "content": "            soft=self.trajectory_config.early_stop_fraction,"
                },
                {
                  "lineNumber": 382,
                  "content": "            models=self.model_config.design_models,"
                },
                {
                  "lineNumber": 390,
                  "content": "            iters=self.trajectory_config.temp_iters,"
                },
                {
                  "lineNumber": 394,
                  "content": "            models=self.model_config.design_models,"
                },
                {
                  "lineNumber": 401,
                  "content": "        if self.trajectory_config.hard_iters &gt; 0:"
                },
                {
                  "lineNumber": 403,
                  "content": "                iters=self.trajectory_config.hard_iters,"
                },
                {
                  "lineNumber": 428,
                  "content": "                omit_aas=self.trajectory_config.rm_aa,"
                },
                {
                  "lineNumber": 446,
                  "content": "            hard_iters=self.trajectory_config.pssm_iters,"
                },
                {
                  "lineNumber": 447,
                  "content": "            tries=self.trajectory_config.greedy_tries,"
                },
                {
                  "lineNumber": 448,
                  "content": "            models=self.model_config.design_models,"
                },
                {
                  "lineNumber": 472,
                  "content": "            -self.trajectory_config.pssm_iters :"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/modules/template.py",
              "matches": [
                {
                  "lineNumber": 12,
                  "content": "from mber.core.modules.config import BaseTemplateConfig, BaseEnvironmentConfig"
                },
                {
                  "lineNumber": 31,
                  "content": "        template_config: BaseTemplateConfig,"
                },
                {
                  "lineNumber": 32,
                  "content": "        environment_config: BaseEnvironmentConfig,"
                },
                {
                  "lineNumber": 37,
                  "content": "            config=template_config, "
                },
                {
                  "lineNumber": 38,
                  "content": "            environment_config=environment_config,"
                },
                {
                  "lineNumber": 43,
                  "content": "        self.template_config = template_config  # For specific access if needed"
                },
                {
                  "lineNumber": 77,
                  "content": "        self._save_configuration_data(design_state)"
                },
                {
                  "lineNumber": 88,
                  "content": "            self._log(f\"Initializing ESM2 model on {self.environment_config.device}\")"
                },
                {
                  "lineNumber": 89,
                  "content": "            self.esm_model = PLM_MODELS[self.template_config.plm_model](device=self.environment_config.device)"
                },
                {
                  "lineNumber": 92,
                  "content": "            self._log(f\"Initializing template folding model: {self.template_config.folding_model}\")"
                },
                {
                  "lineNumber": 93,
                  "content": "            self.folding_model = FOLDING_MODELS[self.template_config.folding_model]()"
                },
                {
                  "lineNumber": 118,
                  "content": "                self.template_config.hotspot_strategy"
                },
                {
                  "lineNumber": 124,
                  "content": "                sasa_threshold=self.template_config.sasa_threshold,"
                },
                {
                  "lineNumber": 141,
                  "content": "            pdb_content=design_state.template_data.template_pdb, "
                },
                {
                  "lineNumber": 144,
                  "content": "            include_surrounding_context=design_state.template_data.include_surrounding_context"
                },
                {
                  "lineNumber": 154,
                  "content": "            pae_threshold=self.template_config.pae_threshold,"
                },
                {
                  "lineNumber": 155,
                  "content": "            distance_threshold=self.template_config.distance_threshold,"
                },
                {
                  "lineNumber": 156,
                  "content": "            gap_penalty=self.template_config.gap_penalty"
                },
                {
                  "lineNumber": 178,
                  "content": "            temperature=self.template_config.sampling_temperature,"
                },
                {
                  "lineNumber": 189,
                  "content": "            self.template_config.omit_amino_acids,"
                },
                {
                  "lineNumber": 190,
                  "content": "            temperature=self.template_config.bias_temperature"
                },
                {
                  "lineNumber": 213,
                  "content": "        design_state.template_data.binder_chain = self.template_config.binder_chain"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/modules/evaluation.py",
              "matches": [
                {
                  "lineNumber": 13,
                  "content": "from mber.core.modules.config import ("
                },
                {
                  "lineNumber": 41,
                  "content": "        model_config: BaseModelConfig,"
                },
                {
                  "lineNumber": 42,
                  "content": "        loss_config: BaseLossConfig,"
                },
                {
                  "lineNumber": 43,
                  "content": "        evaluation_config: BaseEvaluationConfig,"
                },
                {
                  "lineNumber": 44,
                  "content": "        environment_config: BaseEnvironmentConfig,"
                },
                {
                  "lineNumber": 48,
                  "content": "            config=evaluation_config,"
                },
                {
                  "lineNumber": 49,
                  "content": "            environment_config=environment_config,"
                },
                {
                  "lineNumber": 54,
                  "content": "        # Store configs for specific access"
                },
                {
                  "lineNumber": 55,
                  "content": "        self.model_config = model_config"
                },
                {
                  "lineNumber": 56,
                  "content": "        self.loss_config = loss_config"
                },
                {
                  "lineNumber": 57,
                  "content": "        self.evaluation_config = evaluation_config"
                },
                {
                  "lineNumber": 105,
                  "content": "        self._save_configuration_data(design_state)"
                },
                {
                  "lineNumber": 122,
                  "content": "                data_dir=self.environment_config.af_params_dir,"
                },
                {
                  "lineNumber": 123,
                  "content": "                use_multimer=self.model_config.use_multimer_eval,"
                },
                {
                  "lineNumber": 124,
                  "content": "                num_recycles=self.model_config.num_recycles_eval,"
                },
                {
                  "lineNumber": 131,
                  "content": "            self.esm_model = PLM_MODELS[self.evaluation_config.plm_model](device=\"cpu\")"
                },
                {
                  "lineNumber": 140,
                  "content": "                f\"Initializing monomer folding model: {self.evaluation_config.monomer_folding_model}\""
                },
                {
                  "lineNumber": 143,
                  "content": "                self.evaluation_config.monomer_folding_model"
                },
                {
                  "lineNumber": 195,
                  "content": "        \"\"\"Setup and configure loss functions for evaluation.\"\"\""
                },
                {
                  "lineNumber": 202,
                  "content": "                \"con\": self.loss_config.weights_con_intra,"
                },
                {
                  "lineNumber": 203,
                  "content": "                \"i_con\": self.loss_config.weights_con_inter,"
                },
                {
                  "lineNumber": 204,
                  "content": "                \"pae\": self.loss_config.weights_pae_intra,"
                },
                {
                  "lineNumber": 205,
                  "content": "                \"i_pae\": self.loss_config.weights_pae_inter,"
                },
                {
                  "lineNumber": 206,
                  "content": "                \"rg\": self.loss_config.weights_rg,"
                },
                {
                  "lineNumber": 207,
                  "content": "                \"iptm\": self.loss_config.weights_iptm,"
                },
                {
                  "lineNumber": 208,
                  "content": "                \"plddt\": self.loss_config.weights_plddt,"
                },
                {
                  "lineNumber": 209,
                  "content": "                \"seq_ent\": self.loss_config.weights_seq_ent,"
                },
                {
                  "lineNumber": 210,
                  "content": "                \"hbond\": self.loss_config.weights_hbond,"
                },
                {
                  "lineNumber": 211,
                  "content": "                \"salt_bridge\": self.loss_config.weights_salt_bridge,"
                },
                {
                  "lineNumber": 215,
                  "content": "        # Configure contact parameters"
                },
                {
                  "lineNumber": 216,
                  "content": "        self.af_complex_model.opt[\"con\"].update("
                },
                {
                  "lineNumber": 218,
                  "content": "                \"num\": self.loss_config.intra_contact_number,"
                },
                {
                  "lineNumber": 219,
                  "content": "                \"cutoff\": self.loss_config.intra_contact_distance,"
                },
                {
                  "lineNumber": 225,
                  "content": "        self.af_complex_model.opt[\"i_con\"].update("
                },
                {
                  "lineNumber": 227,
                  "content": "                \"num\": self.loss_config.inter_contact_number,"
                },
                {
                  "lineNumber": 228,
                  "content": "                \"cutoff\": self.loss_config.inter_contact_distance,"
                },
                {
                  "lineNumber": 234,
                  "content": "        add_rg_loss(self.af_complex_model, self.loss_config.weights_rg)"
                },
                {
                  "lineNumber": 235,
                  "content": "        add_i_ptm_loss(self.af_complex_model, self.loss_config.weights_iptm)"
                },
                {
                  "lineNumber": 236,
                  "content": "        add_hbond_loss(self.af_complex_model, self.loss_config.weights_hbond)"
                },
                {
                  "lineNumber": 238,
                  "content": "            self.af_complex_model, self.loss_config.weights_salt_bridge"
                },
                {
                  "lineNumber": 281,
                  "content": "            models=self.model_config.eval_models,"
                },
                {
                  "lineNumber": 318,
                  "content": "            # Run relaxation with configurable parameters"
                },
                {
                  "lineNumber": 321,
                  "content": "                use_gpu=self.evaluation_config.use_gpu,"
                },
                {
                  "lineNumber": 322,
                  "content": "                max_iterations=self.evaluation_config.max_iterations,"
                },
                {
                  "lineNumber": 323,
                  "content": "                tolerance=self.evaluation_config.tolerance,"
                },
                {
                  "lineNumber": 324,
                  "content": "                stiffness=self.evaluation_config.stiffness,"
                },
                {
                  "lineNumber": 325,
                  "content": "                max_outer_iterations=self.evaluation_config.max_outer_iterations,"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/modules/config.py",
              "matches": [
                {
                  "lineNumber": 8,
                  "content": "    \"\"\"Base configuration for template preparation.\"\"\""
                },
                {
                  "lineNumber": 17,
                  "content": "    include_surrounding_context: bool = False"
                },
                {
                  "lineNumber": 33,
                  "content": "    \"\"\"Base configuration for models.\"\"\""
                },
                {
                  "lineNumber": 44,
                  "content": "    \"\"\"Base configuration for loss functions.\"\"\""
                },
                {
                  "lineNumber": 45,
                  "content": "    weights_con_intra: float = 0.4"
                },
                {
                  "lineNumber": 46,
                  "content": "    weights_con_inter: float = 0.5"
                },
                {
                  "lineNumber": 49,
                  "content": "    intra_contact_number: int = 2"
                },
                {
                  "lineNumber": 50,
                  "content": "    intra_contact_distance: float = 14.0"
                },
                {
                  "lineNumber": 51,
                  "content": "    inter_contact_number: int = 2"
                },
                {
                  "lineNumber": 52,
                  "content": "    inter_contact_distance: float = 20.0"
                },
                {
                  "lineNumber": 63,
                  "content": "    \"\"\"Base configuration for trajectory optimization.\"\"\""
                },
                {
                  "lineNumber": 84,
                  "content": "    # Optimizer configuration"
                },
                {
                  "lineNumber": 97,
                  "content": "    \"\"\"Base configuration for evaluation.\"\"\""
                },
                {
                  "lineNumber": 113,
                  "content": "    \"\"\"Base configuration for environment.\"\"\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/modules/base.py",
              "matches": [
                {
                  "lineNumber": 17,
                  "content": "    Provides common functionality like logging setup, teardown, and config management."
                },
                {
                  "lineNumber": 22,
                  "content": "        config: Any,"
                },
                {
                  "lineNumber": 23,
                  "content": "        environment_config: Any,"
                },
                {
                  "lineNumber": 31,
                  "content": "            config: Module-specific configuration"
                },
                {
                  "lineNumber": 32,
                  "content": "            environment_config: Environment configuration"
                },
                {
                  "lineNumber": 33,
                  "content": "            verbose: Whether to print log messages to console"
                },
                {
                  "lineNumber": 36,
                  "content": "        self.config = config"
                },
                {
                  "lineNumber": 37,
                  "content": "        self.environment_config = environment_config"
                },
                {
                  "lineNumber": 86,
                  "content": "    def _save_configuration_data(self, design_state: DesignState) -&gt; None:"
                },
                {
                  "lineNumber": 88,
                  "content": "        Save configuration data to design state."
                },
                {
                  "lineNumber": 91,
                  "content": "            design_state: The design state to update with configuration data"
                },
                {
                  "lineNumber": 95,
                  "content": "        # Determine configuration attribute name based on module"
                },
                {
                  "lineNumber": 96,
                  "content": "        config_attr = None"
                },
                {
                  "lineNumber": 100,
                  "content": "            config_attr = f\"{module_type}_config\""
                },
                {
                  "lineNumber": 102,
                  "content": "        # Save configuration if attribute exists"
                },
                {
                  "lineNumber": 103,
                  "content": "        if config_attr and hasattr(design_state.config_data, config_attr):"
                },
                {
                  "lineNumber": 104,
                  "content": "            setattr(design_state.config_data, config_attr, asdict(self.config))"
                },
                {
                  "lineNumber": 106,
                  "content": "        # Always save environment config if not already present"
                },
                {
                  "lineNumber": 107,
                  "content": "        if not design_state.config_data.environment_config and hasattr(self, 'environment_config'):"
                },
                {
                  "lineNumber": 108,
                  "content": "            design_state.config_data.environment_config = asdict(self.environment_config)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/modules/__init__.py",
              "matches": [
                {
                  "lineNumber": 2,
                  "content": "from mber.core.modules.config import ("
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/logging.py",
              "matches": [
                {
                  "lineNumber": 3,
                  "content": "Provides consistent logging with both file and console output"
                },
                {
                  "lineNumber": 105,
                  "content": "        Setup a logger with console and optional file handlers."
                },
                {
                  "lineNumber": 110,
                  "content": "            verbose: Whether to print to console in addition to logging"
                },
                {
                  "lineNumber": 115,
                  "content": "            The configured logger and a log store"
                },
                {
                  "lineNumber": 135,
                  "content": "        # Add console handler"
                },
                {
                  "lineNumber": 136,
                  "content": "        console_handler = logging.StreamHandler(sys.stdout)"
                },
                {
                  "lineNumber": 137,
                  "content": "        console_handler.setFormatter(formatter)"
                },
                {
                  "lineNumber": 138,
                  "content": "        logger.addHandler(console_handler)"
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/data/state.py",
              "matches": [
                {
                  "lineNumber": 25,
                  "content": "    \"\"\"Store all configuration parameters from different modules.\"\"\""
                },
                {
                  "lineNumber": 26,
                  "content": "    template_config: Optional[dict] = None"
                },
                {
                  "lineNumber": 27,
                  "content": "    model_config: Optional[dict] = None"
                },
                {
                  "lineNumber": 28,
                  "content": "    loss_config: Optional[dict] = None"
                },
                {
                  "lineNumber": 29,
                  "content": "    trajectory_config: Optional[dict] = None"
                },
                {
                  "lineNumber": 30,
                  "content": "    evaluation_config: Optional[dict] = None"
                },
                {
                  "lineNumber": 31,
                  "content": "    environment_config: Optional[dict] = None"
                },
                {
                  "lineNumber": 45,
                  "content": "    include_surrounding_context: Optional[bool]= False"
                },
                {
                  "lineNumber": 49,
                  "content": "    template_pdb: Optional[str] = None  # Combined PDB file content as string"
                },
                {
                  "lineNumber": 67,
                  "content": "                continue"
                },
                {
                  "lineNumber": 171,
                  "content": "                continue"
                },
                {
                  "lineNumber": 235,
                  "content": "                continue"
                },
                {
                  "lineNumber": 258,
                  "content": "                continue"
                },
                {
                  "lineNumber": 325,
                  "content": "    config_data: ConfigData = field(default_factory=ConfigData)"
                },
                {
                  "lineNumber": 334,
                  "content": "                continue"
                },
                {
                  "lineNumber": 380,
                  "content": "                continue"
                },
                {
                  "lineNumber": 416,
                  "content": "                continue"
                },
                {
                  "lineNumber": 456,
                  "content": "                            continue"
                },
                {
                  "lineNumber": 511,
                  "content": "            dir_path: Path to the directory containing the saved state"
                },
                {
                  "lineNumber": 514,
                  "content": "            Reconstructed DesignState object"
                },
                {
                  "lineNumber": 523,
                  "content": "        # If pickle doesn't exist, could implement reconstruction from dir structure"
                },
                {
                  "lineNumber": 527,
                  "content": "            \"Reconstruction from directory structure without pickle is not implemented.\""
                }
              ]
            },
            {
              "file": "mber-open/src/mber/core/data/serializable.py",
              "matches": [
                {
                  "lineNumber": 66,
                  "content": "                continue"
                }
              ]
            }
          ],
          "totalLines": 1610,
          "totalMatchedLines": 1610
        }
      }
    }
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/cd19-mber/config_data/config_data.json</summary>

</details>
</tool-use>

---


Checking core state for template_pdb and how to bypass UniProt:


---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/core/data/state.py</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/snap/mber-open/src/mber/utils/pdb_utils.py</summary>

</details>
</tool-use>

---


Writing the detailed plan to `notes/2025-02-03 plans.pd`.


---

<tool-use data-tool-type="write" data-tool-name="edit_file_v2">

<details><summary>Tool use: **edit_file_v2** • Edit file: /home/ec2-user/snap/notes/2025-02-03-implementation-plan.md</summary>

</details>

</tool-use>

---


Summary of what’s in the plan and where it lives:

---

**Plan location:** `notes/2025-02-03-implementation-plan.md`

It’s a phased implementation plan that ties the goals in `notes/2025-02-03 plans.pd` and Dan’s four tasks to the current codebase. Here’s the short version.

---

### Phase 0 — How mBER gets from “ID” to structure
- **Finding:** In `mber-open/src/mber/utils/pdb_utils.py`, `process_target(target_id)` already supports:
  - **Local file path** (if the path exists, it reads that PDB),
  - UniProt ID (downloads AlphaFold PDB from EBI),
  - 4-letter PDB code, S3 paths.
- So **Dan 1 is already possible**: use a **path** to a CHL1 PDB as `target_id`; no UniProt needed. The plan suggests documenting this.

---

### Phase 1 — CHL1 with/without exon, no UniProt (Dan 1)
- Use your existing CHL1 FASTA variants and ColabFold to produce two PDBs: **CHL1 with exon 8** and **CHL1 without exon 8**.
- In a CHL1 pipeline (like `cd19-pipeline-linear.py`), set `TemplateData.target_id` to the **path** to the chosen PDB (e.g. `CHL1/template_data/CHL1_with_exon8.pdb`).
- No mBER code change required for “give mBER directly without UniProt ID.”

---

### Phase 2 — Contacts + CDR penalty (Dan 2, binder regions, Germinal-like)
- Add a **contact utility** (e.g. `mber/utils/contacts.py`): given a complex PDB, return binder–target residue contact pairs (and which target residues are bound).
- **Binder regions:** Extend `regions.py` / config so you can specify CDR ranges (e.g. `H:26-35,H:50-65,H:99-110`) and use them in analysis and loss.
- Add a **CDR-contact loss** in `mber/models/colabdesign/loss.py`: penalize strong interface contacts outside the specified CDR regions (Germinal-style), with a config weight (default off).

---

### Phase 3 — Loss design (Dan 3)
- Document existing mBER loss terms (where they live, what they do).
- Add a way to **penalize wrong target or wrong mode**: e.g. dual-target contrastive (same binder vs “exon-in” and “exon-out” target) or masking inter-contact loss to desired epitope. The plan describes options and recommends starting with the dual-target idea for splice variants.

---

### Phase 4 — Splice-variant scoring for CHL1 (Dan 4)
- **Short term:** Design on CHL1_with_exon8 only. In **evaluation**, score each binder against **both** CHL1_with_exon8 and CHL1_without_exon8; report `i_ptm_exon_in`, `i_ptm_exon_out`, and a splice-selectivity score.
- **Later (optional):** Implement a **dual-target loss** in the trajectory (one step = binder vs both targets, reward binding exon-in and penalize binding exon-out).

---

### Phase 5 — Tooling and repo
- **PyMOL:** Use PyMOL for viewing; add a short “Viewing results in PyMOL” section or script.
- **Fork:** If you change mBER source, work in a fork and document it.
- **“Make proteins and see what works”:** Keep CD19 as reference, add a CHL1 run, and briefly document what worked and what didn’t.

---

The full plan in `notes/2025-02-03-implementation-plan.md` has concrete file paths, class names, config ideas, and a dependency/suggested order section so you can implement in small steps. If you tell me which phase you want to do first (e.g. Phase 1 CHL1 pipeline or Phase 2 contact function), I can turn that into exact code changes next.

---

_**User**_

stop running the code

---

_**Agent (model default, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Checking running processes**

The user mentioned stopping the code, but I need to confirm if any long-running processes are active. I'll check the terminals folder to see what's running. If I find any processes, I might need to use Shell commands to kill them. It seems straightforward to read the terminal files first and then act accordingly if something is running. I want to make sure I'm complying with the user's request effectively!</details></think>

---

I’ll check whether anything is currently running in your terminals and stop it if so.

---

<tool-use data-tool-type="unknown" data-tool-name="list_dir_v2">
<details>
<summary>Tool use: **list_dir_v2**</summary>


Parameters:

```json
{
  "targetDirectory": "/home/ec2-user/.cursor/projects/home-ec2-user-snap/terminals"
}
```
Result:

```json
{
  "directoryTreeRoot": {
    "absPath": "/home/ec2-user/.cursor/projects/home-ec2-user-snap/terminals",
    "childrenFiles": [
      {
        "name": "1.txt",
        "terminalMetadata": {
          "cwd": "/home/ec2-user/snap/CHL1",
          "lastCommands": [
            {
              "command": "git pull",
              "exitCode": 0,
              "timestampMs": "1770174046507",
              "durationMs": "213"
            },
            {
              "command": "cd chl1",
              "exitCode": 1,
              "timestampMs": "1770184054106",
              "durationMs": "2"
            },
            {
              "command": "cd CHL1",
              "exitCode": 0,
              "timestampMs": "1770184056787",
              "durationMs": "0"
            }
          ],
          "lastModifiedMs": "1770186509860",
          "currentCommand": {
            "command": "./run_colabfold_chl1.sh",
            "timestampMs": "1770186524910",
            "durationMs": "0"
          }
        }
      }
    ],
    "childrenWereProcessed": true
  }
}
```
Status: **completed**


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file_v2">
<details><summary>Tool use: **read_file_v2** • Read file: /home/ec2-user/.cursor/projects/home-ec2-user-snap/terminals/1.txt</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: kill -INT 3939 || true</summary>

```bash
kill -INT 3939 || true
```

```
Rejected: User chose to skip
```
</details>
</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: kill -TERM 3939 || true</summary>

```bash
kill -TERM 3939 || true
```

```
Rejected: Review cancelled or failed
```
</details>
</tool-use>

---

<tool-use data-tool-type="shell" data-tool-name="run_terminal_command_v2">
<details><summary>Tool use: **run_terminal_command_v2** • Run command: kill -KILL 3939 || true</summary>

```bash
kill -KILL 3939 || true
```

```
Rejected: Review cancelled or failed
```
</details>
</tool-use>

---

